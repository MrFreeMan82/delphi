/******************************************************************************/
/***         Generated by IBExpert 2012.12.16.1 15.09.2016 10:20:02         ***/
/******************************************************************************/

SET SQL DIALECT 3;

SET NAMES WIN1251;

CREATE DATABASE '192.168.10.4:/bd/ib_db/PrInfo.gdb'
USER 'SYSDBA' PASSWORD 'masterkey'
PAGE_SIZE 16384
DEFAULT CHARACTER SET WIN1251 COLLATION WIN1251;



/******************************************************************************/
/***                                Domains                                 ***/
/******************************************************************************/

CREATE DOMAIN DESCRIPTION_FOR_COMPUTER AS
SMALLINT;

CREATE DOMAIN D_ACCESS_RIGHT_ACTION AS
CHAR(1);

CREATE DOMAIN D_ACCESS_RIGHT_CHECK_MODE AS
CHAR(2);

CREATE DOMAIN D_APPROVING_STATUS AS
SMALLINT
DEFAULT 0
NOT NULL;

CREATE DOMAIN D_BLOB_MEMO AS
BLOB SUB_TYPE 1 SEGMENT SIZE 100;

CREATE DOMAIN D_BOOLEAN AS
SMALLINT;

CREATE DOMAIN D_EMAIL AS
VARCHAR(128);

CREATE DOMAIN D_FACT_NUM AS
INTEGER;

CREATE DOMAIN D_HOST_15 AS
CHAR(15);

CREATE DOMAIN D_INN AS
CHAR(15);

CREATE DOMAIN D_MEMO AS
VARCHAR(2047)
COLLATE PXW_CYRL;

CREATE DOMAIN D_MONEY AS
FLOAT;

CREATE DOMAIN D_NAME AS
VARCHAR(128);

CREATE DOMAIN D_NDSNUM AS
CHAR(15);

CREATE DOMAIN D_PERCENT AS
FLOAT
DEFAULT 0;

CREATE DOMAIN D_PHONE AS
CHAR(16);

CREATE DOMAIN D_PHONE_TYPE AS
SMALLINT
DEFAULT 1;

CREATE DOMAIN D_SDELKA_STATE AS
SMALLINT
NOT NULL;

CREATE DOMAIN D_SDELKA_TYPE AS
SMALLINT
NOT NULL;

CREATE DOMAIN D_SIGN AS
SMALLINT;

CREATE DOMAIN D_TEXT_1024 AS
VARCHAR(1024);

CREATE DOMAIN D_TEXT_128 AS
VARCHAR(128)
COLLATE PXW_CYRL;

CREATE DOMAIN D_TEXT_255 AS
VARCHAR(255)
COLLATE PXW_CYRL;

CREATE DOMAIN D_TEXT_30 AS
VARCHAR(30);

CREATE DOMAIN D_TEXT_32 AS
VARCHAR(32);

CREATE DOMAIN D_TEXT_40 AS
VARCHAR(40);

CREATE DOMAIN D_TEXT_50 AS
VARCHAR(50);

CREATE DOMAIN D_TEXT_512 AS
VARCHAR(512);

CREATE DOMAIN D_TEXT_64 AS
VARCHAR(64)
COLLATE PXW_CYRL;

CREATE DOMAIN IP_COMPUTER AS
SMALLINT;



/******************************************************************************/
/***                               Generators                               ***/
/******************************************************************************/

CREATE GENERATOR GEN_CITY_ID;
SET GENERATOR GEN_CITY_ID TO 0;

CREATE GENERATOR GEN_OBJAVLENIE_LOG_ID;
SET GENERATOR GEN_OBJAVLENIE_LOG_ID TO 15219;

CREATE GENERATOR GEN_OBJAV_CONTENT_LOAD_LOG_ID;
SET GENERATOR GEN_OBJAV_CONTENT_LOAD_LOG_ID TO 310716;

CREATE GENERATOR GEN_PAID_SERVICES;
SET GENERATOR GEN_PAID_SERVICES TO 176791;

CREATE GENERATOR GEN_PODACHA_LOG_ID;
SET GENERATOR GEN_PODACHA_LOG_ID TO 1;

CREATE GENERATOR GEN_REG;
SET GENERATOR GEN_REG TO 0;

CREATE GENERATOR GEN_RESERVE_MAP_ID;
SET GENERATOR GEN_RESERVE_MAP_ID TO 990;

CREATE GENERATOR GEN_RESERVE_RECORD_ID;
SET GENERATOR GEN_RESERVE_RECORD_ID TO 6890;

CREATE GENERATOR GEN_SD_NUM;
SET GENERATOR GEN_SD_NUM TO 710701;

CREATE GENERATOR GEN_TEST_ID;
SET GENERATOR GEN_TEST_ID TO 0;

CREATE GENERATOR GEN_USER_ACTIVITY_ID;
SET GENERATOR GEN_USER_ACTIVITY_ID TO 1009;

CREATE GENERATOR G_AG_ID;
SET GENERATOR G_AG_ID TO 597;

CREATE GENERATOR G_AL_ID;
SET GENERATOR G_AL_ID TO 25578;

CREATE GENERATOR G_BIGS_ID;
SET GENERATOR G_BIGS_ID TO 4;

CREATE GENERATOR G_BI_ID;
SET GENERATOR G_BI_ID TO 0;

CREATE GENERATOR G_BT_ID;
SET GENERATOR G_BT_ID TO 0;

CREATE GENERATOR G_CUQ_ID;
SET GENERATOR G_CUQ_ID TO 122872;

CREATE GENERATOR G_CU_ID;
SET GENERATOR G_CU_ID TO 164051;

CREATE GENERATOR G_EXPORT_ID;
SET GENERATOR G_EXPORT_ID TO 222;

CREATE GENERATOR G_FM_ID;
SET GENERATOR G_FM_ID TO 134;

CREATE GENERATOR G_GG_ID;
SET GENERATOR G_GG_ID TO 0;

CREATE GENERATOR G_IS_ID;
SET GENERATOR G_IS_ID TO 4668;

CREATE GENERATOR G_MT_ID;
SET GENERATOR G_MT_ID TO 545757;

CREATE GENERATOR G_OBJAV_CHANGE_LOG;
SET GENERATOR G_OBJAV_CHANGE_LOG TO 3114971;

CREATE GENERATOR G_OBJAV_CONTENT_ID;
SET GENERATOR G_OBJAV_CONTENT_ID TO 446036;

CREATE GENERATOR G_OBJAV_ID;
SET GENERATOR G_OBJAV_ID TO 2509542;

CREATE GENERATOR G_OBJAV_SAME_CODE;
SET GENERATOR G_OBJAV_SAME_CODE TO 1373822;

CREATE GENERATOR G_OB_ID;
SET GENERATOR G_OB_ID TO 2084119;

CREATE GENERATOR G_OC_ID;
SET GENERATOR G_OC_ID TO 0;

CREATE GENERATOR G_OSL_ID;
SET GENERATOR G_OSL_ID TO 978328;

CREATE GENERATOR G_PC_ID;
SET GENERATOR G_PC_ID TO 4;

CREATE GENERATOR G_PD_ID;
SET GENERATOR G_PD_ID TO 7807180;

CREATE GENERATOR G_RB_ID;
SET GENERATOR G_RB_ID TO 586;

CREATE GENERATOR G_RS_ID;
SET GENERATOR G_RS_ID TO 0;

CREATE GENERATOR G_SD_ID;
SET GENERATOR G_SD_ID TO 1218888;

CREATE GENERATOR G_SITE_OBJAV;
SET GENERATOR G_SITE_OBJAV TO 359301;

CREATE GENERATOR G_SL_ID;
SET GENERATOR G_SL_ID TO 2664006;

CREATE GENERATOR G_SR_ID;
SET GENERATOR G_SR_ID TO 45;

CREATE GENERATOR G_ULL_ID;
SET GENERATOR G_ULL_ID TO 250945;

CREATE GENERATOR G_UL_ID;
SET GENERATOR G_UL_ID TO 27172;

CREATE GENERATOR G_US_ID;
SET GENERATOR G_US_ID TO 505;



/******************************************************************************/
/***                               Exceptions                               ***/
/******************************************************************************/

CREATE EXCEPTION E_CANNOT_ADD_CUST_FROM_1C 'Не могу добавить клиента из 1С в БД регистрации!';

CREATE EXCEPTION E_CANNOT_ADD_PHONE 'Добавление телефонов к клиентам временно запрещено.';

CREATE EXCEPTION E_CANNOT_BE_BEZNAL_V_NAL 'Эта сделка не может быть зарегистрирована как "Безнал в нал"';

CREATE EXCEPTION E_CANNOT_CHANGE_DUPLICATE 'Нельзя удалить или отредактировать сделку-дубликат!';

CREATE EXCEPTION E_CANNOT_DELETE_USR 'Удаление данного пользователя не возможно';

CREATE EXCEPTION E_CANNOT_FIND_SDELKA 'Сделка не найдена';

CREATE EXCEPTION E_CAN_EDIT_CURRENT_PODACHA_ONLY 'Нельзя редактировать объявления не текущей подачи';

CREATE EXCEPTION E_DISTRICT_NN 'Поле "Район" должно быть заполнено!';

CREATE EXCEPTION E_KA_DOUBLE_POVTOR 'Повтор этого объявления в этот номер уже был сделан';

CREATE EXCEPTION E_NO_PARENT_OBJAV 'Не найдено объявление, копия для которого создается, либо копия уже есть.';

CREATE EXCEPTION E_NO_SDELKAS_FOR_NS 'Регистрация сделок в "Навчання сьогднi" запрещена';

CREATE EXCEPTION E_OLD_ISSUE 'Нельзя зарегистрировать эту сделку, потому что она идет в старый номер';

CREATE EXCEPTION E_OLD_PODACHA 'Нельзя изменить уже вышедшие объявления';

CREATE EXCEPTION E_SD_NOT_FOUND 'Сделка не найдена!';

CREATE EXCEPTION E_TOO_MANY_MANAGERS_FOR_AGENT 'Нельзя добавить агента двум менеджерам одновременно';

CREATE EXCEPTION E_TOO_MANY_PHONES 'Можно добавить не более 3-х телефонов';

CREATE EXCEPTION E_TOO_MANY_SERVICES 'Слишком много услуг (сделок) на один номер счета';

CREATE EXCEPTION E_TWO_SAME_CONTENTS 'Для одной подачи нельзя назначить два одинаковых объявления';

CREATE EXCEPTION E_WRONG_FACTURA_NUM 'Такой номер счета зарегистрирован';

CREATE EXCEPTION E_WRONG_FACT_NUM 'Номера счетов не должны повторяться в течении месяца';

CREATE EXCEPTION E_WRONG_GAZETA 'Сделка и подачи - в разные газеты. Удалите подачи перед изменением газеты.';

CREATE EXCEPTION E_WRONG_RUB_GAZETA 'Неправильная рубрика для этой газеты!';



SET TERM ^ ; 



/******************************************************************************/
/***                           Stored Procedures                            ***/
/******************************************************************************/

CREATE PROCEDURE A_PODACHAS_ADDED_FIELD_IS_DONE
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE A_SET_OBJAV_SAME_CODE
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE ADD_AGENT_CHANGING_TASK (
    AG_ID_SRC INTEGER,
    SD_ID_SRC INTEGER,
    AG_ID_DST INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE ADD_BONUS (
    AG_ID INTEGER,
    CU_ID INTEGER,
    BT_CHANGE FLOAT,
    BT_COMMENT VARCHAR(128))
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE ADD_SUM_FOR_MANAGER (
    M_ADD FLOAT,
    M_COMMENT VARCHAR(128),
    M_TYPE INTEGER,
    M_US_ID INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE ADD_TO_OTKAZNIK (
    PH_NUMBER CHAR(12))
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE ADDITIONAL_COUNT_FOR_SDELKA (
    AG_ID_INPUT INTEGER,
    SD_ID_INPUT INTEGER)
RETURNS (
    AG_ID INTEGER,
    SD_ID INTEGER,
    OBJAVS_COUNT INTEGER,
    PODACHA_COUNT INTEGER,
    FREE_PODACHA_COUNT INTEGER,
    ZAPAS_COUNT INTEGER,
    PODACHA_NUMS VARCHAR(128),
    SDELKA_SPACE FLOAT,
    IS_NEW_CUST INTEGER,
    ONE_PODACHA_SPACE FLOAT)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE ADM_ADD_PODACHA (
    PARAM_SD_NUM VARCHAR(128),
    PARAM_IS_ID INTEGER,
    PARAM_PD_FREE_OF_CHARGE INTEGER,
    PARAM_US_ID INTEGER,
    PARAM_IP CHAR(15))
RETURNS (
    RESULT CHAR(128))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE ADM_CHANGE_FACT_NUM_AND_DATE (
    PARAM_SD_NUM VARCHAR(128),
    PARAM_SD_FACT_NUM INTEGER,
    PARAM_SD_FACT_DATE TIMESTAMP,
    PARAM_US_ID INTEGER,
    PARAM_IP CHAR(15))
RETURNS (
    RESULT CHAR(128))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE ADM_CHANGE_PAY_DATE (
    PARAM_SD_NUM VARCHAR(128),
    PARAM_PAY_DATE TIMESTAMP,
    PARAM_USR_ID INTEGER,
    PARAM_IP CHAR(15))
RETURNS (
    RESULT CHAR(128))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE ADM_CHANGE_REQ (
    PARAM_SD_NUM VARCHAR(128),
    PARAM_NEW_RQ INTEGER,
    PARAM_IP CHAR(15),
    PARAM_US_ID INTEGER)
RETURNS (
    RESULT CHAR(128))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE ADM_CHANGE_SDELKA_PERCENT (
    PARAM_SD_NUM VARCHAR(128),
    PARAM_SD_PERCENT FLOAT,
    PARAM_US_ID INTEGER,
    PARAM_IP CHAR(15))
RETURNS (
    RESULT CHAR(128),
    SD_DATE TIMESTAMP)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE ADM_CHANGE_SDELKA_SUM (
    PARAM_SD_NUM VARCHAR(128),
    PARAM_SD_SUM FLOAT,
    PARAM_US_ID INTEGER,
    PARAM_IP CHAR(15))
RETURNS (
    RESULT CHAR(128))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE ADM_DELETE_PODACHA (
    PARAM_SD_NUM VARCHAR(128),
    PARAM_IS_ID INTEGER,
    PARAM_US_ID INTEGER,
    PARAM_IP CHAR(15))
RETURNS (
    RESULT CHAR(128))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE ADM_DELETE_SDELKA (
    PARAM_SD_NUM VARCHAR(128),
    PARAM_US_ID INTEGER,
    PARAM_IP CHAR(15))
RETURNS (
    RESULT CHAR(128))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE ADM_MOVE_NEW_SDELKAS (
    PARAM_US_ID INTEGER,
    PARAM_IP CHAR(15),
    PARAM_SD_NUM_OLD VARCHAR(64),
    PARAM_AG_NEW INTEGER)
RETURNS (
    RESULT CHAR(128))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE ADM_ROLLBACK_ISSUE_ST
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE ADM_SDELKA_APPROVING_DATE_NEW (
    PARAM_SD_NUM VARCHAR(128))
RETURNS (
    RESULT TIMESTAMP)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE ADM_SDELKA_PAY_DATE_NEW (
    PARAM_SD_NUM VARCHAR(128))
RETURNS (
    RESULT TIMESTAMP)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE ADM_SDELKA_PAY_INFO (
    PARAM_SD_NUM VARCHAR(128))
RETURNS (
    PAY_SUM DOUBLE PRECISION,
    PAY_DATE TIMESTAMP,
    USR VARCHAR(255))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE APPROVE_SDELKA (
    AG_ID INTEGER,
    SD_ID INTEGER,
    US_ID INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE BACKUP_SDELKA (
    AG_ID INTEGER,
    SD_ID INTEGER,
    US_ID INTEGER)
RETURNS (
    NEW_SD_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE BEZNAL_V_NAL (
    AG_ID INTEGER,
    SD_ID INTEGER,
    SD_PERCENT FLOAT)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE BUH_UPDATE_SDELKA (
    AGENT_ID INTEGER,
    SDELKA_ID INTEGER,
    PAYED_SUM FLOAT,
    FACT_DATE TIMESTAMP,
    FACT_NUM INTEGER)
RETURNS (
    RESULT INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE CAN_ADD_USR_RIGHT (
    US_ID INTEGER,
    AG_ID INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE CHANGE_AGENT_FOR_SDELKA (
    AG_ID_WAS INTEGER,
    SD_ID_WAS INTEGER,
    AG_ID_NEW INTEGER)
RETURNS (
    SDID_NEW INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE CHANGE_GAZETA
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE CHECK_FOR_NEW_CUSTOMER (
    AG_ID INTEGER,
    CU_ID INTEGER,
    SD_DATE TIMESTAMP,
    GZ_ID INTEGER)
RETURNS (
    RESULT INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE CHECK_PHONE_WILL_BE_IN_OTKAZNIK (
    AG_ID_INPUT INTEGER,
    PH_NUMBER_INPUT VARCHAR(16),
    LAST_ISSUE_PR INTEGER,
    LAST_ISSUE_NS INTEGER,
    LAST_ISSUE_SR INTEGER,
    LAST_ISSUE_RZ INTEGER,
    LAST_ISSUE_RK INTEGER,
    LASTISSDATE TIMESTAMP)
RETURNS (
    WILL_BE SMALLINT)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE CLEAR_DOUBLES
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE CLOSE_ISSUE (
    GZ_ID INTEGER,
    US_ID INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE COMPARE_SUMS
RETURNS (
    MT_DATE DATE,
    MT_SUM FLOAT,
    SD_SUM FLOAT)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE COPY_OBJAV (
    AG_ID_SRC INTEGER,
    SD_ID_SRC INTEGER,
    OB_ID_SRC INTEGER,
    AG_ID_DST INTEGER,
    SD_ID_DST INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE COPY_OBJAVLENIE (
    OBJAV_ID_SRC INTEGER,
    PD_ID_DST INTEGER,
    NEW_CONTENT INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE COPY_SITE_OBJAV (
    CONTENT_ID_FROM INTEGER,
    CONTENT_ID_TO INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE COPY_SITE_OBJAV_ID (
    SITE_OBJAV_ID_FROM INTEGER,
    CONTENT_ID_TO INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE COUNT_CUST_BONUS (
    AG_ID_INPUT INTEGER,
    CU_ID_INPUT INTEGER)
RETURNS (
    AG_ID INTEGER,
    CU_ID INTEGER,
    CUST_BONUS FLOAT)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE COUNT_PERCENT (
    AG_ID INTEGER,
    SD_ID INTEGER)
RETURNS (
    PERCENT FLOAT)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE COUNT_SDELKA_SERVICES (
    IN_FACT_NUM INTEGER,
    IN_FACT_DATE TIMESTAMP)
RETURNS (
    SERVICE_COUNT INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE COUNT_SUM (
    AG_ID INTEGER,
    SD_ID INTEGER)
RETURNS (
    SUMMA FLOAT)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE COUNT_SUM_NEW (
    AG_ID INTEGER,
    SD_ID INTEGER)
RETURNS (
    SUMMA FLOAT)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE CUST_BY_DATE (
    US_ID INTEGER,
    DATE_FROM TIMESTAMP,
    DATE_TO TIMESTAMP)
RETURNS (
    AG_ID INTEGER,
    CUST_NEW INTEGER,
    CUST_OLD INTEGER,
    CUST_NEW_SDELKA_COUNT INTEGER,
    CUST_NEW_SDELKA_SUM FLOAT,
    CUST_OLD_SDELKA_COUNT INTEGER,
    CUST_OLD_SDELKA_SUM FLOAT)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE CUST_INFO_LIST (
    GZ_ID INTEGER)
RETURNS (
    CU_ID_COMPOUND CHAR(23),
    CU_INFO VARCHAR(255))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE CUST_KA_INFO_LIST
RETURNS (
    CU_NAME VARCHAR(255),
    CU_KA_INFO_FULL VARCHAR(1023))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE DAYOFWEEK_NAME (
    DAY_NUM INTEGER)
RETURNS (
    DAY_NAME VARCHAR(2))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE DELETE_CUST (
    CU_ID INTEGER,
    AG_ID INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE DELETE_SDELKA (
    AG_ID INTEGER,
    SD_ID INTEGER,
    COMMENT VARCHAR(128))
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE DROP_CHANGES_IN_SDELKA (
    AG_ID INTEGER,
    SD_ID INTEGER,
    US_ID INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE EVENT_CHANGE (
    EV_ID INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE EXPORT_XML (
    GZ_ID INTEGER)
RETURNS (
    OBJAV_TEXT VARCHAR(2047),
    OBJAV_ID INTEGER,
    RUBRIKA_ID INTEGER,
    RUBRIKA_NAME VARCHAR(128),
    ISS_NAME VARCHAR(10),
    SITE_VACANCY_NAME VARCHAR(128),
    SITE_EMAIL VARCHAR(128),
    SITE_TEL VARCHAR(128),
    SITE_CONTACT VARCHAR(255),
    SITE_DONT_UPLOAD SMALLINT,
    SITE_ZP INTEGER,
    GZ_RB_ID INTEGER,
    K INTEGER,
    SITE_EMPLOYER VARCHAR(255),
    C_NAME VARCHAR(128),
    ED_NAME VARCHAR(32),
    EX_NAME VARCHAR(32),
    CU_COMPANY_ID INTEGER,
    CU_ADDRESS VARCHAR(255),
    EXP_DATE TIMESTAMP,
    PT_ID INTEGER,
    PD_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE EXTRACT_VIP_MODULES
RETURNS (
    AG_NAME VARCHAR(128),
    AG_ID INTEGER,
    SD_ID INTEGER,
    CU_NAME VARCHAR(128),
    SD_DATE TIMESTAMP,
    FM_NAME VARCHAR(128),
    RB_NAME VARCHAR(128),
    PT_NAME VARCHAR(64),
    SD_ALL_PAYED INTEGER,
    GZ_NAME VARCHAR(64),
    GZ_ID INTEGER,
    CONTENT_ID INTEGER,
    PODACHA_NUMS VARCHAR(128),
    RB_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE FILL_OBJAVS_TEMP
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE FILL_OBJAVS_TEMP_OTKAZNIK
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE FIND_COPY (
    AG_ID INTEGER,
    SD_ID INTEGER)
RETURNS (
    COPY_SD_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE FIND_NOT_PAYED_SDELKA_BY_PHONE (
    PH_NUMBER_INPUT CHAR(16))
RETURNS (
    AG_ID INTEGER,
    SD_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE FIND_SDELKA_BY_FACT_NUM (
    AG_ID_INPUT INTEGER,
    SD_FACT_NUM_INPUT INTEGER)
RETURNS (
    AG_ID INTEGER,
    SD_ID INTEGER,
    CU_ID INTEGER,
    CU_NAME VARCHAR(128),
    SD_ID_COMPOUND CHAR(12),
    PT_ID INTEGER,
    SD_ZAPAS INTEGER,
    AG_NAME VARCHAR(128),
    SD_LAST_ISSUE_IS_ID INTEGER,
    SD_LAST_ISSUE_IS_NAME VARCHAR(10),
    SD_FACT_NUM INTEGER,
    SD_ALL_PAYED INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE FIND_SDELKA_BY_NUMBER (
    AG_ID_INPUT INTEGER,
    SD_ID_INPUT INTEGER)
RETURNS (
    AG_ID INTEGER,
    SD_ID INTEGER,
    CU_ID INTEGER,
    CU_NAME VARCHAR(128),
    SD_ID_COMPOUND CHAR(12),
    PT_ID INTEGER,
    SD_ZAPAS INTEGER,
    AG_NAME VARCHAR(128),
    SD_LAST_ISSUE_IS_ID INTEGER,
    SD_LAST_ISSUE_IS_NAME VARCHAR(10),
    SD_FACT_NUM INTEGER,
    SD_ALL_PAYED INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE FIND_SDELKA_BY_OKPO (
    AG_ID_INPUT INTEGER,
    CU_OKPO CHAR(10))
RETURNS (
    AG_ID INTEGER,
    SD_ID INTEGER,
    CU_ID INTEGER,
    CU_NAME VARCHAR(128),
    SD_ID_COMPOUND CHAR(12),
    PT_ID INTEGER,
    SD_ZAPAS INTEGER,
    AG_NAME VARCHAR(128),
    SD_LAST_ISSUE_IS_ID INTEGER,
    SD_LAST_ISSUE_IS_NAME VARCHAR(10),
    SD_FACT_NUM INTEGER,
    SD_ALL_PAYED INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE FIND_SDELKA_BY_PHONE (
    AG_ID_INPUT INTEGER,
    PH_NUMBER_INPUT CHAR(16))
RETURNS (
    AG_ID INTEGER,
    SD_ID INTEGER,
    CU_ID INTEGER,
    CU_NAME VARCHAR(128),
    SD_ID_COMPOUND CHAR(12),
    PT_ID INTEGER,
    SD_ZAPAS INTEGER,
    AG_NAME VARCHAR(128),
    SD_LAST_ISSUE_IS_ID INTEGER,
    SD_LAST_ISSUE_IS_NAME VARCHAR(10),
    SD_FACT_NUM INTEGER,
    SD_ALL_PAYED INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE FIND_SDELKA_BY_PHONE_AND_AGENT (
    AG_ID_INPUT INTEGER,
    PH_NUMBER_INPUT CHAR(16))
RETURNS (
    SD_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE FIND_SDELKA_BY_PHONE_SIMPLE (
    PH_NUMBER_INPUT CHAR(16))
RETURNS (
    AG_ID INTEGER,
    SD_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE FIND_SDELKA_BY_SDNUM2 (
    SD_NUM VARCHAR(128))
RETURNS (
    AG_ID INTEGER,
    SD_ID INTEGER,
    CU_ID INTEGER,
    CU_NAME VARCHAR(128),
    SD_ID_COMPOUND CHAR(12),
    PT_ID INTEGER,
    SD_ZAPAS INTEGER,
    AG_NAME VARCHAR(128),
    SD_LAST_ISSUE_IS_ID INTEGER,
    SD_LAST_ISSUE_IS_NAME VARCHAR(10),
    SD_FACT_NUM INTEGER,
    SD_ALL_PAYED INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE FIND_SDELKA_BY_TEXT (
    AG_ID_INPUT INTEGER,
    OB_TEXT_INPUT VARCHAR(127),
    IS_ID_INPUT INTEGER)
RETURNS (
    AG_ID INTEGER,
    SD_ID INTEGER,
    CU_ID INTEGER,
    CU_NAME VARCHAR(128),
    SD_ID_COMPOUND CHAR(12),
    PT_ID INTEGER,
    SD_ZAPAS INTEGER,
    AG_NAME VARCHAR(128),
    SD_LAST_ISSUE_IS_ID INTEGER,
    SD_LAST_ISSUE_IS_NAME VARCHAR(10),
    SD_FACT_NUM INTEGER,
    SD_ALL_PAYED INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE FIND_SDELKA_FIELDS (
    AG_ID_INPUT INTEGER,
    SD_ID_INPUT INTEGER)
RETURNS (
    CU_ID INTEGER,
    CU_NAME VARCHAR(128),
    SD_ID_COMPOUND CHAR(12),
    PT_ID INTEGER,
    SD_ZAPAS INTEGER,
    AG_NAME VARCHAR(128),
    SD_LAST_ISSUE_IS_ID INTEGER,
    SD_LAST_ISSUE_IS_NAME VARCHAR(10),
    SD_FACT_NUM INTEGER,
    SD_ALL_PAYED INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE FOR_1C (
    DATE_FROM TIMESTAMP,
    DATE_TO TIMESTAMP,
    ONLY_NOT_PAYED INTEGER)
RETURNS (
    FACT_NUM INTEGER,
    FACT_DATE TIMESTAMP,
    AGENT_ID INTEGER,
    OBJAV_ID INTEGER,
    GAZETA_ID INTEGER,
    GAZETA_NAM CHAR(32),
    NOMERA CHAR(64),
    RUBRIKA_ID INTEGER,
    RUBRIKA_NA CHAR(32),
    FORMAT_ID INTEGER,
    FORMAT_NAM CHAR(32),
    COST FLOAT,
    PAYED FLOAT,
    PAYTYPE_ID INTEGER,
    PAYTYPE_NA CHAR(64),
    CUST_OKPO CHAR(12),
    CUST_NAME CHAR(64))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE FOR_1C_2_SDELKA (
    DATE_FROM TIMESTAMP,
    DATE_TO TIMESTAMP,
    ONLY_NOT_PAYED INTEGER)
RETURNS (
    FAC_NUM INTEGER,
    FAC_DATE TIMESTAMP,
    COST FLOAT,
    PAYED FLOAT,
    CUS_OKPO CHAR(12),
    CUS_NAME CHAR(64))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE FOR_1C_2_SERVICE (
    DATE_FROM TIMESTAMP,
    DATE_TO TIMESTAMP,
    ONLY_NOT_PAYED INTEGER)
RETURNS (
    FAC_NUM INTEGER,
    FAC_DATE TIMESTAMP,
    SERV_ID INTEGER,
    DESCRIPT VARCHAR(200),
    COST FLOAT)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE GET_CURRENT_ISSUE (
    IN_GZ_ID INTEGER)
RETURNS (
    IS_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE GET_CURRENT_PODACHA (
    AG_ID INTEGER,
    SD_ID INTEGER)
RETURNS (
    PD_ID INTEGER,
    IS_ID INTEGER,
    PD_IS_DONE INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE GET_CUST_PHONES (
    AG_ID INTEGER,
    CU_ID INTEGER)
RETURNS (
    CU_PHONES VARCHAR(1024))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE GET_DEL_SDELKA_PHONES_STR (
    AG_ID INTEGER,
    SD_ID INTEGER)
RETURNS (
    PHONES VARCHAR(255))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE GET_FIELDS_FOR_MODULE (
    AG_ID INTEGER,
    SD_ID INTEGER,
    RUB_ID INTEGER)
RETURNS (
    AGENT_NAME VARCHAR(128),
    FM_ID INTEGER,
    OBJAV_ID INTEGER,
    OLD_CONTENT_ID INTEGER,
    PICTURE_TO_INET INTEGER,
    VAC_COUNT INTEGER,
    FM_NAME VARCHAR(10),
    RB_NAME VARCHAR(32),
    PODACHA_NUM VARCHAR(128),
    FM_PICTURE_SIZE VARCHAR(128),
    RB_ID INTEGER,
    CLIENT_NAME VARCHAR(128),
    CUQ_REG INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE GET_INTERCEPTIONS
RETURNS (
    AG_ID INTEGER,
    SD_ID INTEGER,
    PH_NUMBER VARCHAR(12),
    AG_ID_INTERCEPTED INTEGER,
    CU_ID_INTERCEPTED INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE GET_IS_ID_GAZETA (
    IN_IS_ID INTEGER)
RETURNS (
    OUT_IS_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE GET_IS_SDELKA_CURRENT_ISSUE (
    AG_ID INTEGER,
    SD_ID INTEGER)
RETURNS (
    IS_CURRENT_ISSUE INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE GET_ISSUE_ID (
    GZ_ID INTEGER,
    IS_NAME VARCHAR(10),
    IS_YEAR INTEGER)
RETURNS (
    IS_ID INTEGER,
    IS_NAME_COMPOSED VARCHAR(50))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE GET_MAX_FORMAT_AND_RUBRIKA (
    AG_ID INTEGER,
    SD_ID INTEGER)
RETURNS (
    FM_ID INTEGER,
    RB_ID INTEGER,
    COST FLOAT)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE GET_NAME_GZ (
    I INTEGER)
RETURNS (
    NAME_GZ VARCHAR(10))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE GET_NEXT_EXPORT_ID
RETURNS (
    EXPORT_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE GET_NEXT_FACT_NUM (
    AG_ID INTEGER)
RETURNS (
    FACT_NUM INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE GET_NEXT_PODACHA
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE GET_OBJAV_TEXT (
    AG_ID INTEGER,
    SD_ID INTEGER,
    OB_ID INTEGER)
RETURNS (
    OB_TEXT VARCHAR(2047),
    OB_ID_RES INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE GET_OLD_CUST_OBJAVLENIE (
    AG_ID_INPUT INTEGER,
    CU_ID_INPUT INTEGER,
    IS_ID_INPUT INTEGER,
    FM_ID_INPUT INTEGER)
RETURNS (
    OBJAV_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE GET_OLD_CUST_OBJAVLENIE_RUB (
    AG_ID_INPUT INTEGER,
    CU_ID_INPUT INTEGER,
    IS_ID_INPUT INTEGER,
    FM_ID_INPUT INTEGER,
    RB_ID_INPUT INTEGER)
RETURNS (
    OBJAV_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE GET_OLD_CUST_OBJAVLENIE_RUB_NEW (
    AG_ID_INPUT INTEGER,
    CU_ID_INPUT INTEGER,
    IS_ID_INPUT INTEGER,
    FM_ID_INPUT INTEGER,
    RB_ID_INPUT INTEGER)
RETURNS (
    OBJAV_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE GET_OLD_CUST_TEXTS (
    AG_ID_INPUT INTEGER,
    CU_ID_INPUT INTEGER,
    IS_ID_INPUT INTEGER,
    FM_ID_INPUT INTEGER)
RETURNS (
    AG_ID INTEGER,
    SD_ID INTEGER,
    OB_ID INTEGER,
    IS_OBJAVLENIE INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE GET_OLD_CUST_TEXTS_RUB (
    AG_ID_INPUT INTEGER,
    CU_ID_INPUT INTEGER,
    IS_ID_INPUT INTEGER,
    FM_ID_INPUT INTEGER,
    RB_ID_INPUT INTEGER)
RETURNS (
    AG_ID INTEGER,
    SD_ID INTEGER,
    OB_ID INTEGER,
    IS_OBJAVLENIE INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE GET_OLD_SDELKA_TEXTS (
    AG_ID_INPUT INTEGER,
    SD_ID_INPUT INTEGER,
    IS_ID_INPUT INTEGER)
RETURNS (
    AG_ID INTEGER,
    SD_ID INTEGER,
    OB_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE GET_RESERVE_MAP (
    GZ_ID INTEGER,
    IS_IN INTEGER,
    RB_IN INTEGER)
RETURNS (
    RM_ID INTEGER,
    PAGE_MAP VARCHAR(1024),
    LOCK_USR INTEGER,
    RB_ID INTEGER,
    IS_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE GET_SD_FORMAT (
    AG_ID INTEGER,
    SD_ID INTEGER)
RETURNS (
    FM_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE GET_SDELKA_CUST_ID (
    AG_ID INTEGER,
    SD_ID INTEGER)
RETURNS (
    CU_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE GET_SDELKA_PHONES_STR (
    AG_ID INTEGER,
    SD_ID INTEGER)
RETURNS (
    PHONES VARCHAR(1000))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE GET_SDELKA_RUBRIKAS (
    AG_ID_INPUT INTEGER,
    SD_ID_INPUT INTEGER)
RETURNS (
    SD_RUBRIKAS VARCHAR(128))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE IS_IN_OTKAZNIK (
    AG_ID INTEGER,
    SD_ID INTEGER)
RETURNS (
    IS_IN INTEGER,
    AG_ID_IN INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE IS_INTERCEPTED (
    AG_ID_INPUT INTEGER,
    PH_NUMBER CHAR(12))
RETURNS (
    RESULT INTEGER,
    AG_ID INTEGER,
    AG_ID_INTERCEPTED INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE IS_RIGHT_NAME_GAZETA (
    AG_ID_INPUT INTEGER,
    SD_ID_INPUT INTEGER,
    NAME_GZ_INPUT VARCHAR(10))
RETURNS (
    IS_RIGHT INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE IS_RIGHT_NAME_GZ (
    AG_ID_INPUT INTEGER,
    SD_ID_INPUT INTEGER,
    NAME_GZ_INPUT VARCHAR(10))
RETURNS (
    IS_RIGHT INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE ISSUE_STATISTIC (
    IS_ID INTEGER)
RETURNS (
    RB_NAME VARCHAR(256),
    RUB_SPACE1 DOUBLE PRECISION,
    RUB_SPACE2 DOUBLE PRECISION,
    RUB_DIFF DOUBLE PRECISION,
    RUB_COUNT1 INTEGER,
    RUB_COUNT2 INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE KA_NEW_POVTOR (
    AG_ID_SRC INTEGER,
    SD_ID INTEGER,
    OB_ID INTEGER,
    IS_MODULE SMALLINT,
    AG_ID_DST INTEGER,
    IS_ID INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE KASSA_NAL (
    AG_ID INTEGER,
    SD_ID INTEGER,
    SD_PERCENT FLOAT)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE LOCK_RUBRIKAS (
    US_ID INTEGER,
    DO_LOCK SMALLINT)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE LOG_SDELKA_CHANGES (
    AG_ID INTEGER,
    SD_ID INTEGER,
    US_ID INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE LOG_USER (
    EDITORNAME VARCHAR(64),
    EDITORADDR VARCHAR(64))
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE MODULE_CHANGE_HISTORY (
    CONTENT_ID INTEGER,
    DPTH INTEGER)
RETURNS (
    CONT_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE MODULE_LOAD_LOG (
    US_ID INTEGER,
    OBJAV_ID INTEGER,
    CONTENT_ID INTEGER,
    TYP INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE MODULI_V_NOMER (
    GZ_ID INTEGER)
RETURNS (
    AG_ID INTEGER,
    SD_ID INTEGER,
    OB_ID INTEGER,
    RB_ID INTEGER,
    FM_ID INTEGER,
    OBJAV_HAS_ATTENTION SMALLINT,
    CONTENT_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE MODULI_V_NOMER_2 (
    GZ_ID INTEGER)
RETURNS (
    AG_ID INTEGER,
    SD_ID INTEGER,
    OB_ID INTEGER,
    RB_ID INTEGER,
    FM_ID INTEGER,
    OBJAV_HAS_ATTENTION SMALLINT,
    CONTENT_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE MODULI_V_NOMER_NOMER (
    IS_ID INTEGER)
RETURNS (
    AG_ID INTEGER,
    SD_ID INTEGER,
    OB_ID INTEGER,
    RB_ID INTEGER,
    FM_ID INTEGER,
    OBJAV_HAS_ATTENTION SMALLINT,
    CONTENT_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE MODULI_V_NOMER_TEST (
    GZ_ID INTEGER)
RETURNS (
    AG_ID INTEGER,
    SD_ID INTEGER,
    OB_ID INTEGER,
    RB_ID INTEGER,
    FM_ID INTEGER,
    OBJAV_HAS_ATTENTION SMALLINT,
    CONTENT_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE NAL_KASSA (
    AG_ID INTEGER,
    SD_ID INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE NAL_V_BEZNAL (
    AG_ID INTEGER,
    SD_ID INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE NAL_V_KREDIT (
    AG_ID INTEGER,
    SD_ID INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE NEW_OBJAVS_IN_ISSUE (
    IS_ID INTEGER)
RETURNS (
    AG_ID INTEGER,
    SD_ID INTEGER,
    OB_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE NEW_SDELKAS_IN_ISSUE (
    IS_ID INTEGER)
RETURNS (
    AG_ID INTEGER,
    SD_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE NEXT_AG_ID
RETURNS (
    NEXT_AG_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE NEXT_CU_ID
RETURNS (
    NEXT_CU_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE NEXT_CUQ_ID
RETURNS (
    NEXT_CUQ_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE NEXT_CURRENT_ISSUE (
    GZ_ID INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE NEXT_FM_ID
RETURNS (
    NEXT_FM_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE NEXT_GG_ID
RETURNS (
    NEXT_GG_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE NEXT_IS_ID
RETURNS (
    NEXT_IS_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE NEXT_OB_ID
RETURNS (
    NEXT_OB_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE NEXT_RB_ID
RETURNS (
    NEXT_RB_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE NEXT_SD_ID (
    AG_ID INTEGER)
RETURNS (
    NEXT_SD_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE NEXT_US_ID
RETURNS (
    NEXT_US_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE OB_STATE_LOG (
    OB_ID INTEGER,
    US_ID INTEGER,
    NEW_STATE INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE OBJAV_CONTENT_DELETE (
    BEGIN_DATE TIMESTAMP,
    END_DATE TIMESTAMP)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE OBJAV_DUPLICATE (
    P_DUPLICATE_AG_ID INTEGER,
    P_DUPLICATE_SD_ID INTEGER,
    P_SOURCE_OB_ID INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE OBJAV_DUPLICATE_ALL (
    P_DUPLICATE_AG_ID INTEGER,
    P_DUPLICATE_SD_ID INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE OBJAV_LIST_FOR_DESIGN (
    GZ_ID INTEGER)
RETURNS (
    AG_ID INTEGER,
    SD_ID INTEGER,
    OB_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE OBJAV_LIST_FOR_INT_NABOR (
    GZ_ID INTEGER)
RETURNS (
    AG_ID INTEGER,
    SD_ID INTEGER,
    OB_ID INTEGER,
    RB_ID INTEGER,
    FM_ID INTEGER,
    OBJAV_HAS_ATTENTION INTEGER,
    CONTENT_ID INTEGER,
    K INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE OBJAV_LIST_FOR_INT_NABOR2 (
    GZ_ID INTEGER)
RETURNS (
    AG_ID INTEGER,
    SD_ID INTEGER,
    OB_ID INTEGER,
    RB_ID INTEGER,
    FM_ID INTEGER,
    OBJAV_HAS_ATTENTION INTEGER,
    CONTENT_ID INTEGER,
    K INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE OBJAV_LIST_FOR_KORREKTURA (
    GZ_ID INTEGER)
RETURNS (
    AG_ID INTEGER,
    SD_ID INTEGER,
    OB_ID INTEGER,
    OB_TYPE INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE OBJAV_LIST_FOR_NABOR (
    GZ_ID INTEGER)
RETURNS (
    AG_ID INTEGER,
    SD_ID INTEGER,
    OB_ID INTEGER,
    OB_TYPE INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE OBJAV_LIST_KA
RETURNS (
    AG_ID INTEGER,
    SD_ID INTEGER,
    OB_ID INTEGER,
    RB_ID INTEGER,
    PD_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE OBJAV_LIST_V_INTERNET (
    GZ_ID INTEGER)
RETURNS (
    OBJAV_TEXT VARCHAR(2047),
    OBJAV_ID INTEGER,
    RUBRIKA_ID INTEGER,
    RUBRIKA_NAME VARCHAR(128),
    ISS_NAME VARCHAR(10),
    SITE_VACANCY_NAME VARCHAR(128),
    SITE_EMAIL VARCHAR(128),
    SITE_TEL VARCHAR(128),
    SITE_CONTACT VARCHAR(255),
    SITE_DONT_UPLOAD SMALLINT,
    SITE_ZP INTEGER,
    GZ_RB_ID INTEGER,
    K INTEGER,
    SITE_EMPLOYER VARCHAR(255),
    C_NAME VARCHAR(128),
    ED_NAME VARCHAR(32),
    EX_NAME VARCHAR(32),
    CU_COMPANY_ID INTEGER,
    CU_ADDRESS VARCHAR(255),
    EXP_DATE TIMESTAMP,
    PT_ID INTEGER,
    PD_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE OBJAV_LIST_V_NOMER (
    IS_ID INTEGER)
RETURNS (
    AG_ID INTEGER,
    SD_ID INTEGER,
    OB_ID INTEGER,
    RB_ID INTEGER,
    PD_ID INTEGER,
    OB_STATE INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE OBJAV_LIST_V_NOMER_ALL (
    IS_ID INTEGER)
RETURNS (
    AG_ID INTEGER,
    SD_ID INTEGER,
    OB_ID INTEGER,
    RB_ID INTEGER,
    PD_ID INTEGER,
    OB_STATE INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE OBJAV_NAVCH_COURSE (
    IS_ID INTEGER)
RETURNS (
    AG_ID INTEGER,
    SD_ID INTEGER,
    OB_ID INTEGER,
    GZ_ID INTEGER,
    AG_NAME VARCHAR(128),
    RB_NAME VARCHAR(128),
    CU_INFO VARCHAR(512),
    OB_TEXT VARCHAR(2047))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE OBJAV_PHONES (
    AG_ID INTEGER,
    SD_ID INTEGER)
RETURNS (
    PH_NUMBER CHAR(16))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE OBJAV_SVERSTANA (
    AG_ID INTEGER,
    SD_ID INTEGER,
    OB_ID INTEGER,
    PD_ID INTEGER,
    RB_ID INTEGER,
    DIAGNOZ INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE OBJAV_VERSTKA_DIFFERENCE (
    IS_ID INTEGER)
RETURNS (
    AG_ID INTEGER,
    SD_ID INTEGER,
    OB_ID INTEGER,
    PD_ID INTEGER,
    RB_ID INTEGER,
    DIAGNOZ SMALLINT)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE OBJAV_VERSTKA_SVERSTANO
RETURNS (
    AG_ID INTEGER,
    SD_ID INTEGER,
    OB_ID INTEGER,
    PD_ID INTEGER,
    RB_ID INTEGER,
    SD_ID_COMPOUND VARCHAR(50),
    OB_COMMENT VARCHAR(255),
    FM_ID INTEGER,
    SD_SHOW_CUST_ID SMALLINT,
    CU_ID_COMPOUND VARCHAR(50),
    CU_INFO VARCHAR(512),
    GZ_ID SMALLINT,
    RB_NAME_SHORT VARCHAR(50),
    OBJAV_TEXT VARCHAR(2047),
    OB_ORDER FLOAT,
    OB_IS_OPTIONAL SMALLINT,
    DISTRICT_NAME VARCHAR(100))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE OBJAVLENIE_DELETE (
    OBJAV_ID INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE OBJAVLENIE_DUPLICATE (
    P_DUPLICATE_AG_ID INTEGER,
    P_DUPLICATE_SD_ID INTEGER,
    P_SOURCE_OB_ID INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE OBJAVLENIE_DUPLICATE_ALL (
    P_DUPLICATE_AG_ID INTEGER,
    P_DUPLICATE_SD_ID INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE OBJAVLENIE_GET_DUPL_RUBRIKA (
    P_DST_GZ_ID INTEGER,
    P_SRC_RB_ID INTEGER,
    P_SRC_DOUBLE_RB_ID INTEGER)
RETURNS (
    P_DST_RB_ID INTEGER,
    P_DST_DOUBLE_RB_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE OBJAVLENIE_INSERT (
    PD_ID INTEGER,
    CONTENT_ID INTEGER,
    RB_ID INTEGER,
    FM_ID INTEGER,
    VAC_COUNT SMALLINT,
    DOUBLE_RB_ID INTEGER,
    OBJAV_COMMENT VARCHAR(255),
    OBJAV_HAS_ATTENTION SMALLINT,
    PICTURE_TO_INET SMALLINT,
    DISTRICT_ID INTEGER,
    MDL_TEXT D_MEMO)
RETURNS (
    SAME_CODE INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE OBJAVLENIE_INSERT_INTERNAL (
    PD_ID INTEGER,
    CONTENT_ID INTEGER,
    RB_ID INTEGER,
    FM_ID INTEGER,
    VAC_COUNT SMALLINT,
    DOUBLE_RB_ID INTEGER,
    OBJAV_COMMENT VARCHAR(255),
    OBJAV_HAS_ATTENTION SMALLINT,
    PICTURE_TO_INET SMALLINT,
    DISTRICT_ID INTEGER,
    MDL_TEXT D_MEMO)
RETURNS (
    SAME_CODE INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE OBJAVLENIE_UPDATE (
    OBJAV_ID INTEGER,
    CONTENT_ID INTEGER,
    RB_ID INTEGER,
    FM_ID INTEGER,
    VAC_COUNT INTEGER,
    DOUBLE_RB_ID INTEGER,
    OBJAV_COMMENT VARCHAR(255),
    OBJAV_HAS_ATTENTION SMALLINT,
    PICTURE_TO_INET SMALLINT,
    DISTRICT_ID INTEGER,
    MDL_TEXT D_MEMO)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE ONE_C (
    DATE_FROM TIMESTAMP,
    DATE_TO TIMESTAMP)
RETURNS (
    NUMBER_OF_RECORDS INTEGER,
    OCOUNT INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PAY_FOR_SDELKA (
    AG_ID INTEGER,
    SD_ID INTEGER,
    SUM_PAYED FLOAT,
    ALL_PAYED INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE PAY_SDELKAS (
    FACT_NUM INTEGER,
    PAY_SUM FLOAT)
RETURNS (
    CU_NAME VARCHAR(128))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PODACHA_DUPLICATE (
    P_DUPLICATE_AG_ID INTEGER,
    P_DUPLICATE_SD_ID INTEGER,
    P_SOURCE_PD_ID INTEGER,
    P_DUPLICATE_IS_ID INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE PODACHA_FILL_OBJAVS (
    PD_ID INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE PODACHA_GET_BY_ORDER_NO (
    P_AG_ID INTEGER,
    P_SD_ID INTEGER,
    P_ORDER_NO INTEGER)
RETURNS (
    P_PD_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE PODACHA_INSERT (
    AG_ID INTEGER,
    SD_ID INTEGER,
    GZ_ID INTEGER,
    IS_ID INTEGER,
    PD_FREE_OF_CHARGE INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE PODACHA_IS_CURRENT_AND_EDITABLE (
    PD_ID INTEGER)
RETURNS (
    RESULT INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE REFRESH_OTKAZNIK (
    LAST_ISSUE_PR INTEGER,
    LAST_ISSUE_NS INTEGER,
    LAST_ISSUE_SR INTEGER,
    LAST_ISSUE_RZ INTEGER,
    LAST_ISSUE_RK INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE REFRESH_OTKAZNIK_NEW
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE REP_ASSISTANTS (
    P_DATE_FROM TIMESTAMP,
    P_DATE_TO TIMESTAMP)
RETURNS (
    US_NAME VARCHAR(128),
    SDELKA_COUNT INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE REP_BARTER_ITOG (
    P_GZ_ID INTEGER,
    P_IS_ID INTEGER)
RETURNS (
    AG_ID INTEGER,
    SDELKA_COUNT INTEGER,
    TOTAL_SPACE FLOAT,
    TOTAL_SUM FLOAT)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE REP_CUST_VIP (
    AG_ID_INPUT INTEGER,
    DATE_FROM TIMESTAMP,
    DATE_TO TIMESTAMP)
RETURNS (
    CU_ID INTEGER,
    KA_COUNT INTEGER,
    INET_COUNT INTEGER,
    TOTAL_COUNT INTEGER,
    KA_SUM FLOAT,
    INET_SUM FLOAT,
    TOTAL_SUM FLOAT,
    AG_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE REP_MODULI_BY_DESIGNER (
    P_DATE_FROM TIMESTAMP,
    P_DATE_TO TIMESTAMP)
RETURNS (
    US_ID INTEGER,
    US_NAME VARCHAR(200),
    CONTENT_COUNT INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE REP_PHONES_EXIT_FROM_OTKAZNIK (
    AG_ID_INPUT INTEGER,
    LAST_ISSUE_PR INTEGER,
    LAST_ISSUE_NS INTEGER,
    LAST_ISSUE_SR INTEGER,
    LAST_ISSUE_RZ INTEGER,
    LAST_ISSUE_RK INTEGER)
RETURNS (
    PH_NUMBER VARCHAR(16))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE REP_SDELKA_BY_OFFICE (
    OFFICE_ID INTEGER,
    RQ_ID INTEGER,
    PT_ID INTEGER,
    DATE_FROM TIMESTAMP,
    DATE_TO TIMESTAMP)
RETURNS (
    SD_ID_COMPOUND VARCHAR(200),
    SD_DATE TIMESTAMP,
    SD_FACT_NUM INTEGER,
    AG_NAME VARCHAR(200),
    CU_NAME VARCHAR(200),
    CU_PHONES VARCHAR(200),
    SD_TYPE_DESC VARCHAR(200),
    FM_NAME VARCHAR(200),
    PODACHA_NUMS VARCHAR(200),
    SD_SUM FLOAT,
    US_NAME VARCHAR(200),
    RQ_NAME VARCHAR(32),
    GZ_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE REP_SDELKA_CROSSING_MONTH (
    DATE_FROM TIMESTAMP,
    DATE_TO TIMESTAMP)
RETURNS (
    AG_NAME VARCHAR(128),
    CU_NAME VARCHAR(128),
    CU_OKPO CHAR(10),
    PT_NAME VARCHAR(64),
    SD_FACT_NUM INTEGER,
    SD_FACT_DATE TIMESTAMP,
    GZ_NAME_SHORT VARCHAR(64),
    PODACHA_NUMS_INSIDE VARCHAR(255),
    SD_SUM FLOAT,
    SD_SUM_PAYED FLOAT,
    SD_SUM_PART FLOAT,
    SUM_TOTAL_OUT FLOAT,
    SUM_PART_OUT FLOAT,
    SUM_PAYED_OUT FLOAT)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE REP_SDELKA_CROSSING_MONTH2 (
    DATE_FROM TIMESTAMP,
    DATE_TO TIMESTAMP)
RETURNS (
    AG_NAME VARCHAR(128),
    CU_NAME VARCHAR(128),
    CU_OKPO CHAR(10),
    PT_NAME VARCHAR(64),
    SD_FACT_NUM INTEGER,
    SD_FACT_DATE TIMESTAMP,
    GZ_NAME_SHORT VARCHAR(64),
    PODACHA_NUMS_INSIDE VARCHAR(255),
    SD_SUM FLOAT,
    SD_SUM_PAYED FLOAT,
    SD_SUM_PART FLOAT,
    SUM_TOTAL_OUT FLOAT,
    SUM_PART_OUT FLOAT,
    SUM_PAYED_OUT FLOAT)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE REP_SDELKA_CROSSING_MONTH3 (
    DATE_FROM TIMESTAMP,
    DATE_TO TIMESTAMP)
RETURNS (
    AG_NAME VARCHAR(128),
    CU_NAME VARCHAR(128),
    CU_OKPO CHAR(10),
    PT_NAME VARCHAR(64),
    SD_FACT_NUM INTEGER,
    SD_FACT_DATE TIMESTAMP,
    GZ_NAME_SHORT VARCHAR(64),
    PODACHA_NUMS_INSIDE VARCHAR(255),
    SD_SUM FLOAT,
    SD_SUM_PAYED FLOAT,
    SD_SUM_PART FLOAT,
    SUM_TOTAL_OUT FLOAT,
    SUM_PART_OUT FLOAT,
    SUM_PAYED_OUT FLOAT)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE REPORT_RESUME_WEEK_BY_CLIENT (
    INPUT_US_ID INTEGER,
    DATE_BEGIN TIMESTAMP,
    DATE_END TIMESTAMP)
RETURNS (
    OUT_NAME VARCHAR(128),
    OUT_CUST_NEW INTEGER,
    OUT_CUST_OLD INTEGER,
    OUT_CUST_NEW_SDELKA_COUNT INTEGER,
    OUT_CUST_NEW_SDELKA_SUM FLOAT,
    OUT_CUST_OLD_SDELKA_COUNT INTEGER,
    OUT_CUST_OLD_SDELKA_SUM FLOAT)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE SD_IS_CURRENT_ISSUE (
    AG_ID INTEGER,
    SD_ID INTEGER)
RETURNS (
    RESULT INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE SDELKA_COUNT_DUPLICATE_SUM (
    P_AG_ID INTEGER,
    P_SD_ID INTEGER,
    P_GZ_ID_SOURCE INTEGER,
    P_GZ_ID_DUPLICATE INTEGER)
RETURNS (
    SUM_DUPLICATE FLOAT)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE SDELKA_COUNT_SUMMARY (
    DATE_FROM TIMESTAMP,
    DATE_TO TIMESTAMP,
    US_ID INTEGER,
    REP_MODE INTEGER)
RETURNS (
    AG_ID INTEGER,
    SD_COUNT INTEGER,
    NAL_SUM FLOAT,
    BEZNAL_SUM FLOAT,
    KREDIT_SUM FLOAT,
    KASA_SUM FLOAT,
    BARTER_COUNT INTEGER,
    KA_COUNT INTEGER,
    KA_SUM FLOAT,
    INET_COUNT INTEGER,
    INET_SUM FLOAT,
    OTHER_CITY_COUNT INTEGER,
    OTHER_CITY_SUM FLOAT,
    NEW_CUST_COUNT INTEGER,
    PAYED_BEZNAL FLOAT,
    PAYED_CREDIT FLOAT,
    PAYED_OTHER_CITY_COUNT INTEGER,
    PAYED_OTHER_CITY_SUM FLOAT,
    PAYED_BEZNAL_V_NAL FLOAT,
    PAYED_KASA FLOAT,
    BEZNAL_V_NAL_SUM FLOAT,
    OBJAV_TEXT_COUNT INTEGER,
    OBJAV_MODULE_COUNT INTEGER,
    OBJAV_VIP_COUNT INTEGER,
    AVG_SDELKA_COST FLOAT,
    AVG_PODACHA_COST FLOAT,
    AVG_VAC_COST FLOAT,
    TTL_VAC_COUNT INTEGER,
    TTL_OBJAV_COST FLOAT,
    INET_PAYED_SUM FLOAT,
    REG_COUNT INTEGER,
    REG_SUM FLOAT,
    REG_PAYED_SUM FLOAT)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE SDELKA_DOLJNIKA (
    AG_ID_INPUT INTEGER,
    SD_ID_INPUT INTEGER)
RETURNS (
    AG_ID INTEGER,
    SD_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE SDELKA_DUPLICATE (
    P_AG_ID INTEGER,
    P_SD_ID INTEGER,
    P_DUPLICATE_GZ_ID INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE SDELKA_DUPLICATING_END (
    P_SOURCE_AG_ID INTEGER,
    P_SOURCE_SD_ID INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE SDELKA_DUPLICATING_START (
    P_SOURCE_AG_ID INTEGER,
    P_SOURCE_SD_ID INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE SDELKA_FOR_ZARPLATA (
    AG_ID_INPUT INTEGER,
    DATE_FROM TIMESTAMP,
    DATE_TO TIMESTAMP)
RETURNS (
    AG_ID INTEGER,
    SD_ID INTEGER,
    SDZ_SD_PERCENT_SUM FLOAT,
    SD_PERCENT_SUM_TO_GIVE FLOAT,
    PT_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE SDELKA_IS_DOLJNIKA (
    AG_ID_INPUT INTEGER,
    SD_ID_INPUT INTEGER)
RETURNS (
    RESULT INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE SDELKA_PHONES (
    AG_ID INTEGER,
    SD_ID INTEGER)
RETURNS (
    PH_NUMBER CHAR(16))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE SDELKA_PODACHA_NUMS (
    AG_ID_INPUT INTEGER,
    SD_ID_INPUT INTEGER)
RETURNS (
    SD_ID INTEGER,
    PODACHA_NUMS VARCHAR(128))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE SDELKA_PODACHA_NUMS_DATES (
    AG_ID INTEGER,
    SD_ID INTEGER,
    DATE_FROM TIMESTAMP,
    DATE_TO TIMESTAMP)
RETURNS (
    PODACHA_NUMS VARCHAR(255))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE SDELKA_PODACHA_NUMS_DATES_1C (
    AG_ID INTEGER,
    SD_ID INTEGER,
    DATE_FROM TIMESTAMP,
    DATE_TO TIMESTAMP)
RETURNS (
    PODACHA_NUMS VARCHAR(255))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE SDELKA_WAS_DELETED_LOG (
    P_US_ID INTEGER,
    P_AG_ID INTEGER,
    P_SD_ID INTEGER,
    P_IP CHAR(15))
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE SET_RESET_SUM_AND_PERCENT (
    AG_ID INTEGER,
    SD_ID INTEGER,
    RESET SMALLINT)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE SET_SUM_AND_PERCENT (
    AG_ID INTEGER,
    SD_ID INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE SITE_OBJAV_COPY (
    SITE_OBJAV_ID INTEGER)
RETURNS (
    NEW_SITE_OBJAV_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE TRANSFE_SDELKA (
    DATE_FROM TIMESTAMP,
    DATE_TO TIMESTAMP)
RETURNS (
    SD_FACT_NUM INTEGER,
    SD_FACT_DATE TIMESTAMP,
    SERV_ID SMALLINT,
    PODACHA_NUMS_INSIDE1 VARCHAR(255),
    SD_SUM FLOAT,
    SD_SUM_PAYED FLOAT,
    CU_OKPO CHAR(10),
    CU_NAME VARCHAR(128),
    COMPANY_OKPO VARCHAR(10),
    ISPAID SMALLINT,
    SD_ID INTEGER,
    AG_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE TRANSPORT_DATA_1C (
    DATE_FROM TIMESTAMP,
    DATE_TO TIMESTAMP,
    ONLY_NOT_PAYED INTEGER)
RETURNS (
    FAC_NUM INTEGER,
    FAC_DATE TIMESTAMP,
    SERV_ID INTEGER,
    DESCRIPT VARCHAR(200),
    COST FLOAT,
    PAYED FLOAT,
    CUS_OKPO CHAR(10),
    CUS_NAME CHAR(128),
    PODACHA_NUMS_INSIDE VARCHAR(255))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE UPD_NEW_CUSTS
RETURNS (
    NUM VARCHAR(64))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE USER_LOGGED_IN (
    US_ID INTEGER,
    AG_ID INTEGER,
    HOST VARCHAR(64))
AS
BEGIN
  EXIT;
END^





CREATE PROCEDURE UTIL_FORMAT_DATE (
    DT DATE)
RETURNS (
    RES CHAR(10))
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE WRONG_GAZETA
RETURNS (
    AG_ID INTEGER,
    SD_ID INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE PROCEDURE Z_DELETE_OLD_SDELKA (
    DATE_FROM DATE)
AS
BEGIN
  EXIT;
END^






SET TERM ; ^



/******************************************************************************/
/***                                 Tables                                 ***/
/******************************************************************************/



CREATE TABLE ACCESS_RIGHTS_RULE (
    ARR_WINDOW_NAME         D_TEXT_32 NOT NULL,
    ARR_ORDER               SMALLINT NOT NULL,
    ARR_NAME                D_TEXT_128 NOT NULL,
    ARR_USER_TYPES          D_TEXT_32 NOT NULL,
    ARR_TARGET_OBJECT_NAME  D_TEXT_512 NOT NULL,
    ARR_CHECK_OBJECT_NAME   D_TEXT_64,
    ARR_CHECK_MODE          D_ACCESS_RIGHT_CHECK_MODE,
    ARR_CHECK_OBJECT_VALUE  FLOAT,
    ARR_ACTION              D_ACCESS_RIGHT_ACTION
);

CREATE TABLE ADMIN_LOG (
    US_ID         INTEGER NOT NULL,
    AL_ID         INTEGER NOT NULL,
    AT_ID         INTEGER NOT NULL,
    AL_DATE       TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
    AL_PARAMS     D_TEXT_255 COLLATE PXW_CYRL,
    AL_IP         CHAR(15),
    AL_IS_REMOTE  D_BOOLEAN DEFAULT 0 NOT NULL
);

CREATE TABLE ADMIN_TOOLS (
    AT_ID           INTEGER NOT NULL,
    AT_NAME         D_TEXT_255 NOT NULL COLLATE PXW_CYRL,
    AT_PROC         D_TEXT_64 COLLATE PXW_CYRL,
    AT_PROC_PARAMS  D_TEXT_512,
    AT_RESULT_NAME  D_TEXT_64 COLLATE PXW_CYRL,
    AT_ACTIVE       D_BOOLEAN DEFAULT 1 NOT NULL
);

CREATE TABLE AGENT (
    AG_ID                   INTEGER NOT NULL,
    AG_NAME                 D_NAME NOT NULL,
    AG_IS_REMOTE            D_BOOLEAN,
    AG_MAX_FACT_NUM         INTEGER DEFAULT 0 NOT NULL,
    AG_FACTURA_PHONES       D_TEXT_64 COLLATE PXW_CYRL,
    AG_FACTURA_NAME         D_TEXT_64 COLLATE PXW_CYRL,
    AG_LOCK_RUBRIKAS        D_BOOLEAN NOT NULL,
    CAN_USE_NEW_REQUISITES  D_BOOLEAN DEFAULT 0 NOT NULL,
    AG_IS_ACTIVE            D_BOOLEAN
);

CREATE TABLE AGENT_PERCENT (
    AG_ID      INTEGER NOT NULL,
    IS_ID      INTEGER NOT NULL,
    AP_NAL     D_PERCENT,
    AP_BEZNAL  D_PERCENT
);

CREATE TABLE APPROVING_STATUS (
    AS_ID    D_APPROVING_STATUS NOT NULL,
    AS_NAME  D_TEXT_64 COLLATE PXW_CYRL
);

CREATE TABLE BANK (
    ID_B     INTEGER NOT NULL,
    B_NAME   D_TEXT_128,
    B_MFO    D_TEXT_30,
    B_EDRPO  D_TEXT_30,
    B_SVID   D_TEXT_30,
    B_INN    D_TEXT_30,
    B_ACC    D_TEXT_30
);

CREATE TABLE BLANK_IN_GLOBAL_STACK (
    BI_ID     INTEGER NOT NULL,
    AG_ID     INTEGER NOT NULL,
    SD_ID     INTEGER NOT NULL,
    US_ID     INTEGER NOT NULL,
    BI_ISSUE  INTEGER NOT NULL
);

CREATE TABLE BONUS_TRANSACTIONS (
    AG_ID       INTEGER NOT NULL,
    CU_ID       INTEGER NOT NULL,
    BT_ID       INTEGER NOT NULL,
    BT_DATE     TIMESTAMP NOT NULL,
    BT_SUM      D_MONEY,
    BT_COMMENT  D_TEXT_128 COLLATE PXW_CYRL,
    BT_CHANGE   FLOAT
);

CREATE TABLE BOOL (
    BL_ID    D_BOOLEAN NOT NULL,
    BL_NAME  CHAR(4) NOT NULL
);

CREATE TABLE CHANGE_AGENT_TASK (
    AG_ID_SRC  INTEGER NOT NULL,
    SD_ID_SRC  INTEGER NOT NULL,
    AG_ID_DST  INTEGER NOT NULL
);

CREATE TABLE CITY (
    C_ID     INTEGER NOT NULL,
    C_NAME   D_TEXT_128,
    ORDERBY  INTEGER
);

CREATE TABLE CUST (
    AG_ID             INTEGER NOT NULL,
    CU_ID             INTEGER NOT NULL,
    CU_NAME           D_TEXT_128 COLLATE PXW_CYRL,
    CU_ID_COMPOUND    COMPUTED BY (AG_ID||'-'||CU_ID),
    CU_BONUS_ENABLED  D_BOOLEAN,
    CU_OKPO           CHAR(10),
    CU_INFO           D_TEXT_512 DEFAULT '' NOT NULL COLLATE PXW_CYRL,
    CU_KA_INFO_SHORT  D_TEXT_512,
    CU_KA_INFO_FULL   VARCHAR(1023),
    CUQ_REG_ID        INTEGER,
    EDIT_TIME         TIMESTAMP,
    CU_COMPANY_ID     INTEGER,
    CU_EMAIL          D_TEXT_128,
    CU_PASSWORD       D_TEXT_128
);

CREATE TABLE CUST_FOR_OBJAV_EXPORT (
    AG_ID  INTEGER NOT NULL,
    CU_ID  INTEGER NOT NULL
);

CREATE TABLE CUST_PHONE (
    AG_ID          INTEGER NOT NULL,
    CU_ID          INTEGER NOT NULL,
    CP_NUMBER      D_PHONE NOT NULL,
    CP_ADDDATE     TIMESTAMP NOT NULL,
    CP_IS_DOLJNIK  D_BOOLEAN default 0,
    CP_COMMENT     D_TEXT_128 COLLATE PXW_CYRL
);

CREATE TABLE CUST_PHONE_TMP (
    AG_ID          INTEGER NOT NULL,
    CU_ID          INTEGER NOT NULL,
    CP_NUMBER      D_PHONE NOT NULL,
    CP_ADDDATE     TIMESTAMP NOT NULL,
    CP_IS_DOLJNIK  D_BOOLEAN default 0,
    CP_COMMENT     D_TEXT_128 COLLATE PXW_CYRL
);

CREATE TABLE CUST_UNIQUE (
    CUQ_TYPE          SMALLINT NOT NULL,
    CUQ_FULL_NAME     D_TEXT_512,
    CUQ_ADDRESS       D_TEXT_512,
    CUQ_ADDRESS_REAL  D_TEXT_512,
    CUQ_NAME          D_TEXT_512,
    CUQ_PHONES        D_TEXT_30 COLLATE PXW_CYRL,
    CUQ_BOSS          D_TEXT_40 COLLATE PXW_CYRL,
    CUQ_BUHGALTER     D_TEXT_40 COLLATE PXW_CYRL,
    CUQ_OKPO          CHAR(10) NOT NULL,
    CUQ_INN           D_INN NOT NULL,
    CUQ_NDS_NUM       D_NDSNUM,
    CUQ_CONTACT       D_TEXT_50 COLLATE PXW_CYRL,
    CUQ_DOC_SER       VARCHAR(10) COLLATE PXW_CYRL,
    CUQ_DOC_NUM       VARCHAR(10) COLLATE PXW_CYRL,
    CUQ_DOC_AUTHOR    VARCHAR(60) COLLATE PXW_CYRL,
    CUQ_DOC_DATE      CHAR(10),
    CUQ_1C_ID         INTEGER NOT NULL,
    CUQ_REG_ID        INTEGER NOT NULL,
    CUQ_CHANGED       D_BOOLEAN NOT NULL,
    EDIT_TIME         TIMESTAMP DEFAULT current_timestamp
);

CREATE TABLE CUST_UNIQUE_TYPE (
    CUQT_ID    SMALLINT NOT NULL,
    CUQT_NAME  D_TEXT_32 COLLATE PXW_CYRL
);

CREATE TABLE DISTRICT (
    DT_ID         INTEGER NOT NULL,
    DT_NAME       VARCHAR(100) NOT NULL,
    DT_IS_ACTIVE  D_BOOLEAN DEFAULT 1 NOT NULL
);

CREATE TABLE EDUCATION (
    ED_ID    INTEGER NOT NULL,
    ED_NAME  D_TEXT_32
);

CREATE TABLE EXPERIENCE (
    EX_ID    INTEGER NOT NULL,
    EX_NAME  D_TEXT_32
);

CREATE TABLE FORMAT (
    FM_ID              INTEGER NOT NULL,
    FM_NAME            D_NAME NOT NULL,
    FM_SPACE           FLOAT,
    FM_ALWAYS_ADD_SUM  D_BOOLEAN DEFAULT 0,
    FM_HAS_PICTURE     D_BOOLEAN NOT NULL,
    FM_PICTURE_SIZES   D_TEXT_128,
    ORDERBY            INTEGER DEFAULT 1000
);

CREATE TABLE FORMAT_COST (
    GZ_ID      INTEGER NOT NULL,
    FM_ID      INTEGER NOT NULL,
    FM_COST    FLOAT DEFAULT 0,
    FM_COST_4  D_MONEY DEFAULT 0
);

CREATE TABLE GAZETA (
    GZ_ID          SMALLINT NOT NULL,
    GZ_NAME        D_TEXT_64 COLLATE PXW_CYRL,
    GZ_NAME_SHORT  D_TEXT_64 COLLATE PXW_CYRL,
    GZ_LOGO        BLOB SUB_TYPE 0 SEGMENT SIZE 2000
);

CREATE TABLE INET_OB_TYPE (
    OB_TYPE     D_SIGN,
    TYPE_NAME   D_TEXT_255,
    SHORT_NAME  D_TEXT_32
);

CREATE GLOBAL TEMPORARY TABLE INTERNET (
    OBJAV_ID    INTEGER,
    RS_ID       INTEGER,
    CONTENT_ID  INTEGER,
    TXT         D_MEMO
) ON COMMIT DELETE ROWS;

CREATE TABLE ISSUE (
    IS_ID             INTEGER NOT NULL,
    GZ_ID             SMALLINT NOT NULL,
    IS_NAME           VARCHAR(10) NOT NULL COLLATE PXW_CYRL,
    IS_DATE           TIMESTAMP NOT NULL,
    IS_NAME_COMPOSED  VARCHAR(30)
);

CREATE TABLE "LOG" (
    LG_DATE       TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
    LG_COMMENT    D_TEXT_128 COLLATE PXW_CYRL,
    LG_IS_REMOTE  D_BOOLEAN DEFAULT 0 NOT NULL
);

CREATE TABLE MONEY_TRANSACTIONS (
    MT_ID       INTEGER NOT NULL,
    MT_DATE     TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
    MT_SUM      FLOAT NOT NULL,
    MT_COMMENT  D_TEXT_128 COLLATE PXW_CYRL,
    MT_CHANGE   FLOAT NOT NULL,
    TT_ID       INTEGER NOT NULL,
    US_ID       INTEGER NOT NULL
);

CREATE TABLE NEW_CUST_LOG (
    AG_ID           INTEGER,
    SD_ID           INTEGER,
    NEW_CUST_VALUE  INTEGER,
    EDIT_TIME       TIMESTAMP
);

CREATE TABLE NOT_PAYED_SDELKA (
    AG_ID  INTEGER NOT NULL,
    SD_ID  INTEGER NOT NULL,
    CU_ID  INTEGER
);

CREATE TABLE OBJAV (
    AG_ID             INTEGER NOT NULL,
    SD_ID             INTEGER NOT NULL,
    OB_ID             INTEGER NOT NULL,
    OB_STATE          SMALLINT DEFAULT 0 NOT NULL,
    OB_IS_ACTIVE      D_BOOLEAN DEFAULT 1 NOT NULL,
    OB_PARENT         INTEGER,
    FM_ID             SMALLINT NOT NULL,
    RB_ID             INTEGER NOT NULL,
    OB_ORDER          FLOAT,
    OB_COMMENT        VARCHAR(127) COLLATE PXW_CYRL,
    OB_TEXT           D_MEMO COLLATE PXW_CYRL,
    OB_FOR_INTERNET   D_BOOLEAN DEFAULT 1 NOT NULL,
    OB_CHANGED        TIMESTAMP NOT NULL,
    RS_ID             INTEGER,
    OB_VAC_COUNT      SMALLINT DEFAULT 1 NOT NULL,
    OB_HAS_ATTENTION  D_BOOLEAN DEFAULT 0,
    OB_IS_OPTIONAL    D_BOOLEAN DEFAULT 0 NOT NULL,
    DISTRICT_ID       INTEGER,
    SITE_OBJAV_ADDED  D_SIGN,
    SITE_EMAIL        D_TEXT_128,
    SITE_EMPLOYER     D_TEXT_255
);

CREATE TABLE OBJAV_CHANGE_LOG (
    OL_ID          INTEGER NOT NULL,
    AG_ID          INTEGER NOT NULL,
    SD_ID          INTEGER NOT NULL,
    OB_ID          INTEGER NOT NULL,
    US_ID          INTEGER NOT NULL,
    NEW_STATE_ID   INTEGER NOT NULL,
    NEW_RB_ID      INTEGER NOT NULL,
    CHANGE_DATE    TIMESTAMP NOT NULL,
    NEW_TEXT       D_MEMO COLLATE PXW_CYRL,
    SD_IS_COPY_OF  INTEGER
);

CREATE TABLE OBJAV_CONTENT (
    CONTENT_ID                INTEGER NOT NULL,
    FM_ID                     INTEGER NOT NULL,
    RB_ID                     INTEGER,
    CONTENT_PICTURE           BLOB SUB_TYPE 0 SEGMENT SIZE 1000,
    CONTENT_COREL_PAGE        D_TEXT_32,
    CONTENT_SITE_OBJAV_ADDED  D_BOOLEAN DEFAULT 0,
    VAC_COUNT                 SMALLINT DEFAULT 1 NOT NULL,
    MODIFY_DATE               TIMESTAMP,
    CREATE_DATE               TIMESTAMP,
    CH_PICTURE                BLOB SUB_TYPE 0 SEGMENT SIZE 1000,
    CH_TEXT                   D_MEMO,
    OLD_CONTENT_ID_LINK       INTEGER,
    EXTENSION                 VARCHAR(5) COLLATE PXW_CYRL,
    SMALL_PICTURE             BLOB SUB_TYPE 0 SEGMENT SIZE 1000
);

CREATE TABLE OBJAV_CONTENT_LOAD_LOG (
    ID          INTEGER NOT NULL,
    LL_DATE     TIMESTAMP NOT NULL,
    US_ID       INTEGER NOT NULL,
    OBJAV_ID    INTEGER NOT NULL,
    CONTENT_ID  INTEGER NOT NULL,
    LOG_TYPE    SMALLINT
);

CREATE TABLE OBJAV_CONTENT_SITE_OBJAV (
    CONTENT_ID     INTEGER NOT NULL,
    SITE_OBJAV_ID  INTEGER NOT NULL
);

CREATE TABLE OBJAV_DUPL (
    AG_ID          INTEGER NOT NULL,
    SD_ID          INTEGER NOT NULL,
    OB_ID          INTEGER NOT NULL,
    DUPL_OF_AG_ID  INTEGER NOT NULL,
    DUPL_OF_SD_ID  INTEGER NOT NULL,
    DUPL_OF_OB_ID  INTEGER NOT NULL
);

CREATE TABLE OBJAV_INET_IMPORT (
    RB_ID    INTEGER NOT NULL,
    OB_TEXT  D_MEMO COLLATE PXW_CYRL,
    OI_ID    INTEGER
);

CREATE TABLE OBJAV_LIST_V_NOMER_TEMP (
    AG_ID     INTEGER NOT NULL,
    SD_ID     INTEGER NOT NULL,
    OB_ID     INTEGER NOT NULL,
    PD_ID     INTEGER NOT NULL,
    RB_ID     INTEGER NOT NULL,
    OB_STATE  INTEGER NOT NULL
);

CREATE TABLE OBJAV_PHONES_REG_TEMP (
    AG_ID           INTEGER NOT NULL,
    SD_ID           INTEGER NOT NULL,
    OB_ID           INTEGER NOT NULL,
    OB_PHONE        D_PHONE NOT NULL COLLATE PXW_CYRL,
    AG_ID_OTKAZNIK  INTEGER
);

CREATE TABLE OBJAV_PHONES_TEMP (
    AG_ID           INTEGER NOT NULL,
    SD_ID           INTEGER NOT NULL,
    OB_ID           INTEGER NOT NULL,
    OB_PHONE        D_PHONE NOT NULL COLLATE PXW_CYRL,
    AG_ID_OTKAZNIK  INTEGER
);

CREATE TABLE OBJAV_STATE (
    OS_ID    INTEGER NOT NULL,
    OS_NAME  D_TEXT_64
);

CREATE TABLE OBJAV_STATE_LOG (
    OSL_IS_REMOTE  D_BOOLEAN NOT NULL,
    OSL_TIMESTAMP  TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
    OSL_DAYOFWEEK  SMALLINT NOT NULL,
    OSL_OLDSTATE   SMALLINT NOT NULL,
    OSL_NEWSTATE   SMALLINT NOT NULL,
    OSL_POVTOR     D_BOOLEAN NOT NULL,
    OSL_FORMAT     SMALLINT NOT NULL,
    OSL_ID         INTEGER NOT NULL
);

CREATE TABLE OBJAV_SVERSTANO (
    AG_ID  INTEGER NOT NULL,
    SD_ID  INTEGER NOT NULL,
    OB_ID  INTEGER NOT NULL,
    RB_ID  INTEGER NOT NULL,
    PD_ID  INTEGER NOT NULL
);

CREATE TABLE OBJAV_TEXT_SITE_OBJAV (
    OB_ID          INTEGER NOT NULL,
    SITE_OBJAV_ID  INTEGER NOT NULL,
    EDIT_TIME      TIMESTAMP DEFAULT current_timestamp
);

CREATE TABLE OBJAV_WORKING_LIST (
    AG_ID     INTEGER NOT NULL,
    SD_ID     INTEGER NOT NULL,
    OB_ID     INTEGER NOT NULL,
    OB_STATE  SMALLINT NOT NULL,
    FM_ID     INTEGER NOT NULL
);

CREATE TABLE OBJAV_WORKING_TEMP (
    AG_ID  INTEGER NOT NULL,
    SD_ID  INTEGER NOT NULL,
    OB_ID  INTEGER NOT NULL,
    FM_ID  INTEGER NOT NULL
);

CREATE TABLE OBJAVLENIE (
    OBJAV_ID             INTEGER NOT NULL,
    PD_ID                INTEGER NOT NULL,
    CONTENT_ID           INTEGER,
    RB_ID                INTEGER NOT NULL,
    FM_ID                INTEGER NOT NULL,
    DOUBLE_RB_ID         INTEGER,
    SAME_CODE            INTEGER NOT NULL,
    OBJAV_COMMENT        D_TEXT_255 COLLATE PXW_CYRL,
    OBJAV_HAS_ATTENTION  D_BOOLEAN DEFAULT 0,
    PICTURE_TO_INET      D_BOOLEAN DEFAULT 0,
    VAC_COUNT            SMALLINT DEFAULT 1 NOT NULL,
    DISTRICT_ID          INTEGER,
    SITE_EMAIL           D_TEXT_128,
    SITE_EMPLOYER        D_TEXT_255,
    OB_STATE             INTEGER,
    MDL_TEXT             D_MEMO,
    OB_STATE_TXT         INTEGER
);

CREATE TABLE OBJAVLENIE_DUPL (
    OBJAV_ID          INTEGER NOT NULL,
    DUPL_OF_OBJAV_ID  INTEGER
);

CREATE TABLE OBJAVLENIE_ERROR (
    OBJAV_ID             INTEGER NOT NULL,
    PD_ID                INTEGER NOT NULL,
    CONTENT_ID           INTEGER,
    RB_ID                INTEGER NOT NULL,
    FM_ID                INTEGER NOT NULL,
    DOUBLE_RB_ID         INTEGER,
    SAME_CODE            INTEGER NOT NULL,
    OBJAV_COMMENT        D_TEXT_255 COLLATE PXW_CYRL,
    OBJAV_HAS_ATTENTION  D_BOOLEAN DEFAULT 0,
    PICTURE_TO_INET      D_BOOLEAN DEFAULT 0,
    VAC_COUNT            SMALLINT DEFAULT 1 NOT NULL,
    DISTRICT_ID          INTEGER
);

CREATE TABLE OBJAVLENIE_LOG (
    OL_ID      INTEGER NOT NULL,
    OB_ID      INTEGER,
    US_ID      INTEGER,
    NEW_STATE  INTEGER,
    EDIT_TIME  TIMESTAMP
);

CREATE TABLE OBJAVS_TEMP (
    AG_ID    INTEGER NOT NULL,
    SD_ID    INTEGER NOT NULL,
    OB_ID    INTEGER NOT NULL,
    OB_TEXT  D_MEMO
);

CREATE TABLE OFFICE (
    OF_ID         INTEGER NOT NULL,
    OF_NAME       VARCHAR(50) NOT NULL,
    OF_IS_REMOTE  D_BOOLEAN NOT NULL
);

CREATE TABLE ONE_ROW_TABLE (
    ORT_ID  SMALLINT DEFAULT 0 NOT NULL
);

CREATE TABLE OTKAZNIK (
    OT_NUMBER     D_PHONE NOT NULL,
    AG_ID         INTEGER,
    OT_IS_STATIC  D_BOOLEAN DEFAULT 0 NOT NULL,
    OT_COMMENT    D_TEXT_128 COLLATE PXW_CYRL,
    EDIT_TIME     TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE PAID_SERVICES (
    FACT_NUM      INTEGER,
    FACT_DATE     TIMESTAMP,
    SERV_ID       SMALLINT,
    DESCRIPT      VARCHAR(255),
    COST          D_MONEY,
    PAID          D_MONEY,
    CUST_OKPO     CHAR(10),
    CUST_NAME     D_TEXT_128,
    COMPANY_OKPO  VARCHAR(10),
    IS_PAID       SMALLINT,
    LOADED        D_BOOLEAN,
    EDIT_TIME     TIMESTAMP,
    ID            D_FACT_NUM,
    AG_ID         INTEGER,
    SD_ID         INTEGER,
    CREATE_DATE   TIMESTAMP
);

CREATE TABLE PARAMS (
    PM_FIRST_OTKAZNIK_ISSUE_PR  INTEGER NOT NULL,
    PM_FIRST_OTKAZNIK_ISSUE_NS  INTEGER NOT NULL,
    PM_FIRST_OTKAZNIK_ISSUE_SR  INTEGER,
    PM_MIN_BONUS_SUM            D_MONEY,
    PM_BONUS_PERCENT            D_PERCENT,
    PM_CURRENT_ISSUE_PR         INTEGER NOT NULL,
    PM_CURRENT_ISSUE_NS         INTEGER NOT NULL,
    PM_CURRENT_ISSUE_SR         INTEGER,
    PM_ROOT_DISK_ID             VARCHAR(100),
    PM_DO_CHECK_DISK            D_BOOLEAN,
    PM_SYNC_STATE               SMALLINT NOT NULL,
    PM_GAZETA_OUTPUT_PATH       D_TEXT_128 NOT NULL COLLATE PXW_CYRL,
    PM_CLOSEDATE_PR_OLD         TIMESTAMP,
    PM_CLOSEDATE_PR_NEW         TIMESTAMP,
    PM_CLOSEDATE_NS_OLD         TIMESTAMP,
    PM_CLOSEDATE_NS_NEW         TIMESTAMP,
    PM_CLOSEDATE_SR_OLD         TIMESTAMP,
    PM_CLOSEDATE_SR_NEW         TIMESTAMP,
    PM_DEFAULT_FACTURA_PHONES   D_TEXT_64 COLLATE PXW_CYRL,
    PM_LOCK_RUBRIKAS_VYPUSK     D_BOOLEAN NOT NULL,
    PM_PROXY_SERVER             D_TEXT_64 COLLATE PXW_CYRL,
    PM_PROXY_PORT               INTEGER,
    PM_PROXY_USERNAME           D_TEXT_50,
    PM_PROXY_PASSWORD           D_TEXT_50,
    PM_VACANCY_IMPORT_URL       D_TEXT_128 COLLATE PXW_CYRL,
    PM_FIRST_OTKAZNIK_ISSUE_RZ  INTEGER DEFAULT 0 NOT NULL,
    PM_CURRENT_ISSUE_RZ         INTEGER DEFAULT 0 NOT NULL,
    PM_CLOSEDATE_RZ_NEW         TIMESTAMP,
    PM_CLOSEDATE_RZ_OLD         TIMESTAMP,
    PM_REPORT_TEMPLATE          BLOB SUB_TYPE 0 SEGMENT SIZE 8192,
    PM_REPORT_TEMPLATE_DATE     TIMESTAMP NOT NULL,
    PM_FIRST_OTKAZNIK_ISSUE_RK  INTEGER,
    PM_CURRENT_ISSUE_RK         INTEGER,
    PM_CLOSEDATE_RK_OLD         TIMESTAMP,
    PM_CLOSEDATE_RK_NEW         TIMESTAMP,
    PM_APP_INSTANCE_NO          INTEGER DEFAULT 1 NOT NULL,
    PM_REPORT_PATH              D_TEXT_255,
    PM_UPDATE_REP               SMALLINT,
    PM_PRINFO                   D_SIGN,
    PM_PR_CNT                   INTEGER,
    PM_ST_CNT                   INTEGER,
    PM_INTERNET_CNT             INTEGER
);

CREATE TABLE PAY_TYPE (
    PT_ID           INTEGER NOT NULL,
    PT_NAME         D_TEXT_64 COLLATE PXW_CYRL,
    PT_SPACE_COEFF  FLOAT NOT NULL
);

CREATE TABLE PHONE (
    AG_ID      INTEGER NOT NULL,
    SD_ID      INTEGER NOT NULL,
    PH_NUMBER  D_PHONE NOT NULL
);

CREATE TABLE PK_ERROR_LOG (
    US_ID     INTEGER NOT NULL,
    ERR_TEXT  D_TEXT_1024,
    SD_ID     INTEGER,
    AG_ID     INTEGER,
    ERR_CTX   D_TEXT_64,
    ERR_DATE  TIMESTAMP
);

CREATE TABLE PODACHA (
    GZ_ID              SMALLINT NOT NULL,
    IS_ID              INTEGER NOT NULL,
    AG_ID              INTEGER NOT NULL,
    SD_ID              INTEGER NOT NULL,
    PD_FREE_OF_CHARGE  D_BOOLEAN NOT NULL,
    PD_ID              INTEGER NOT NULL,
    PD_ADDDATE         TIMESTAMP DEFAULT CURRENT_TIME NOT NULL,
    PD_IS_DONE         D_BOOLEAN DEFAULT 0 NOT NULL
);

CREATE TABLE PREDMET_RAHUNKU (
    PR_ID    INTEGER NOT NULL,
    PR_TEXT  D_TEXT_255
);

CREATE TABLE REQUISITE (
    RQ_ID         INTEGER NOT NULL,
    RQ_NAME       VARCHAR(32),
    RQ_FULL_NAME  VARCHAR(128),
    RQ_ACCOUNT    VARCHAR(128),
    RQ_ADDRESS    VARCHAR(128),
    RQ_PHONES     VARCHAR(64),
    RQ_ACTIVE     D_BOOLEAN DEFAULT 1 NOT NULL,
    RQ_STAMP      BLOB SUB_TYPE 0 SEGMENT SIZE 1000,
    RQ_OKPO       VARCHAR(24),
    RQ_COMP_ADDR  D_TEXT_255,
    RQ_SVID       D_TEXT_128,
    RQ_INN        D_TEXT_128
);

CREATE TABLE RESERVE_MAP (
    RM_ID     INTEGER NOT NULL,
    GZ_ID     INTEGER,
    IS_ID     INTEGER,
    RB_ID     INTEGER,
    LOCK_USR  INTEGER,
    PAGE_MAP  D_TEXT_1024
);

CREATE TABLE RESERVE_RECORD (
    RR_ID    INTEGER NOT NULL,
    US_ID    INTEGER,
    AG_ID    INTEGER,
    RM_ID    INTEGER,
    COMMENT  D_TEXT_128,
    SD_ID    INTEGER
);

CREATE TABLE RUBRIKA (
    RB_ID           INTEGER NOT NULL,
    RB_NAME         D_NAME NOT NULL,
    RB_NAME_SHORT   D_TEXT_64 NOT NULL COLLATE PXW_CYRL,
    RB_COST_COEFF   FLOAT DEFAULT 1 NOT NULL,
    RB_IS_OBLOGKA   D_BOOLEAN DEFAULT 0 NOT NULL,
    GZ_ID           INTEGER NOT NULL,
    RB_IS_HOT       D_BOOLEAN,
    RB_IS_LOCKABLE  D_BOOLEAN DEFAULT 0 NOT NULL,
    DELETED         D_SIGN,
    DEFAULT_MAP     D_TEXT_255,
    ORDERBY         INTEGER,
    RB_NAME_ENG     D_TEXT_128
);

CREATE TABLE RUBRIKA_HOT (
    RB_ID  INTEGER NOT NULL
);

CREATE TABLE RUBRIKA_NOT_VACS (
    RB_ID  INTEGER NOT NULL
);

CREATE TABLE RUBRIKA_POHOZHA (
    RS_ID  INTEGER NOT NULL,
    RB_ID  INTEGER NOT NULL,
    GZ_ID  INTEGER
);

CREATE TABLE RUBRIKA_SITE (
    RS_ID    INTEGER NOT NULL,
    RS_NAME  D_TEXT_128 NOT NULL COLLATE PXW_CYRL,
    DELETED  D_SIGN
);

CREATE TABLE SD_INET_OB (
    AG_ID    INTEGER,
    SD_ID    INTEGER,
    OB_LINK  D_TEXT_1024,
    OB_TYPE  D_SIGN
);

CREATE TABLE SDELKA (
    AG_ID                        INTEGER NOT NULL,
    SD_ID                        INTEGER NOT NULL,
    SD_TYPE                      D_SDELKA_TYPE NOT NULL,
    SD_STATE                     D_SDELKA_STATE NOT NULL,
    RQ_ID                        INTEGER DEFAULT 0 NOT NULL,
    CU_ID                        INTEGER,
    AS_ID                        D_APPROVING_STATUS NOT NULL,
    SD_COMMENT                   D_TEXT_1024 COLLATE PXW_CYRL,
    SD_SUM                       D_MONEY NOT NULL,
    SD_PERCENT                   D_PERCENT,
    SD_SUM_DEFAULT               D_MONEY,
    SD_PERCENT_DEFAULT           D_PERCENT,
    SD_SKIDKA                    FLOAT DEFAULT 0,
    PT_ID                        SMALLINT NOT NULL,
    SD_SETTING_SUM_AND_PERCENT   D_BOOLEAN DEFAULT 0 NOT NULL,
    GZ_ID                        SMALLINT,
    SD_SUM_PAYED                 D_MONEY,
    SD_ALL_PAYED                 D_BOOLEAN,
    SD_COMMENT_SHORT             D_TEXT_128 COLLATE PXW_CYRL,
    SD_IS_CHANGED_COPY_OF_SD_ID  INTEGER,
    SD_ID_COMPOUND               COMPUTED BY (AG_ID||'-'||SD_ID),
    SD_PAY_NOW                   D_BOOLEAN DEFAULT 0 NOT NULL,
    SD_FACT_NUM                  D_FACT_NUM,
    SD_KA_START_DATE             TIMESTAMP,
    SD_KA_END_DATE               TIMESTAMP,
    SD_FACT_DATE                 TIMESTAMP,
    SD_DATE                      TIMESTAMP,
    SD_PERCENT_SUM               COMPUTED BY (SD_SUM*SD_PERCENT/100),
    SD_PERCENT_GIVEN             D_BOOLEAN,
    SD_TO_GIVE_PERCENT           D_BOOLEAN,
    SD_APPROVED_DATE             TIMESTAMP,
    SD_IS_BEZNAL_V_NAL           D_BOOLEAN NOT NULL,
    SD_PAY_DATE                  TIMESTAMP,
    SD_NEW_CUST                  D_BOOLEAN,
    SD_PERCENT_SUM_TO_GIVE       COMPUTED BY (SD_SUM_PAYED*SD_PERCENT/100),
    SD_SHOW_CUST_ID              D_BOOLEAN,
    SD_IS_IMPORTANT_FOR_SITE     D_BOOLEAN DEFAULT 0 NOT NULL,
    REGISTERED_BY_ID             INTEGER,
    SD_PAY_VER                   D_SIGN,
    SD_NUM                       D_TEXT_64
);

CREATE TABLE SDELKA_CHANGE_LOG (
    SL_ID        INTEGER NOT NULL,
    AG_ID        INTEGER NOT NULL,
    SD_ID        INTEGER NOT NULL,
    SD_STATE     INTEGER NOT NULL,
    AS_ID        INTEGER,
    US_ID        INTEGER,
    CHANGE_DATE  TIMESTAMP NOT NULL,
    PT_ID        SMALLINT
);

CREATE TABLE SDELKA_DELETED (
    AG_ID                        INTEGER NOT NULL,
    SD_ID                        INTEGER NOT NULL,
    SD_TYPE                      D_SDELKA_TYPE NOT NULL,
    SD_STATE                     D_SDELKA_STATE NOT NULL,
    RQ_ID                        INTEGER,
    CU_ID                        INTEGER,
    AS_ID                        D_APPROVING_STATUS NOT NULL,
    SD_COMMENT                   D_TEXT_1024 COLLATE PXW_CYRL,
    SD_SUM                       D_MONEY,
    SD_PERCENT                   D_PERCENT,
    SD_SUM_DEFAULT               D_MONEY,
    SD_PERCENT_DEFAULT           D_PERCENT,
    SD_SKIDKA                    FLOAT DEFAULT 0,
    PT_ID                        SMALLINT NOT NULL,
    SD_SETTING_SUM_AND_PERCENT   D_BOOLEAN DEFAULT 0 NOT NULL,
    GZ_ID                        SMALLINT,
    SD_SUM_PAYED                 D_MONEY,
    SD_ALL_PAYED                 D_BOOLEAN,
    SD_COMMENT_SHORT             D_TEXT_128 COLLATE PXW_CYRL,
    SD_IS_CHANGED_COPY_OF_SD_ID  INTEGER,
    SD_ID_COMPOUND               VARCHAR(16),
    SD_PAY_NOW                   D_BOOLEAN DEFAULT 0 NOT NULL,
    SD_FACT_NUM                  D_FACT_NUM,
    SD_KA_START_DATE             TIMESTAMP,
    SD_KA_END_DATE               TIMESTAMP,
    SD_FACT_DATE                 TIMESTAMP,
    SD_DATE                      TIMESTAMP,
    SD_PERCENT_SUM               FLOAT,
    SD_PERCENT_GIVEN             D_BOOLEAN,
    SD_TO_GIVE_PERCENT           D_BOOLEAN,
    SD_APPROVED_DATE             TIMESTAMP,
    SD_IS_BEZNAL_V_NAL           D_BOOLEAN NOT NULL,
    SD_PAY_DATE                  TIMESTAMP,
    SD_NEW_CUST                  D_BOOLEAN,
    SD_PERCENT_SUM_TO_GIVE       FLOAT,
    SD_SHOW_CUST_ID              D_BOOLEAN,
    SD_IS_IMPORTANT_FOR_SITE     D_BOOLEAN DEFAULT 0 NOT NULL,
    SD_REGISTERED_BY_ID          INTEGER,
    SD_DELETED_DATE              TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL,
    SD_NUM                       D_TEXT_64,
    SD_PAY_VER                   D_SIGN
);

CREATE TABLE SDELKA_DUPL (
    AG_ID          INTEGER NOT NULL,
    SD_ID          INTEGER NOT NULL,
    DUPL_OF_AG_ID  INTEGER NOT NULL,
    DUPL_OF_SD_ID  INTEGER NOT NULL
);

CREATE TABLE SDELKA_DUPLICATE_SUM (
    GZ_ID_SOURCE     INTEGER NOT NULL,
    GZ_ID_DUPLICATE  INTEGER NOT NULL,
    SUM_SOURCE       FLOAT NOT NULL,
    SUM_DUPLICATE    FLOAT
);

CREATE TABLE SDELKA_DUPLICATING (
    AG_ID       INTEGER NOT NULL,
    SD_ID       INTEGER NOT NULL,
    CALL_COUNT  INTEGER DEFAULT 0 NOT NULL
);

CREATE TABLE SDELKA_PAY_HISTORY (
    AG_ID     INTEGER,
    SD_ID     INTEGER,
    PAY_SUM   DOUBLE PRECISION,
    PAY_DATE  TIMESTAMP,
    US_ID     INTEGER
);

CREATE TABLE SDELKA_STATE (
    SDS_ID    SMALLINT NOT NULL,
    SDS_NAME  D_TEXT_64 COLLATE PXW_CYRL
);

CREATE TABLE SDELKA_TYPE (
    SDT_ID    SMALLINT NOT NULL,
    SDT_NAME  D_TEXT_64 COLLATE PXW_CYRL
);

CREATE TABLE SDELKA_TYPE_DESC (
    SD_TYPE       INTEGER NOT NULL,
    GZ_ID         INTEGER NOT NULL,
    SD_TYPE_DESC  VARCHAR(10) NOT NULL COLLATE PXW_CYRL
);

CREATE TABLE SDELKA_WAS_DELETED (
    AG_ID                        INTEGER NOT NULL,
    SD_ID                        INTEGER NOT NULL,
    SD_TYPE                      D_SDELKA_TYPE NOT NULL,
    SD_STATE                     D_SDELKA_STATE NOT NULL,
    RQ_ID                        INTEGER DEFAULT 0 NOT NULL,
    CU_ID                        INTEGER,
    AS_ID                        D_APPROVING_STATUS NOT NULL,
    SD_COMMENT                   D_TEXT_1024 COLLATE PXW_CYRL,
    SD_SUM                       D_MONEY NOT NULL,
    SD_PERCENT                   D_PERCENT,
    SD_SUM_DEFAULT               D_MONEY,
    SD_PERCENT_DEFAULT           D_PERCENT,
    SD_SKIDKA                    FLOAT DEFAULT 0,
    PT_ID                        SMALLINT NOT NULL,
    SD_SETTING_SUM_AND_PERCENT   D_BOOLEAN DEFAULT 0 NOT NULL,
    GZ_ID                        SMALLINT,
    SD_SUM_PAYED                 D_MONEY,
    SD_ALL_PAYED                 D_BOOLEAN,
    SD_COMMENT_SHORT             D_TEXT_128 COLLATE PXW_CYRL,
    SD_IS_CHANGED_COPY_OF_SD_ID  INTEGER,
    SD_ID_COMPOUND               VARCHAR(23),
    SD_PAY_NOW                   D_BOOLEAN DEFAULT 0 NOT NULL,
    SD_FACT_NUM                  D_FACT_NUM,
    SD_KA_START_DATE             TIMESTAMP,
    SD_KA_END_DATE               TIMESTAMP,
    SD_FACT_DATE                 TIMESTAMP,
    SD_DATE                      TIMESTAMP,
    SD_PERCENT_SUM               DOUBLE PRECISION,
    SD_PERCENT_GIVEN             D_BOOLEAN,
    SD_TO_GIVE_PERCENT           D_BOOLEAN,
    SD_APPROVED_DATE             TIMESTAMP,
    SD_IS_BEZNAL_V_NAL           D_BOOLEAN NOT NULL,
    SD_PAY_DATE                  TIMESTAMP,
    SD_NEW_CUST                  D_BOOLEAN,
    SD_PERCENT_SUM_TO_GIVE       DOUBLE PRECISION,
    SD_SHOW_CUST_ID              D_BOOLEAN,
    SD_IS_IMPORTANT_FOR_SITE     D_BOOLEAN DEFAULT 0 NOT NULL,
    REGISTERED_BY_ID             INTEGER,
    SD_DELETED_DATE              TIMESTAMP NOT NULL,
    US_ID                        INTEGER,
    AG_ID_DEL                    INTEGER,
    SD_ID_DEL                    INTEGER,
    ULL_HOST                     D_HOST_15 COLLATE PXW_CYRL
);

CREATE TABLE SDELKA_WORKING_LIST (
    AG_ID     INTEGER NOT NULL,
    SD_ID     INTEGER NOT NULL,
    SD_STATE  SMALLINT NOT NULL,
    AS_ID     SMALLINT
);

CREATE TABLE SERVICE (
    SR_ID           INTEGER NOT NULL,
    SR_AMOUNT       FLOAT,
    SR_SUM          D_MONEY NOT NULL,
    SR_TYPE         INTEGER NOT NULL,
    SR_DESCRIPTION  D_TEXT_1024,
    AG_ID           INTEGER NOT NULL,
    SD_ID           INTEGER NOT NULL
);

CREATE TABLE SERVICE_TYPE (
    SE_ID           INTEGER NOT NULL,
    SE_NAME         D_TEXT_128 NOT NULL,
    SE_IS_ACTIVE    D_BOOLEAN DEFAULT 1 NOT NULL,
    SE_DESCRIPTION  D_TEXT_1024
);

CREATE TABLE SITE_OBJAV (
    SITE_OBJAV_ID      INTEGER NOT NULL,
    RS_ID              INTEGER NOT NULL,
    SITE_OBJAV_TEXT    D_MEMO COLLATE PXW_CYRL,
    SITE_VACANCY_NAME  D_TEXT_128,
    SITE_EMAIL         D_TEXT_128,
    SITE_TEL           D_TEXT_128,
    SITE_CONTACT       D_TEXT_255,
    SITE_DONT_UPLOAD   SMALLINT,
    SITE_ZP            INTEGER,
    SITE_EMPLOYER      VARCHAR(255),
    EX_ID              INTEGER,
    ED_ID              INTEGER,
    C_ID               INTEGER,
    CONTENT_ID         INTEGER,
    OB_ID              INTEGER,
    IS_ID              INTEGER,
    CU_ADDRESS         D_TEXT_255,
    MARKED             D_BOOLEAN
);

CREATE TABLE SYNC_STATE (
    SS_ID         SMALLINT NOT NULL,
    SS_NAME       D_TEXT_64 COLLATE PXW_CYRL,
    SS_IS_REMOTE  D_BOOLEAN
);

CREATE TABLE TRANSACTION_TYPE (
    TT_ID    INTEGER NOT NULL,
    TT_NAME  D_TEXT_64 COLLATE PXW_CYRL,
    TT_SIGN  D_SIGN NOT NULL
);

CREATE TABLE USER_LOG (
    UL_ID           INTEGER NOT NULL,
    UL_TIME         TIMESTAMP,
    UL_US_ID        INTEGER,
    UL_TABLE        D_TEXT_64 COLLATE PXW_CYRL,
    UL_CHANGE_TYPE  D_TEXT_64 COLLATE PXW_CYRL,
    UL_LOG_OLD      D_TEXT_255 COLLATE PXW_CYRL,
    UL_LOG_NEW      D_TEXT_255 COLLATE PXW_CYRL,
    UL_IS_REMOTE    D_BOOLEAN
);

CREATE TABLE USER_LOGIN_LOG (
    ULL_ID         INTEGER NOT NULL,
    ULL_DATE       TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    US_ID          INTEGER,
    AG_ID          INTEGER,
    ULL_HOST       D_TEXT_64 COLLATE PXW_CYRL,
    ULL_IS_REMOTE  D_BOOLEAN DEFAULT 0 NOT NULL
);

CREATE TABLE USR (
    US_ID                    INTEGER NOT NULL,
    US_NAME                  D_NAME NOT NULL,
    US_DISK_ID               VARCHAR(100),
    US_PASSWORD              VARCHAR(100),
    US_TYPE                  INTEGER,
    US_OFFICE_NAME           D_TEXT_64 COLLATE PXW_CYRL,
    US_IS_REMOTE             D_BOOLEAN NOT NULL,
    US_AUTO_REFRESH          D_BOOLEAN DEFAULT 1 NOT NULL,
    US_CAN_EDIT_CUST_UNIQUE  D_BOOLEAN DEFAULT 0 NOT NULL,
    OF_ID                    INTEGER,
    US_IS_ACTIVE             D_BOOLEAN,
    US_ACCOUNT               D_TEXT_255,
    US_CAN_BLOCK_COVER       D_BOOLEAN
);

CREATE TABLE USR_RIGHTS (
    US_ID  INTEGER NOT NULL,
    AG_ID  INTEGER NOT NULL
);

CREATE TABLE USR_TYPE (
    UT_ID    INTEGER NOT NULL,
    UT_NAME  D_TEXT_64 COLLATE PXW_CYRL
);

CREATE TABLE VERSTKA_DIAGNOZ (
    VD_ID    SMALLINT NOT NULL,
    VD_NAME  D_TEXT_64 NOT NULL COLLATE PXW_CYRL
);



/******************************************************************************/
/***                                 Views                                  ***/
/******************************************************************************/


/* View: SDELKA_REAL */
CREATE VIEW SDELKA_REAL(
    AG_ID,
    SD_ID,
    SD_TYPE,
    SD_STATE,
    CU_ID,
    AS_ID,
    SD_COMMENT,
    SD_SUM,
    SD_PERCENT,
    SD_SUM_DEFAULT,
    SD_PERCENT_DEFAULT,
    SD_SKIDKA,
    PT_ID,
    SD_SETTING_SUM_AND_PERCENT,
    GZ_ID,
    SD_SUM_PAYED,
    SD_ALL_PAYED,
    SD_COMMENT_SHORT,
    SD_IS_CHANGED_COPY_OF_SD_ID,
    SD_ID_COMPOUND,
    SD_PAY_NOW,
    SD_FACT_NUM,
    SD_KA_START_DATE,
    SD_KA_END_DATE,
    SD_FACT_DATE,
    SD_DATE,
    SD_PERCENT_SUM,
    SD_PERCENT_GIVEN,
    SD_TO_GIVE_PERCENT,
    SD_APPROVED_DATE,
    SD_IS_BEZNAL_V_NAL,
    SD_PAY_DATE,
    SD_NEW_CUST,
    SD_PERCENT_SUM_TO_GIVE)
AS
SELECT
    AG_ID,
    SD_ID,
    SD_TYPE,
    SD_STATE,
    CU_ID,
    AS_ID,
    SD_COMMENT,
    SD_SUM,
    SD_PERCENT,
    SD_SUM_DEFAULT,
    SD_PERCENT_DEFAULT,
    SD_SKIDKA,
    PT_ID,
    SD_SETTING_SUM_AND_PERCENT,
    GZ_ID,
    SD_SUM_PAYED,
    SD_ALL_PAYED,
    SD_COMMENT_SHORT,
    SD_IS_CHANGED_COPY_OF_SD_ID,
    SD_ID_COMPOUND,
    SD_PAY_NOW,
    SD_FACT_NUM,
    SD_KA_START_DATE,
    SD_KA_END_DATE,
    SD_FACT_DATE,
    SD_DATE,
    SD_PERCENT_SUM,
    SD_PERCENT_GIVEN,
    SD_TO_GIVE_PERCENT,
    SD_APPROVED_DATE,
    SD_IS_BEZNAL_V_NAL,
    SD_PAY_DATE,
    SD_NEW_CUST,
    SD_PERCENT_SUM_TO_GIVE
FROM SDELKA SD
WHERE SD.SD_STATE<>100 AND
      SD.AS_ID<>2
;



/* View: SDELKA_CURRENT */
CREATE VIEW SDELKA_CURRENT(
    AG_ID,
    SD_ID,
    SD_TYPE,
    SD_STATE,
    CU_ID,
    AS_ID,
    SD_COMMENT,
    SD_SUM,
    SD_PERCENT,
    SD_SUM_DEFAULT,
    SD_PERCENT_DEFAULT,
    SD_SKIDKA,
    PT_ID,
    SD_SETTING_SUM_AND_PERCENT,
    GZ_ID,
    SD_SUM_PAYED,
    SD_ALL_PAYED,
    SD_COMMENT_SHORT,
    SD_IS_CHANGED_COPY_OF_SD_ID,
    SD_ID_COMPOUND,
    SD_PAY_NOW,
    SD_FACT_NUM,
    SD_KA_START_DATE,
    SD_KA_END_DATE,
    SD_FACT_DATE,
    SD_DATE,
    SD_PERCENT_SUM,
    SD_PERCENT_GIVEN,
    SD_TO_GIVE_PERCENT,
    SD_APPROVED_DATE,
    SD_IS_BEZNAL_V_NAL,
    SD_PAY_DATE,
    SD_NEW_CUST,
    SD_PERCENT_SUM_TO_GIVE)
AS
SELECT *
FROM SDELKA_REAL SDR
WHERE SDR.SD_STATE=4
;



/* View: SDELKA_SERVICE */
CREATE VIEW SDELKA_SERVICE(
    SR_ID,
    AG_ID,
    SD_ID,
    SR_AMOUNT,
    SR_SUM,
    SR_TYPE,
    SR_DESCRIPTION,
    SE_NAME,
    SE_DESCRIPTION)
AS
select sr.SR_ID, sd.AG_ID, sd.SD_ID, sr.SR_AMOUNT, sr.SR_SUM, se.SE_ID as SR_TYPE, sr.SR_DESCRIPTION, se.SE_NAME, se.SE_DESCRIPTION
from SDELKA sd
left join SERVICE_TYPE se on (1 = 1)
left join SERVICE sr on (sr.AG_ID = sd.AG_ID and sr.SD_ID = sd.SD_ID and sr.SR_TYPE = se.SE_ID)
where    se.SE_IS_ACTIVE = 1
      or sr.SR_ID is not null
;




/* Check constraints definition */

ALTER TABLE ONE_ROW_TABLE ADD CHECK (ORT_ID=0);


/******************************************************************************/
/***                           Unique Constraints                           ***/
/******************************************************************************/

ALTER TABLE CHANGE_AGENT_TASK ADD CONSTRAINT PK_CAT_SDELKA_ONCE UNIQUE (AG_ID_SRC, SD_ID_SRC);
ALTER TABLE ISSUE ADD CONSTRAINT UK_ISSUE_AND_GAZETA UNIQUE (IS_ID, GZ_ID);


/******************************************************************************/
/***                              Primary Keys                              ***/
/******************************************************************************/

ALTER TABLE ACCESS_RIGHTS_RULE ADD CONSTRAINT PK_ACCESS_RIGHTS_RULE PRIMARY KEY (ARR_WINDOW_NAME, ARR_ORDER);
ALTER TABLE ADMIN_LOG ADD CONSTRAINT PK_ADMIN_LOG PRIMARY KEY (US_ID, AL_ID);
ALTER TABLE ADMIN_TOOLS ADD CONSTRAINT PK_ADMIN_TOOLS PRIMARY KEY (AT_ID);
ALTER TABLE AGENT ADD CONSTRAINT PK_AGENT PRIMARY KEY (AG_ID);
ALTER TABLE AGENT_PERCENT ADD CONSTRAINT PK_AGENT_PERCENT PRIMARY KEY (AG_ID, IS_ID);
ALTER TABLE APPROVING_STATUS ADD CONSTRAINT PK_APPROVING_STATUS PRIMARY KEY (AS_ID);
ALTER TABLE BANK ADD CONSTRAINT PK_BANK PRIMARY KEY (ID_B);
ALTER TABLE BLANK_IN_GLOBAL_STACK ADD CONSTRAINT PK_BLANK_IN_GLOBAL_STACK PRIMARY KEY (BI_ID);
ALTER TABLE BONUS_TRANSACTIONS ADD CONSTRAINT PK_BONUS_TRANSACTIONS PRIMARY KEY (AG_ID, CU_ID, BT_ID);
ALTER TABLE BOOL ADD CONSTRAINT PK_BOOL PRIMARY KEY (BL_ID);
ALTER TABLE CHANGE_AGENT_TASK ADD CONSTRAINT PK_CHANGE_AGENT_TASK PRIMARY KEY (AG_ID_SRC, SD_ID_SRC, AG_ID_DST);
ALTER TABLE CITY ADD CONSTRAINT PK_CITY PRIMARY KEY (C_ID);
ALTER TABLE CUST ADD CONSTRAINT PK_CUST PRIMARY KEY (AG_ID, CU_ID);
ALTER TABLE CUST_FOR_OBJAV_EXPORT ADD CONSTRAINT PK_CUST_FOR_OBJAV_EXPORT PRIMARY KEY (AG_ID, CU_ID);
ALTER TABLE CUST_PHONE ADD CONSTRAINT PK_CUST_PHONE PRIMARY KEY (AG_ID, CU_ID, CP_NUMBER);
ALTER TABLE CUST_UNIQUE ADD CONSTRAINT PK_CUST_UNIQUE PRIMARY KEY (CUQ_REG_ID);
ALTER TABLE CUST_UNIQUE_TYPE ADD CONSTRAINT PK_CUST_UNIQUE_TYPE PRIMARY KEY (CUQT_ID);
ALTER TABLE DISTRICT ADD CONSTRAINT PK_DISTRICT PRIMARY KEY (DT_ID);
ALTER TABLE EDUCATION ADD CONSTRAINT PK_EDUCATION PRIMARY KEY (ED_ID);
ALTER TABLE EXPERIENCE ADD CONSTRAINT PK_EXPERIENCE PRIMARY KEY (EX_ID);
ALTER TABLE FORMAT ADD CONSTRAINT PK_FORMAT PRIMARY KEY (FM_ID);
ALTER TABLE FORMAT_COST ADD CONSTRAINT PK_FORMAT_COST PRIMARY KEY (GZ_ID, FM_ID);
ALTER TABLE GAZETA ADD CONSTRAINT PK_GAZETA PRIMARY KEY (GZ_ID);
ALTER TABLE ISSUE ADD CONSTRAINT PK_ISSUE PRIMARY KEY (IS_ID);
ALTER TABLE MONEY_TRANSACTIONS ADD CONSTRAINT PK_MONEY_TRANSACTIONS PRIMARY KEY (MT_ID);
ALTER TABLE NOT_PAYED_SDELKA ADD CONSTRAINT PK_NOT_PAYED_SDELKA PRIMARY KEY (AG_ID, SD_ID);
ALTER TABLE OBJAV ADD CONSTRAINT PK_OBJAV PRIMARY KEY (AG_ID, SD_ID, OB_ID);
ALTER TABLE OBJAVLENIE ADD CONSTRAINT PK_OBJAVLENIE PRIMARY KEY (OBJAV_ID);
ALTER TABLE OBJAVLENIE_DUPL ADD CONSTRAINT PK_OBJAVLENIE_DUPL PRIMARY KEY (OBJAV_ID);
ALTER TABLE OBJAV_CHANGE_LOG ADD CONSTRAINT PK_OBJAV_CHANGE_LOG PRIMARY KEY (OL_ID);
ALTER TABLE OBJAV_CONTENT ADD CONSTRAINT PK_OBJAV_CONTENT PRIMARY KEY (CONTENT_ID);
ALTER TABLE OBJAV_CONTENT_LOAD_LOG ADD PRIMARY KEY (ID);
ALTER TABLE OBJAV_CONTENT_SITE_OBJAV ADD CONSTRAINT PK_OBJAV_CONTENT_SITE_OBJAV PRIMARY KEY (CONTENT_ID, SITE_OBJAV_ID);
ALTER TABLE OBJAV_DUPL ADD CONSTRAINT PK_OBJAV_DUPL PRIMARY KEY (AG_ID, SD_ID, OB_ID);
ALTER TABLE OBJAV_LIST_V_NOMER_TEMP ADD CONSTRAINT PK_OBJAV_LIST_V_NOMER_TEMP PRIMARY KEY (AG_ID, SD_ID, OB_ID, PD_ID, RB_ID);
ALTER TABLE OBJAV_PHONES_REG_TEMP ADD CONSTRAINT PK_OBJAV_PHONES_REG_TEMP PRIMARY KEY (AG_ID, SD_ID, OB_ID, OB_PHONE);
ALTER TABLE OBJAV_PHONES_TEMP ADD CONSTRAINT PK_OBJAV_PHONES_TEMP PRIMARY KEY (AG_ID, SD_ID, OB_ID, OB_PHONE);
ALTER TABLE OBJAV_STATE ADD PRIMARY KEY (OS_ID);
ALTER TABLE OBJAV_STATE_LOG ADD CONSTRAINT PK_OBJAV_STATE_LOG PRIMARY KEY (OSL_ID, OSL_IS_REMOTE);
ALTER TABLE OBJAV_SVERSTANO ADD CONSTRAINT PK_OBJAV_SVERSTANO PRIMARY KEY (AG_ID, SD_ID, OB_ID, RB_ID, PD_ID);
ALTER TABLE OBJAV_WORKING_LIST ADD CONSTRAINT PK_OBJAV_WORKING_LIST PRIMARY KEY (AG_ID, SD_ID, OB_ID);
ALTER TABLE OFFICE ADD CONSTRAINT PK_OFFICE PRIMARY KEY (OF_ID);
ALTER TABLE ONE_ROW_TABLE ADD CONSTRAINT PK_ONE_ROW_TABLE PRIMARY KEY (ORT_ID);
ALTER TABLE OTKAZNIK ADD CONSTRAINT PK_OTKAZNIK PRIMARY KEY (OT_NUMBER);
ALTER TABLE PAY_TYPE ADD CONSTRAINT PK_PAY_TYPE PRIMARY KEY (PT_ID);
ALTER TABLE PHONE ADD CONSTRAINT PK_PHONE PRIMARY KEY (AG_ID, SD_ID, PH_NUMBER);
ALTER TABLE PODACHA ADD CONSTRAINT PK_PODACHA PRIMARY KEY (PD_ID);
ALTER TABLE PREDMET_RAHUNKU ADD CONSTRAINT PK_PREDMET_RAHUNKU PRIMARY KEY (PR_ID);
ALTER TABLE REQUISITE ADD CONSTRAINT PK_REQUISITE PRIMARY KEY (RQ_ID);
ALTER TABLE RESERVE_MAP ADD CONSTRAINT PK_RESERVE_MAP PRIMARY KEY (RM_ID);
ALTER TABLE RESERVE_RECORD ADD CONSTRAINT PK_RESERVE_RECORD PRIMARY KEY (RR_ID);
ALTER TABLE RUBRIKA ADD CONSTRAINT PK_RUBRIKA PRIMARY KEY (RB_ID);
ALTER TABLE RUBRIKA_HOT ADD CONSTRAINT PK_RUBRIKA_HOT PRIMARY KEY (RB_ID);
ALTER TABLE RUBRIKA_NOT_VACS ADD CONSTRAINT PK_RUBRIKA_NOT_VACS PRIMARY KEY (RB_ID);
ALTER TABLE RUBRIKA_POHOZHA ADD CONSTRAINT PK_RUBRIKA_POHOZHA PRIMARY KEY (RS_ID, RB_ID);
ALTER TABLE RUBRIKA_SITE ADD CONSTRAINT PK_RUBRIKA_SITE PRIMARY KEY (RS_ID);
ALTER TABLE SDELKA ADD CONSTRAINT PK_SDELKA PRIMARY KEY (AG_ID, SD_ID);
ALTER TABLE SDELKA_CHANGE_LOG ADD CONSTRAINT PK_SDELKA_CHANGE_LOG PRIMARY KEY (SL_ID);
ALTER TABLE SDELKA_DUPL ADD CONSTRAINT PK_SDELKA_DUPL PRIMARY KEY (AG_ID, SD_ID);
ALTER TABLE SDELKA_DUPLICATE_SUM ADD CONSTRAINT PK_SDELKA_DUPLICATE_SUM PRIMARY KEY (GZ_ID_SOURCE, GZ_ID_DUPLICATE, SUM_SOURCE);
ALTER TABLE SDELKA_DUPLICATING ADD CONSTRAINT PK_SDELKA_DUPLICATING PRIMARY KEY (AG_ID, SD_ID);
ALTER TABLE SDELKA_STATE ADD CONSTRAINT PK_SDELKA_STATE PRIMARY KEY (SDS_ID);
ALTER TABLE SDELKA_TYPE ADD CONSTRAINT PK_SDELKA_TYPE PRIMARY KEY (SDT_ID);
ALTER TABLE SDELKA_WORKING_LIST ADD CONSTRAINT PK_SDELKA_WORKING_LIST PRIMARY KEY (AG_ID, SD_ID);
ALTER TABLE SERVICE_TYPE ADD CONSTRAINT PK_SERVICE_TYPE PRIMARY KEY (SE_ID);
ALTER TABLE SITE_OBJAV ADD CONSTRAINT PK_SITE_OBJAV PRIMARY KEY (SITE_OBJAV_ID);
ALTER TABLE SYNC_STATE ADD CONSTRAINT PK_SYNC_STATE PRIMARY KEY (SS_ID);
ALTER TABLE TRANSACTION_TYPE ADD CONSTRAINT PK_TRANSACTION_TYPE PRIMARY KEY (TT_ID);
ALTER TABLE USER_LOG ADD CONSTRAINT PK_USER_LOG PRIMARY KEY (UL_ID);
ALTER TABLE USER_LOGIN_LOG ADD CONSTRAINT PK_USER_LOGIN_LOG PRIMARY KEY (ULL_ID);
ALTER TABLE USR ADD PRIMARY KEY (US_ID);
ALTER TABLE USR_RIGHTS ADD PRIMARY KEY (US_ID, AG_ID);
ALTER TABLE USR_TYPE ADD CONSTRAINT PK_USR_TYPE PRIMARY KEY (UT_ID);
ALTER TABLE VERSTKA_DIAGNOZ ADD CONSTRAINT PK_VERSTKA_DIAGNOZ PRIMARY KEY (VD_ID);


/******************************************************************************/
/***                              Foreign Keys                              ***/
/******************************************************************************/

ALTER TABLE AGENT_PERCENT ADD CONSTRAINT FK_AGENT_PERCENT_FOR_AGENT FOREIGN KEY (AG_ID) REFERENCES AGENT (AG_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE AGENT_PERCENT ADD CONSTRAINT FK_AGENT_PERCENT_FOR_ISSUE FOREIGN KEY (IS_ID) REFERENCES ISSUE (IS_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE BONUS_TRANSACTIONS ADD CONSTRAINT FK_BT_FOR_CUST FOREIGN KEY (AG_ID, CU_ID) REFERENCES CUST (AG_ID, CU_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE CUST ADD CONSTRAINT FK_CUST_CUST_UNIQUE FOREIGN KEY (CUQ_REG_ID) REFERENCES CUST_UNIQUE (CUQ_REG_ID) ON DELETE SET NULL ON UPDATE CASCADE;
ALTER TABLE CUST ADD CONSTRAINT FK_CUST_FOR_AGENT FOREIGN KEY (AG_ID) REFERENCES AGENT (AG_ID) ON UPDATE CASCADE;
ALTER TABLE CUST_PHONE ADD CONSTRAINT FK_CUST_PHONE_FOR_CUST FOREIGN KEY (AG_ID, CU_ID) REFERENCES CUST (AG_ID, CU_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE FORMAT_COST ADD CONSTRAINT FK_FORMAT_COST_FM_ID FOREIGN KEY (FM_ID) REFERENCES FORMAT (FM_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE FORMAT_COST ADD CONSTRAINT FK_FORMAT_COST_GZ_ID FOREIGN KEY (GZ_ID) REFERENCES GAZETA (GZ_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE MONEY_TRANSACTIONS ADD CONSTRAINT FK_MT_FOR_USER FOREIGN KEY (US_ID) REFERENCES USR (US_ID) ON UPDATE CASCADE;
ALTER TABLE NOT_PAYED_SDELKA ADD CONSTRAINT FK_NOT_PAYED_SDELKA_AGENT FOREIGN KEY (AG_ID) REFERENCES AGENT (AG_ID);
ALTER TABLE NOT_PAYED_SDELKA ADD CONSTRAINT FK_NOT_PAYED_SDELKA_CUST FOREIGN KEY (AG_ID, CU_ID) REFERENCES CUST (AG_ID, CU_ID) ON UPDATE CASCADE;
ALTER TABLE NOT_PAYED_SDELKA ADD CONSTRAINT FK_NOT_PAYED_SDELKA_SDELKA FOREIGN KEY (AG_ID, SD_ID) REFERENCES SDELKA (AG_ID, SD_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE OBJAV ADD CONSTRAINT FK_OBJAV_DISTRICT FOREIGN KEY (DISTRICT_ID) REFERENCES DISTRICT (DT_ID) ON UPDATE CASCADE;
ALTER TABLE OBJAV ADD CONSTRAINT FK_OBJAV_FOR_SDELKA FOREIGN KEY (AG_ID, SD_ID) REFERENCES SDELKA (AG_ID, SD_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE OBJAVLENIE ADD CONSTRAINT FK_OBJAVLENIE_CONTENT FOREIGN KEY (CONTENT_ID) REFERENCES OBJAV_CONTENT (CONTENT_ID) ON UPDATE CASCADE;
ALTER TABLE OBJAVLENIE ADD CONSTRAINT FK_OBJAVLENIE_DISTRICT FOREIGN KEY (DISTRICT_ID) REFERENCES DISTRICT (DT_ID) ON UPDATE CASCADE;
ALTER TABLE OBJAVLENIE ADD CONSTRAINT FK_OBJAVLENIE_DOUBLE_RUBRIKA FOREIGN KEY (DOUBLE_RB_ID) REFERENCES RUBRIKA (RB_ID) ON UPDATE CASCADE;
ALTER TABLE OBJAVLENIE ADD CONSTRAINT FK_OBJAVLENIE_PODACHA FOREIGN KEY (PD_ID) REFERENCES PODACHA (PD_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE OBJAVLENIE ADD CONSTRAINT FK_OBJAVLENIE_RUBRIKA FOREIGN KEY (RB_ID) REFERENCES RUBRIKA (RB_ID) ON UPDATE CASCADE;
ALTER TABLE OBJAVLENIE_DUPL ADD CONSTRAINT FK_OBJAVLENIE_DUPL_OF FOREIGN KEY (DUPL_OF_OBJAV_ID) REFERENCES OBJAVLENIE (OBJAV_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE OBJAVLENIE_DUPL ADD CONSTRAINT FK_OBJAVLENIE_DUPL_TO FOREIGN KEY (OBJAV_ID) REFERENCES OBJAVLENIE (OBJAV_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE OBJAV_CONTENT ADD CONSTRAINT FK_OBJAV_CONTENT_FORMAT FOREIGN KEY (FM_ID) REFERENCES FORMAT (FM_ID);
ALTER TABLE OBJAV_CONTENT ADD CONSTRAINT FK_OBJAV_CONTENT_RUBRIKA FOREIGN KEY (RB_ID) REFERENCES RUBRIKA (RB_ID);
ALTER TABLE OBJAV_CONTENT_LOAD_LOG ADD CONSTRAINT FK_OBJAV_CONTENT_LOAD_CONTE FOREIGN KEY (CONTENT_ID) REFERENCES OBJAV_CONTENT (CONTENT_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE OBJAV_CONTENT_LOAD_LOG ADD CONSTRAINT FK_OBJAV_CONTENT_LOAD_OBJAV FOREIGN KEY (OBJAV_ID) REFERENCES OBJAVLENIE (OBJAV_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE OBJAV_DUPL ADD CONSTRAINT FK_OBJAV_DUPL_OF FOREIGN KEY (DUPL_OF_AG_ID, DUPL_OF_SD_ID, DUPL_OF_OB_ID) REFERENCES OBJAV (AG_ID, SD_ID, OB_ID);
ALTER TABLE OBJAV_DUPL ADD CONSTRAINT FK_OBJAV_DUPL_TO FOREIGN KEY (AG_ID, SD_ID, OB_ID) REFERENCES OBJAV (AG_ID, SD_ID, OB_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE OBJAV_WORKING_LIST ADD CONSTRAINT FK_OBJAV_WORKING_LIST_OBJAV FOREIGN KEY (AG_ID, SD_ID, OB_ID) REFERENCES OBJAV (AG_ID, SD_ID, OB_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE PHONE ADD CONSTRAINT FK_PHONE_FOR_SDELKA FOREIGN KEY (AG_ID, SD_ID) REFERENCES SDELKA (AG_ID, SD_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE PODACHA ADD CONSTRAINT FK_PODACHA_FOR_SDELKA FOREIGN KEY (AG_ID, SD_ID) REFERENCES SDELKA (AG_ID, SD_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE PODACHA ADD CONSTRAINT FK_PODACHA_IN_ISSUE FOREIGN KEY (IS_ID) REFERENCES ISSUE (IS_ID) ON UPDATE CASCADE;
ALTER TABLE PODACHA ADD CONSTRAINT FK_PODACHA_IN_ISSUE_GAZETA FOREIGN KEY (IS_ID, GZ_ID) REFERENCES ISSUE (IS_ID, GZ_ID);
ALTER TABLE RUBRIKA ADD CONSTRAINT FK_RUBRIKA_GAZETA FOREIGN KEY (GZ_ID) REFERENCES GAZETA (GZ_ID);
ALTER TABLE RUBRIKA_HOT ADD CONSTRAINT FK_RUBRIKA_HOT_RB_ID FOREIGN KEY (RB_ID) REFERENCES RUBRIKA (RB_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE RUBRIKA_NOT_VACS ADD CONSTRAINT FK_RUBRIKA_NOT_VACS_RB_ID FOREIGN KEY (RB_ID) REFERENCES RUBRIKA (RB_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE SDELKA ADD CONSTRAINT FK_SDELKA_FOR_AGENT FOREIGN KEY (AG_ID) REFERENCES AGENT (AG_ID);
ALTER TABLE SDELKA ADD CONSTRAINT FK_SDELKA_FOR_CUST FOREIGN KEY (AG_ID, CU_ID) REFERENCES CUST (AG_ID, CU_ID) ON UPDATE CASCADE;
ALTER TABLE SDELKA ADD CONSTRAINT FK_SDELKA_REG_BY FOREIGN KEY (REGISTERED_BY_ID) REFERENCES USR (US_ID) ON UPDATE CASCADE;
ALTER TABLE SDELKA ADD CONSTRAINT FK_SDELKA_REQUISITE FOREIGN KEY (RQ_ID) REFERENCES REQUISITE (RQ_ID);
ALTER TABLE SDELKA_CHANGE_LOG ADD CONSTRAINT FK_SDELKA_CHANGE_AS_ID FOREIGN KEY (AS_ID) REFERENCES APPROVING_STATUS (AS_ID);
ALTER TABLE SDELKA_CHANGE_LOG ADD CONSTRAINT FK_SDELKA_CHANGE_LOG_SD FOREIGN KEY (AG_ID, SD_ID) REFERENCES SDELKA (AG_ID, SD_ID) ON DELETE CASCADE ON UPDATE CASCADE
  USING INDEX FK_SDELKA_CHANGE_LOG_SDELKA;
ALTER TABLE SDELKA_CHANGE_LOG ADD CONSTRAINT FK_SDELKA_CHANGE_STATE FOREIGN KEY (SD_STATE) REFERENCES SDELKA_STATE (SDS_ID);
ALTER TABLE SDELKA_CHANGE_LOG ADD CONSTRAINT FK_SDELKA_CHANGE_USER FOREIGN KEY (US_ID) REFERENCES USR (US_ID);
ALTER TABLE SDELKA_DUPL ADD CONSTRAINT FK_SDELKA_DUPL_OF FOREIGN KEY (DUPL_OF_AG_ID, DUPL_OF_SD_ID) REFERENCES SDELKA (AG_ID, SD_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE SDELKA_DUPL ADD CONSTRAINT FK_SDELKA_DUPL_TO FOREIGN KEY (AG_ID, SD_ID) REFERENCES SDELKA (AG_ID, SD_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE SDELKA_WORKING_LIST ADD CONSTRAINT FK_SDELKA_WORKING_LIST_AGENT FOREIGN KEY (AG_ID) REFERENCES AGENT (AG_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE SDELKA_WORKING_LIST ADD CONSTRAINT FK_SDELKA_WORKING_LIST_SDELKA FOREIGN KEY (AG_ID, SD_ID) REFERENCES SDELKA (AG_ID, SD_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE USR ADD CONSTRAINT FK_USR_OFFICE FOREIGN KEY (OF_ID) REFERENCES OFFICE (OF_ID) ON DELETE SET NULL ON UPDATE CASCADE;
ALTER TABLE USR_RIGHTS ADD CONSTRAINT FK_USR_RIGHTS_FOR_AGENT FOREIGN KEY (AG_ID) REFERENCES AGENT (AG_ID) ON DELETE CASCADE ON UPDATE CASCADE;
ALTER TABLE USR_RIGHTS ADD CONSTRAINT FK_USR_RIGHTS_FOR_USR FOREIGN KEY (US_ID) REFERENCES USR (US_ID) ON DELETE CASCADE ON UPDATE CASCADE;


/******************************************************************************/
/***                                Indices                                 ***/
/******************************************************************************/

CREATE INDEX I_AG_NAME ON AGENT (AG_NAME);
CREATE INDEX IDX_CUST_CU_ID ON CUST (CU_ID);
CREATE INDEX IDX_CU_OKPO ON CUST (CU_OKPO);
CREATE INDEX IDX_CUST_PHONE ON CUST_PHONE (CP_NUMBER);
CREATE INDEX I_CUST_PHONE_CUST ON CUST_PHONE (CU_ID);
CREATE INDEX IDX_CUQ_OKPO ON CUST_UNIQUE (CUQ_OKPO);
CREATE UNIQUE INDEX IDX_FORMAT ON FORMAT (FM_NAME);
CREATE INDEX I_FM_NAME ON FORMAT (FM_NAME);
CREATE INDEX IDX_ISSUE_DATE ON ISSUE (IS_DATE);
CREATE INDEX IDX_MONEY_TRANSACTIONS ON MONEY_TRANSACTIONS (MT_DATE);
CREATE INDEX IDX_OBJAV_SD_ID ON OBJAV (SD_ID);
CREATE INDEX I_OBJAV_AG_OB ON OBJAV (AG_ID, OB_ID);
CREATE INDEX I_OBJAV_AG_PARENT ON OBJAV (AG_ID, OB_PARENT);
CREATE INDEX I_OBJAV_PARENT ON OBJAV (OB_PARENT);
CREATE INDEX I_OBJAV_RUBRIKA ON OBJAV (RB_ID);
CREATE INDEX I_OBJAV_STATE ON OBJAV (OB_STATE);
CREATE INDEX I_OBJAVLENIE_DOUBLE ON OBJAVLENIE (DOUBLE_RB_ID);
CREATE INDEX I_OBJAVLENIE_RUBRIKA ON OBJAVLENIE (RB_ID);
CREATE INDEX I_OBJAVLENIE_SAME_CODE ON OBJAVLENIE (SAME_CODE);
CREATE INDEX I_OBJAV_CONTENT_LOAD_CONTENT ON OBJAV_CONTENT_LOAD_LOG (OBJAV_ID);
CREATE INDEX I_OBJAV_CONTENT_LOAD_UD ON OBJAV_CONTENT_LOAD_LOG (US_ID, LL_DATE);
CREATE INDEX IDX_OBJAV_STATE_LOG ON OBJAV_STATE_LOG (OSL_TIMESTAMP);
CREATE INDEX IDX_OBJAV_WORKING_LIST ON OBJAV_WORKING_LIST (OB_STATE);
CREATE INDEX I_OBJAV_WORKING_LIST_FM_ID ON OBJAV_WORKING_LIST (FM_ID);
CREATE INDEX OTKAZNIK_IDX_AG_ID ON OTKAZNIK (AG_ID);
CREATE UNIQUE INDEX PAID_SERVICES_IDX1 ON PAID_SERVICES (ID);
CREATE INDEX IDX_PHONE ON PHONE (PH_NUMBER);
CREATE INDEX RESERVE_MAP_IDX1 ON RESERVE_MAP (IS_ID);
CREATE INDEX RESERVE_RECORD_IDX1 ON RESERVE_RECORD (RM_ID);
CREATE UNIQUE INDEX IDX_RUBRIKA ON RUBRIKA (GZ_ID, RB_NAME);
CREATE INDEX I_RB_NAME ON RUBRIKA (RB_NAME);
CREATE UNIQUE INDEX I_RB_NAME_SHORT ON RUBRIKA (GZ_ID, RB_NAME_SHORT);
CREATE INDEX I_SDELKA_AG_CU ON SDELKA (AG_ID, CU_ID);
CREATE INDEX I_SDELKA_APPROVED_DATE ON SDELKA (SD_APPROVED_DATE);
CREATE INDEX I_SDELKA_APPR_DATE ON SDELKA (SD_APPROVED_DATE);
CREATE INDEX I_SDELKA_CHANGED_COPY ON SDELKA (SD_IS_CHANGED_COPY_OF_SD_ID);
CREATE INDEX I_SDELKA_DATE ON SDELKA (SD_DATE);
CREATE INDEX I_SDELKA_FACT_NUM ON SDELKA (SD_FACT_NUM);
CREATE INDEX I_SDELKA_PAY_DATE ON SDELKA (SD_PAY_DATE);
CREATE INDEX I_SDELKA_PAY_TYPE ON SDELKA (PT_ID);
CREATE INDEX I_SDELKA_SD_ID ON SDELKA (SD_ID);
CREATE INDEX SDELKA_IDX1 ON SDELKA (SD_NUM);
CREATE INDEX SITE_OBJAV_IDX1 ON SITE_OBJAV (CONTENT_ID);
CREATE INDEX SITE_OBJAV_IDX2 ON SITE_OBJAV (OB_ID);
CREATE INDEX SITE_OBJAV_IDX3 ON SITE_OBJAV (EX_ID);
CREATE INDEX SITE_OBJAV_IDX4 ON SITE_OBJAV (ED_ID);
CREATE INDEX SITE_OBJAV_IDX5 ON SITE_OBJAV (C_ID);
CREATE INDEX I_US_NAME ON USR (US_NAME);
CREATE INDEX I_UR_US_ID ON USR_RIGHTS (US_ID);


/******************************************************************************/
/***                                Triggers                                ***/
/******************************************************************************/


SET TERM ^ ;



/******************************************************************************/
/***                      Triggers for updatable views                      ***/
/******************************************************************************/



/* Trigger: SDELKA_SERVICE_BU0 */
CREATE TRIGGER SDELKA_SERVICE_BU0 FOR SDELKA_SERVICE
ACTIVE AFTER UPDATE OR DELETE POSITION 0
AS
BEGIN
  POST_EVENT 'DUMMY_EVENT';
END
^

ALTER TRIGGER SDELKA_SERVICE_BU0
AS
begin
    if (   (DELETING and OLD.SR_ID is not null)
        or (    UPDATING
            and NEW.SR_AMOUNT is null
            and NEW.SR_SUM is null))
    then
        delete from SERVICE
        where SR_ID = OLD.SR_ID;
    else if (UPDATING) then
    begin
        if (OLD.SR_ID is not null) then
            update SERVICE
            set  SR_AMOUNT = NEW.SR_AMOUNT
                ,SR_SUM = coalesce(NEW.SR_SUM, 0)
                ,SR_DESCRIPTION = NEW.SR_DESCRIPTION
            where SR_ID = NEW.SR_ID;
        else
            insert into SERVICE (SR_ID, AG_ID, SD_ID, SR_AMOUNT, SR_SUM, SR_TYPE, SR_DESCRIPTION)
            values (NEW.SR_ID, NEW.AG_ID, NEW.SD_ID, NEW.SR_AMOUNT, coalesce(NEW.SR_SUM, 0), NEW.SR_TYPE, NEW.SR_DESCRIPTION);
    end
end
^

/******************************************************************************/
/***                          Triggers for tables                           ***/
/******************************************************************************/



/* Trigger: ADMIN_LOG_BI */
CREATE TRIGGER ADMIN_LOG_BI FOR ADMIN_LOG
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
    IF (NEW.AL_ID IS NULL) THEN
        NEW.AL_ID=GEN_ID(G_AL_ID,1);
END
^

/* Trigger: BI_USER_LOGIN_LOG_ULL_ID */
CREATE TRIGGER BI_USER_LOGIN_LOG_ULL_ID FOR USER_LOGIN_LOG
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.ULL_ID IS NULL) THEN
      NEW.ULL_ID = GEN_ID(G_ULL_ID, 1);
END
^

/* Trigger: BLANK_IN_GLOBAL_STACK_BI */
CREATE TRIGGER BLANK_IN_GLOBAL_STACK_BI FOR BLANK_IN_GLOBAL_STACK
ACTIVE BEFORE INSERT POSITION 0
AS
declare variable nomer integer;
BEGIN
  new.bi_id=gen_id(g_bigs_id,1);
  select max(params.pm_current_issue_pr) from params
    into nomer;
  new.bi_issue=nomer;
END
^

/* Trigger: BONUS_TRANSACTIONS_BI */
CREATE TRIGGER BONUS_TRANSACTIONS_BI FOR BONUS_TRANSACTIONS
ACTIVE BEFORE INSERT POSITION 0
AS
declare variable b_was FLOAT;
declare variable last_id INTEGER;
BEGIN
    NEW.BT_ID=gen_id(G_BT_ID,1);

    SELECT MAX(BT_ID) FROM BONUS_TRANSACTIONS
        WHERE AG_ID=NEW.AG_ID AND CU_ID=NEW.CU_ID
        INTO :last_id
    ;
    
    SELECT BT_SUM FROM BONUS_TRANSACTIONS
        WHERE AG_ID=NEW.AG_ID AND CU_ID=NEW.CU_ID AND BT_ID=:last_id
        INTO :b_was
    ;
    if (b_was IS NULL) then
        b_was=0;
        
    NEW.BT_SUM=b_was+NEW.BT_CHANGE;
    
    NEW.BT_DATE=CURRENT_TIMESTAMP;
END
^

/* Trigger: CITY_BI */
CREATE TRIGGER CITY_BI FOR CITY
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.C_ID IS NULL) THEN
    NEW.C_ID = GEN_ID(GEN_CITY_ID,1);
END
^

/* Trigger: CUST_BU */
CREATE TRIGGER CUST_BU FOR CUST
ACTIVE BEFORE UPDATE POSITION 0
AS
    DECLARE VARIABLE CUQ_ID integer;
BEGIN
    NEW.EDIT_TIME = CURRENT_TIMESTAMP;

    IF (OLD.CU_OKPO<>NEW.CU_OKPO AND
        NEW.CU_OKPO IS NOT NULL AND
        NEW.CU_OKPO<>'' AND
        NEW.CU_OKPO<>'00000000' AND
        NEW.CU_OKPO<>'000000000') THEN
    BEGIN
        CUQ_ID=0;

        SELECT MIN(CUQ_REG_ID)
        FROM CUST_UNIQUE
        WHERE CUQ_OKPO=NEW.CU_OKPO
        INTO :CUQ_ID;

        if (CUQ_ID<>0) then
             NEW.CUQ_REG_ID=:CUQ_ID;
        else
             NEW.CUQ_REG_ID=null;
    END

    IF (NEW.CU_OKPO IS NULL
        OR NEW.CU_OKPO=''
        OR NEW.CU_OKPO='00000000'
        OR NEW.CU_OKPO='000000000')
    THEN
        NEW.CUQ_REG_ID=NULL;
END
^

/* Trigger: CUST_PHONE_BI1 */
CREATE TRIGGER CUST_PHONE_BI1 FOR CUST_PHONE
ACTIVE BEFORE INSERT POSITION 2
AS
BEGIN
    IF (NEW.CP_ADDDATE IS NULL) THEN
        NEW.CP_ADDDATE=CURRENT_TIMESTAMP;
END
^

/* Trigger: CUST_UNIQUE_AI */
CREATE TRIGGER CUST_UNIQUE_AI FOR CUST_UNIQUE
ACTIVE AFTER INSERT POSITION 0
AS
DECLARE VARIABLE CNT INTEGER;
BEGIN
--Проставим всем клиентам агентов этого уникального клиента
--по ОКПО
    IF (NEW.CUQ_OKPO IS NOT NULL AND NEW.CUQ_OKPO<>'' AND NEW.CUQ_OKPO<>'00000000' AND NEW.CUQ_OKPO<>'000000000') THEN
        UPDATE CUST CU
        SET CU.CUQ_REG_ID=NEW.CUQ_REG_ID
        WHERE CU.CU_OKPO=NEW.CUQ_OKPO;
            -- AND CU.CUQ_REG_ID IS NULL;
END
^

/* Trigger: CUST_UNIQUE_AU */
CREATE TRIGGER CUST_UNIQUE_AU FOR CUST_UNIQUE
ACTIVE AFTER UPDATE POSITION 0
AS
BEGIN
    IF (NEW.CUQ_OKPO<>OLD.CUQ_OKPO) THEN
    BEGIN
--Поменялся ОКПО - проверим всех клиентов агентов, которые
--были с этим уникальным клиентом связаны раньше
       -- UPDATE CUST CU
      --  SET CU.CUQ_REG_ID=NULL
      --  WHERE CU.CUQ_REG_ID=OLD.CUQ_REG_ID;
 -- почему не изменяет старый ОКПО - "переводит в NULL"
    END
END
^

/* Trigger: CUST_UNIQUE_BI */
CREATE TRIGGER CUST_UNIQUE_BI FOR CUST_UNIQUE
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
    IF ((NEW.CUQ_REG_ID IS NULL) OR (NEW.CUQ_REG_ID=0)) THEN
        NEW.CUQ_REG_ID=GEN_ID(G_CUQ_ID,1);

    IF (NEW.CUQ_1C_ID IS NULL) THEN
        NEW.CUQ_1C_ID=0;

/*$$IBEC$$     IF (NEW.CUQ_ADDRESS_REAL IS NULL OR
        NEW.CUQ_ADDRESS_REAL='')
    THEN
        NEW.CUQ_ADDRESS_REAL=NEW.CUQ_ADDRESS; $$IBEC$$*/

    NEW.CUQ_CHANGED=1;

    NEW.EDIT_TIME = CURRENT_TIMESTAMP;
END
^

/* Trigger: CUST_UNIQUE_BU */
CREATE TRIGGER CUST_UNIQUE_BU FOR CUST_UNIQUE
ACTIVE BEFORE UPDATE POSITION 0
AS
BEGIN
    IF ((OLD.CUQ_CHANGED=NEW.CUQ_CHANGED)AND
        (OLD.CUQ_CHANGED=0)) then
        NEW.CUQ_CHANGED=1;

    NEW.EDIT_TIME = CURRENT_TIMESTAMP;
END
^

/* Trigger: MONEY_TRANSACTIONS_BI */
CREATE TRIGGER MONEY_TRANSACTIONS_BI FOR MONEY_TRANSACTIONS
ACTIVE BEFORE INSERT POSITION 0
AS
declare variable m_was FLOAT;
declare variable last_id INTEGER;
BEGIN
    NEW.MT_ID=gen_id(G_MT_ID,1);

    IF (NEW.MT_SUM IS NULL) THEN
    BEGIN
        SELECT MAX(MT_ID) FROM MONEY_TRANSACTIONS
            WHERE US_ID=NEW.US_ID
            INTO :last_id
        ;
    
        IF (last_id IS NULL) THEN
            m_was=0;
        ELSE
            SELECT MT_SUM FROM MONEY_TRANSACTIONS
                WHERE MT_ID=:last_id
                INTO :m_was
            ;
        
        NEW.MT_SUM=m_was+NEW.MT_CHANGE;
    END
END
^

/* Trigger: OBJAVLENIE_AIU_DUPLICATE */
CREATE TRIGGER OBJAVLENIE_AIU_DUPLICATE FOR OBJAVLENIE
ACTIVE AFTER INSERT OR UPDATE OR DELETE POSITION 0
AS
    declare variable agid integer;
    declare variable sdid integer;
    declare variable objavid integer;

begin
    for
        select pd.AG_ID, pd.SD_ID, odu.DUPL_OF_OBJAV_ID
        from OBJAVLENIE_DUPL odu
        left join OBJAVLENIE ob on (ob.OBJAV_ID = odu.OBJAV_ID)
        left join PODACHA pd on (pd.PD_ID = ob.PD_ID)
        where odu.DUPL_OF_OBJAV_ID = new.OBJAV_ID
        into :agid, :sdid, :objavid
    do
        execute procedure OBJAVLENIE_DUPLICATE(:agid, :sdid, new.OBJAV_ID);
end
^

/* Trigger: OBJAVLENIE_BI */
CREATE TRIGGER OBJAVLENIE_BI FOR OBJAVLENIE
ACTIVE BEFORE INSERT POSITION 1
AS
BEGIN
    if (new.VAC_COUNT is null) then
        new.VAC_COUNT = 1;
END
^

/* Trigger: OBJAVLENIE_BIU_DISTRICT */
CREATE TRIGGER OBJAVLENIE_BIU_DISTRICT FOR OBJAVLENIE
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
as
  declare variable gz integer;
begin
  /*  Проверка для газеты "Пропоную оголошення"     --"Работа в Киеве" -
      должно быть заполнено поле "Район"                              */

  select s.GZ_ID
  from PODACHA pd
  left join SDELKA s on (s.AG_ID = pd.AG_ID and s.SD_ID = pd.SD_ID)
  where pd.PD_ID = new.PD_ID
  into :gz;

  if (gz = 2 and new.DISTRICT_ID is null) then
    new.DISTRICT_ID = 1;

 -- if (gz = 2 and new.DISTRICT_ID is null) then
 --   exception E_DISTRICT_NN;
end
^

/* Trigger: OBJAVLENIE_BI_CHECK_CONTENT */
CREATE TRIGGER OBJAVLENIE_BI_CHECK_CONTENT FOR OBJAVLENIE
ACTIVE BEFORE INSERT POSITION 0
AS
DECLARE VARIABLE CNT INTEGER;
BEGIN
/* проверим, чтобы у одной подачи не было двух одинаковых объявлений */
    SELECT COUNT(*)
    FROM OBJAVLENIE OB
    WHERE OB.PD_ID = NEW.PD_ID
          AND OB.CONTENT_ID = NEW.CONTENT_ID
    INTO :CNT;
    IF (CNT > 0) THEN
        EXCEPTION E_TWO_SAME_CONTENTS;
END
^

/* Trigger: OBJAVLENIE_BUD_BLOCK_DUPLICATE */
CREATE TRIGGER OBJAVLENIE_BUD_BLOCK_DUPLICATE FOR OBJAVLENIE
ACTIVE BEFORE UPDATE OR DELETE POSITION 0
AS
    declare variable cnt integer;
begin
    select count(*)
    from
        OBJAVLENIE_DUPL od
        left join OBJAVLENIE o on (o.OBJAV_ID = od.DUPL_OF_OBJAV_ID)
        left join PODACHA p on (p.PD_ID = o.PD_ID)
    where od.OBJAV_ID = old.OBJAV_ID
          and not exists (
              select 1
              from SDELKA_DUPLICATING d
              where d.AG_ID = p.AG_ID
                    and d.SD_ID = p.SD_ID
                    and d.CALL_COUNT > 0
          )
    into :cnt;

    if (cnt > 0) then
        exception E_CANNOT_CHANGE_DUPLICATE;
end
^

/* Trigger: OBJAVLENIE_BU_CHECK_CONTENT */
CREATE TRIGGER OBJAVLENIE_BU_CHECK_CONTENT FOR OBJAVLENIE
ACTIVE BEFORE UPDATE POSITION 0
AS
DECLARE VARIABLE CNT INTEGER;
BEGIN
/* проверим, чтобы у одной подачи не было двух одинаковых объявлений */
    IF ((NEW.CONTENT_ID <> OLD.CONTENT_ID)
       OR (NEW.PD_ID <> OLD.PD_ID)) THEN
    BEGIN
        SELECT COUNT(*)
        FROM OBJAVLENIE OB
        WHERE OB.PD_ID = NEW.PD_ID
              AND OB.CONTENT_ID = NEW.CONTENT_ID
        INTO :CNT;
        IF (CNT > 0) THEN
            EXCEPTION E_TWO_SAME_CONTENTS;
    END
END
^

/* Trigger: OBJAVLENIE_DUPL_AD0 */
CREATE TRIGGER OBJAVLENIE_DUPL_AD0 FOR OBJAVLENIE_DUPL
ACTIVE AFTER DELETE POSITION 0
AS
begin
  delete from OBJAVLENIE o
  where o.OBJAV_ID = old.OBJAV_ID;

/*    execute procedure OBJAVLENIE_DELETE(old.OBJAV_ID);*/
end
^

/* Trigger: OBJAVLENIE_LOG_BI */
CREATE TRIGGER OBJAVLENIE_LOG_BI FOR OBJAVLENIE_LOG
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.OL_ID IS NULL) THEN
    NEW.OL_ID = GEN_ID(GEN_OBJAVLENIE_LOG_ID,1);
END
^

/* Trigger: OBJAV_AI_WORKING_LIST */
CREATE TRIGGER OBJAV_AI_WORKING_LIST FOR OBJAV
ACTIVE AFTER INSERT POSITION 2
AS
BEGIN
    if (
            new.OB_STATE in (0, 1, 2)
            and new.OB_PARENT is null
            and new.OB_IS_ACTIVE = 1
    ) then begin
        insert into OBJAV_WORKING_LIST  (AG_ID, SD_ID, OB_ID, OB_STATE, FM_ID)
        values (new.AG_ID, new.SD_ID, new.OB_ID, new.OB_STATE, new.FM_ID);
    end
END
^

/* Trigger: OBJAV_AU_DUPLICATE */
CREATE TRIGGER OBJAV_AU_DUPLICATE FOR OBJAV
ACTIVE AFTER UPDATE POSITION 0
AS
    declare variable agid integer;
    declare variable sdid integer;
begin
    for
        select odu.AG_ID, odu.SD_ID
        from OBJAV_DUPL odu
        where odu.DUPL_OF_AG_ID = new.AG_ID
              and odu.DUPL_OF_SD_ID = new.SD_ID
              and odu.DUPL_OF_OB_ID = new.OB_ID
        into :agid, :sdid
    do
        execute procedure OBJAV_DUPLICATE(:agid, :sdid, new.OB_ID);
end
^

/* Trigger: OBJAV_AU_WORKING_LIST */
CREATE TRIGGER OBJAV_AU_WORKING_LIST FOR OBJAV
ACTIVE AFTER UPDATE POSITION 2
AS
BEGIN
    if (
            new.OB_STATE in (0, 1, 2)
            and new.OB_PARENT is null
            and new.OB_IS_ACTIVE = 1
    ) then
    begin
        delete from OBJAV_WORKING_LIST where AG_ID = new.AG_ID and SD_ID = new.SD_ID and OB_ID = new.OB_ID;
        delete from OBJAV_WORKING_LIST where AG_ID = old.AG_ID and SD_ID = old.SD_ID and OB_ID = old.OB_ID;

        insert into OBJAV_WORKING_LIST  (AG_ID, SD_ID, OB_ID, OB_STATE, FM_ID)
        values (new.AG_ID, new.SD_ID, new.OB_ID, new.OB_STATE, new.FM_ID);
    end
    else begin
        delete from OBJAV_WORKING_LIST  s
        where s.AG_ID = new.AG_ID and s.SD_ID = new.SD_ID and s.OB_ID = new.OB_ID;
    end
END
^

/* Trigger: OBJAV_BD_DELETE_COPIES */
CREATE TRIGGER OBJAV_BD_DELETE_COPIES FOR OBJAV
ACTIVE BEFORE DELETE POSITION 0
AS
declare variable CNT INTEGER;
BEGIN
    IF (OLD.OB_PARENT IS NULL) THEN
    BEGIN
        DELETE FROM OBJAV
        WHERE AG_ID=OLD.AG_ID AND SD_ID=OLD.SD_ID AND OB_PARENT=OLD.OB_ID;
    END
END
^

/* Trigger: OBJAV_BI */
CREATE TRIGGER OBJAV_BI FOR OBJAV
ACTIVE BEFORE INSERT POSITION 0
as
begin
    if (new.OB_ID is null) then
        new.OB_ID = gen_id(G_OB_ID, 1);
        
    if (new.RB_ID is null) then
        new.RB_ID = 1;

    if (new.FM_ID is null) then
        new.FM_ID = 1;
        
    if (new.OB_CHANGED is null) then
        new.OB_CHANGED = CURRENT_TIMESTAMP;
        
    if (new.OB_VAC_COUNT is null) then
        new.OB_VAC_COUNT = 1;
end
^

/* Trigger: OBJAV_BI2_CHECK_PARENT */
CREATE TRIGGER OBJAV_BI2_CHECK_PARENT FOR OBJAV
ACTIVE BEFORE INSERT POSITION 2
AS
declare variable CNT INTEGER;
declare variable ISACTIVE INTEGER;
declare variable FORINTERNET INTEGER;
declare variable OBSTATE INTEGER;
declare variable FMID INTEGER;
declare variable CONTENTID INTEGER;
BEGIN
    IF (NEW.OB_PARENT IS NOT NULL) THEN
    BEGIN
        SELECT COUNT(*) FROM OBJAV
        WHERE AG_ID=NEW.AG_ID AND SD_ID=NEW.SD_ID AND OB_ID=NEW.OB_PARENT
        INTO :CNT;
        IF (CNT<>1) THEN
            EXCEPTION E_NO_PARENT_OBJAV;
        ELSE
        BEGIN
            SELECT
                OB.OB_IS_ACTIVE,
                OB.OB_FOR_INTERNET,
                OB.OB_STATE,
                OB.FM_ID,
                OB.OB_VAC_COUNT,
                OB.OB_HAS_ATTENTION,
                OB.OB_IS_OPTIONAL
            FROM
                OBJAV OB
            WHERE
                OB.AG_ID=NEW.AG_ID AND
                OB.SD_ID=NEW.SD_ID AND
                OB.OB_ID=NEW.OB_PARENT
            INTO
                NEW.OB_IS_ACTIVE,
                NEW.OB_FOR_INTERNET,
                NEW.OB_STATE,
                NEW.FM_ID,
                NEW.OB_VAC_COUNT,
                NEW.OB_HAS_ATTENTION,
                NEW.OB_IS_OPTIONAL;
        END
    END
END
^

/* Trigger: OBJAV_BIU_DISTRICT */
CREATE TRIGGER OBJAV_BIU_DISTRICT FOR OBJAV
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
as
  declare variable gz integer;
begin
  /* Проверка для газеты "Работа в Киеве" -
     должно быть заполнено поле "Район" */

  select s.GZ_ID
  from SDELKA s
  where s.AG_ID = new.AG_ID and s.SD_ID = new.SD_ID
  into :gz;

 if (gz = 2 and new.DISTRICT_ID is null) then
    new.DISTRICT_ID = 1;

-- if (gz = 2 and new.DISTRICT_ID is null) then
--    exception E_DISTRICT_NN;
end
^

/* Trigger: OBJAV_BU_CHECK_PARENT */
CREATE TRIGGER OBJAV_BU_CHECK_PARENT FOR OBJAV
ACTIVE BEFORE UPDATE POSITION 2
AS
declare variable CNT INTEGER;
BEGIN
    IF (NEW.OB_PARENT<>OLD.OB_PARENT AND NEW.OB_PARENT IS NOT NULL) THEN
    BEGIN
        SELECT COUNT(*) FROM OBJAV
        WHERE AG_ID=NEW.AG_ID AND SD_ID=NEW.SD_ID AND OB_ID=NEW.OB_PARENT
        INTO :CNT;

        IF (CNT<>1) THEN
            EXCEPTION E_NO_PARENT_OBJAV;
    END
END
^

/* Trigger: OBJAV_BU_SET_CHANGED */
CREATE TRIGGER OBJAV_BU_SET_CHANGED FOR OBJAV
ACTIVE BEFORE UPDATE POSITION 3
as
begin
    if (   old.OB_STATE     <> new.OB_STATE
        or old.FM_ID        <> new.FM_ID
        or old.RB_ID        <> new.RB_ID
        or old.RS_ID        <> new.RS_ID
        or old.OB_VAC_COUNT <> new.OB_VAC_COUNT
        or old.OB_COMMENT   <> new.OB_COMMENT
        or old.OB_TEXT      <> new.OB_TEXT
        or old.OB_HAS_ATTENTION <> new.OB_HAS_ATTENTION
        or old.OB_IS_OPTIONAL <> new.OB_IS_OPTIONAL
        or old.DISTRICT_ID <> new.DISTRICT_ID)
    then
        new.OB_CHANGED = CURRENT_TIMESTAMP;
end
^

/* Trigger: OBJAV_BU_STATE_AND_ACTIVE */
CREATE TRIGGER OBJAV_BU_STATE_AND_ACTIVE FOR OBJAV
ACTIVE BEFORE UPDATE POSITION 1
as
begin
     if (new.OB_PARENT is null) then
     begin
          if (new.OB_IS_ACTIVE <> old.OB_IS_ACTIVE) then
             update OBJAV ob
             set ob.OB_IS_ACTIVE = new.OB_IS_ACTIVE
             where     ob.AG_ID     = new.AG_ID
                   and ob.SD_ID     = new.SD_ID
                   and ob.OB_PARENT = new.OB_ID;
                   
          if (new.OB_FOR_INTERNET <> old.OB_FOR_INTERNET) then
             update OBJAV ob
             set ob.OB_FOR_INTERNET = new.OB_FOR_INTERNET
             where     ob.AG_ID     = new.AG_ID
                   and ob.SD_ID     = new.SD_ID
                   and ob.OB_PARENT = new.OB_ID;
                   
          if (new.OB_STATE <> old.OB_STATE) then
             update OBJAV ob
             set ob.OB_STATE = new.OB_STATE
             where     ob.AG_ID     = new.AG_ID
                   and ob.SD_ID     = new.SD_ID
                   and ob.OB_PARENT = new.OB_ID;
                   
          if (new.FM_ID <> old.FM_ID) then
             update OBJAV ob
             set ob.FM_ID = new.FM_ID
             where     ob.AG_ID     = new.AG_ID
                   and ob.SD_ID     = new.SD_ID
                   and ob.OB_PARENT = new.OB_ID;
                   
          if (new.OB_VAC_COUNT <> old.OB_VAC_COUNT) then
             update OBJAV ob
             set ob.OB_VAC_COUNT = new.OB_VAC_COUNT
             where     ob.AG_ID     = new.AG_ID
                   and ob.SD_ID     = new.SD_ID
                   and ob.OB_PARENT = new.OB_ID;

          if (new.OB_IS_OPTIONAL <> old.OB_IS_OPTIONAL) then
             update OBJAV ob
             set ob.OB_IS_OPTIONAL = new.OB_IS_OPTIONAL
             where     ob.AG_ID     = new.AG_ID
                   and ob.SD_ID     = new.SD_ID
                   and ob.OB_PARENT = new.OB_ID;

          if (new.DISTRICT_ID <> old.DISTRICT_ID) then
             update OBJAV ob
             set ob.DISTRICT_ID = new.DISTRICT_ID
             where     ob.AG_ID     = new.AG_ID
                   and ob.SD_ID     = new.SD_ID
                   and ob.OB_PARENT = new.OB_ID;
     end
end
^

/* Trigger: OBJAV_CHANGE_LOG_BI */
CREATE TRIGGER OBJAV_CHANGE_LOG_BI FOR OBJAV_CHANGE_LOG
ACTIVE BEFORE INSERT POSITION 0
AS

BEGIN
    new.OL_ID = gen_id(G_OBJAV_CHANGE_LOG, 1);
    new.CHANGE_DATE = CURRENT_TIMESTAMP;

    select s.SD_IS_CHANGED_COPY_OF_SD_ID from sdelka s where s.AG_ID = new.AG_ID and s.SD_ID = new.SD_ID into new.SD_IS_COPY_OF;
END
^

/* Trigger: OBJAV_CONTENT_BIU0 */
CREATE TRIGGER OBJAV_CONTENT_BIU0 FOR OBJAV_CONTENT
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
AS
begin
  if (INSERTING) then
    NEW.CREATE_DATE = CURRENT_TIMESTAMP;

  NEW.MODIFY_DATE = CURRENT_TIMESTAMP;
end
^

/* Trigger: OBJAV_CONTENT_LOAD_LOG_BI */
CREATE TRIGGER OBJAV_CONTENT_LOAD_LOG_BI FOR OBJAV_CONTENT_LOAD_LOG
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.id is null) then
    new.id = gen_id(gen_objav_content_load_log_id,1);
end
^

/* Trigger: OBJAV_DUPL_AD0 */
CREATE TRIGGER OBJAV_DUPL_AD0 FOR OBJAV_DUPL
ACTIVE AFTER DELETE POSITION 0
AS
begin
  delete from OBJAV o
  where o.AG_ID = old.AG_ID
        and o.SD_ID = old.SD_ID
        and o.OB_ID = old.OB_ID;
end
^

/* Trigger: OBJAV_STATE_LOG_BI */
CREATE TRIGGER OBJAV_STATE_LOG_BI FOR OBJAV_STATE_LOG
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
    --IF (NEW.OSL_DAYOFWEEK IS NULL) THEN
    --    NEW.OSL_DAYOFWEEK=F_DAYOFWEEK(CURRENT_DATE);
    IF(NEW.OSL_DAYOFWEEK IS NULL) THEN
         NEW.OSL_DAYOFWEEK = EXTRACT(WEEKDAY FROM CURRENT_TIMESTAMP) + 1;

    IF (NEW.OSL_ID IS NULL) THEN
        NEW.OSL_ID=GEN_ID(G_OSL_ID,1);
END
^

/* Trigger: PAID_SERVICES_BI0 */
CREATE TRIGGER PAID_SERVICES_BI0 FOR PAID_SERVICES
ACTIVE BEFORE INSERT POSITION 0
AS
begin
  /* Trigger text */
  IF (NEW.id IS NULL) THEN
  BEGIN
       SELECT gen_id(gen_paid_services,1) FROM rdb$database INTO NEW.ID;
       new.CREATE_DATE = CURRENT_TIMESTAMP;
  END

  IF((NEW.COMPANY_OKPO IS NULL) OR (NEW.COMPANY_OKPO = '')) THEN NEW.COMPANY_OKPO = '11111111';
end
^

/* Trigger: PAID_SERVICES_BU0 */
CREATE TRIGGER PAID_SERVICES_BU0 FOR PAID_SERVICES
ACTIVE BEFORE UPDATE POSITION 0
AS
begin
  /* Trigger text */
  if ((new.LOADED = 1) and old.LOADED = 0)then new.EDIT_TIME = CURRENT_TIMESTAMP;
end
^

/* Trigger: PODACHA_BI */
CREATE TRIGGER PODACHA_BI FOR PODACHA
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
    if (NEW.PD_ID IS NULL) then
        NEW.PD_ID=gen_id(G_PD_ID,1);
END
^

/* Trigger: PODACHA_BI_CHECK_WRONG_GAZETA */
CREATE TRIGGER PODACHA_BI_CHECK_WRONG_GAZETA FOR PODACHA
ACTIVE BEFORE INSERT POSITION 1
AS
DECLARE VARIABLE GZID INTEGER;
BEGIN
    SELECT GZ_ID FROM SDELKA
    WHERE AG_ID=NEW.AG_ID AND SD_ID=NEW.SD_ID
    INTO :GZID;

    IF (NEW.GZ_ID<>:GZID) THEN
        EXCEPTION E_WRONG_GAZETA;
END
^

/* Trigger: PODACHA_BU_CHECK_WRONG_GAZETA */
CREATE TRIGGER PODACHA_BU_CHECK_WRONG_GAZETA FOR PODACHA
ACTIVE BEFORE UPDATE POSITION 0
AS
DECLARE VARIABLE GZID INTEGER;
BEGIN
    IF (OLD.GZ_ID<>NEW.GZ_ID) THEN
    BEGIN
        SELECT GZ_ID FROM SDELKA
        WHERE AG_ID=NEW.AG_ID AND SD_ID=NEW.SD_ID
        INTO :GZID;

        IF (NEW.GZ_ID<>:GZID) THEN
            EXCEPTION E_WRONG_GAZETA;
    END
END
^

/* Trigger: RESERVE_MAP_BI */
CREATE TRIGGER RESERVE_MAP_BI FOR RESERVE_MAP
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.RM_ID IS NULL) THEN
    NEW.RM_ID = GEN_ID(GEN_RESERVE_MAP_ID,1);
END
^

/* Trigger: RESERVE_RECORD_BI */
CREATE TRIGGER RESERVE_RECORD_BI FOR RESERVE_RECORD
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.RR_ID IS NULL) THEN
    NEW.RR_ID = GEN_ID(GEN_RESERVE_RECORD_ID,1);

  IF ((POSITION('-', NEW.COMMENT) > 0)) THEN
  BEGIN        -- ToDo: automatic change ag_id by sd_num
       SELECT s.SD_ID FROM SDELKA S WHERE s.SD_NUM = TRIM(NEW.COMMENT) INTO NEW.SD_ID;
  END
END
^

/* Trigger: RESERVE_RECORD_BU0 */
CREATE TRIGGER RESERVE_RECORD_BU0 FOR RESERVE_RECORD
ACTIVE BEFORE UPDATE POSITION 0
AS
begin
  /* Trigger text */
  IF ((POSITION('-', NEW.COMMENT) > 0)) THEN
  BEGIN            -- ToDo: automatic change ag_id by sd_num
       SELECT s.SD_ID FROM SDELKA S WHERE s.SD_NUM = TRIM(NEW.COMMENT) INTO NEW.SD_ID;
  END
end
^

/* Trigger: SDELKA_AD_CLEAR_DUPLICATINGS */
CREATE TRIGGER SDELKA_AD_CLEAR_DUPLICATINGS FOR SDELKA
ACTIVE AFTER DELETE POSITION 0
AS
begin
    delete from SDELKA_DUPLICATING d
    where not exists (
        select 1
        from SDELKA s
        where s.AG_ID = d.AG_ID
              and s.SD_ID = d.SD_ID
    );
end
^

/* Trigger: SDELKA_AI_DOLJNIK */
CREATE TRIGGER SDELKA_AI_DOLJNIK FOR SDELKA
ACTIVE AFTER INSERT POSITION 1
AS
BEGIN
    if (
            new.SD_STATE <> 100
        and new.SD_STATE > 4
        and new.SD_ALL_PAYED <> 1
        and new.AS_ID <> 2
    ) then
        insert into NOT_PAYED_SDELKA  (AG_ID, SD_ID, CU_ID)
        values (new.AG_ID, new.SD_ID, new.CU_ID);

END
^

/* Trigger: SDELKA_AI_WORKING_LIST */
CREATE TRIGGER SDELKA_AI_WORKING_LIST FOR SDELKA
ACTIVE AFTER INSERT POSITION 2
AS
BEGIN
    if (
            new.SD_TYPE <> 2
        and new.AS_ID <> 2
        and ( new.SD_STATE <= 4
            or new.AS_ID = 1
        )
    ) then
        insert into SDELKA_WORKING_LIST  (AG_ID, SD_ID, SD_STATE, AS_ID)
        values (new.AG_ID, new.SD_ID, new.SD_STATE, new.AS_ID);
END
^

/* Trigger: SDELKA_AU_DOLJNIK */
CREATE TRIGGER SDELKA_AU_DOLJNIK FOR SDELKA
ACTIVE AFTER UPDATE POSITION 3
AS
    declare variable cnt integer;
BEGIN
    if (
            new.SD_STATE <> 100
        and new.SD_STATE > 4
        and new.SD_ALL_PAYED <> 1
        and new.AS_ID <> 2
    and new.AG_ID = old.AG_ID
  ) then
  begin
      select count(1)
        from NOT_PAYED_SDELKA nps
        where nps.AG_ID = new.AG_ID and nps.SD_ID = new.SD_ID
    into :cnt;
    if (cnt = 0) then
            insert into NOT_PAYED_SDELKA  (AG_ID, SD_ID, CU_ID)
            values (new.AG_ID, new.SD_ID, new.CU_ID);
    else
        update NOT_PAYED_SDELKA nps
      set   nps.AG_ID = new.AG_ID
          , nps.SD_ID = new.SD_ID
        , nps.CU_ID = new.CU_ID
      where     nps.AG_ID = old.AG_ID
            and nps.SD_ID = old.SD_ID;
            end
    else
        delete from NOT_PAYED_SDELKA  nps2
        where nps2.AG_ID = new.AG_ID and nps2.SD_ID = new.SD_ID;
END
^

/* Trigger: SDELKA_AU_WORKING_LIST */
CREATE TRIGGER SDELKA_AU_WORKING_LIST FOR SDELKA
ACTIVE AFTER UPDATE POSITION 4
AS
BEGIN
    if (
            new.SD_TYPE <> 2
        and new.AS_ID <> 2
        and ( new.SD_STATE <= 4
            or new.AS_ID = 1
        )
    ) then
    begin
  delete from SDELKA_WORKING_LIST where AG_ID = old.AG_ID and SD_ID = old.SD_ID;
        delete from SDELKA_WORKING_LIST where AG_ID = new.AG_ID and SD_ID = new.SD_ID;

        insert into SDELKA_WORKING_LIST  (AG_ID, SD_ID, SD_STATE, AS_ID)
        values (new.AG_ID, new.SD_ID, new.SD_STATE, new.AS_ID);
    end
    else
        delete from SDELKA_WORKING_LIST  s
        where s.AG_ID = new.AG_ID and s.SD_ID = new.SD_ID;
END
^

/* Trigger: SDELKA_BD_DELETE_DUPLICATE */
CREATE TRIGGER SDELKA_BD_DELETE_DUPLICATE FOR SDELKA
ACTIVE BEFORE DELETE POSITION 0
AS
begin
    -- Удалим дубликаты сделки
    if (exists (
        select 1
        from SDELKA_DUPL s
        where s.DUPL_OF_AG_ID = old.AG_ID
              and s.DUPL_OF_SD_ID = old.SD_ID)
    ) then
    begin
        execute procedure sdelka_duplicating_start(old.AG_ID, old.SD_ID);

        delete from SDELKA_DUPL d
        where d.DUPL_OF_AG_ID = old.AG_ID
              and d.DUPL_OF_SD_ID = old.SD_ID;

        execute procedure sdelka_duplicating_end(old.AG_ID, old.SD_ID);
    end
end
^

/* Trigger: SDELKA_BI */
CREATE TRIGGER SDELKA_BI FOR SDELKA
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
      if (NEW.AS_ID IS NULL OR NEW.AS_ID=0) then
      BEGIN
          NEW.SD_DATE=CURRENT_TIMESTAMP;
          NEW.SD_PERCENT_GIVEN=0;
          NEW.SD_IS_BEZNAL_V_NAL=0;
      END
      
      IF (NEW.PT_ID=5 AND NEW.SD_STATE<4) THEN
          EXCEPTION E_CANNOT_BE_BEZNAL_V_NAL;

      IF(NEW.registered_by_id IS NULL) THEN NEW.registered_by_id = 463;

      NEW.SD_NEW_CUST = 0;
END
^

/* Trigger: SDELKA_BU */
CREATE TRIGGER SDELKA_BU FOR SDELKA
ACTIVE BEFORE UPDATE POSITION 2
AS
BEGIN
    if (NEW.SD_SKIDKA IS NULL) then
        NEW.SD_SKIDKA=0;

    if (NEW.SD_PERCENT IS NULL) then
        NEW.SD_PERCENT=0;
END
^

/* Trigger: SDELKA_BU0 */
CREATE TRIGGER SDELKA_BU0 FOR SDELKA
ACTIVE BEFORE UPDATE POSITION 1
AS
DECLARE VARIABLE FIRST_ISID INTEGER;
DECLARE VARIABLE CURR_ISID INTEGER;
BEGIN

  IF(NEW.SD_SUM_PAYED IS NULL) THEN NEW.SD_SUM_PAYED = 0;

    /* Из безнала в нал можно перевести только "старую" сделку */
    IF (NEW.PT_ID=5 AND NEW.SD_STATE<4) THEN
      EXCEPTION E_CANNOT_BE_BEZNAL_V_NAL;

    /* Нельзя изменять статус (в т.ч. - подтверждать) сделки, у которых
       есть подачи в уже закрытые номера */
    IF ((OLD.SD_STATE<4 AND NEW.SD_STATE>=2)AND(OLD.SD_STATE<>NEW.SD_STATE)) THEN
    BEGIN
      SELECT MIN(IS_ID) FROM PODACHA PD
        WHERE PD.AG_ID=NEW.AG_ID AND
            PD.SD_ID=NEW.SD_ID AND
            NOT
            (
              (PD.GZ_ID=1 AND PD.IS_ID=0)
              OR
              (PD.GZ_ID=2 AND PD.IS_ID=1)
              OR
              (PD.GZ_ID=3 AND PD.IS_ID=2)
              OR
              (PD.GZ_ID=4 AND PD.IS_ID=3)
              OR
              (PD.GZ_ID=5 AND PD.IS_ID=4)
                        )
                INTO :FIRST_ISID
            ;

        execute procedure get_current_issue(new.GZ_ID)
        returning_values :CURR_ISID;

      IF (FIRST_ISID IS NOT NULL AND FIRST_ISID<CURR_ISID) THEN
                EXCEPTION E_OLD_ISSUE;
        END
END
^

/* Trigger: SDELKA_BU2 */
CREATE TRIGGER SDELKA_BU2 FOR SDELKA
ACTIVE BEFORE UPDATE POSITION 4
AS
/*DECLARE VARIABLE SYNCSTATE INTEGER;*/
BEGIN
/*    SELECT PM_SYNC_STATE
    FROM PARAMS
    INTO :SYNCSTATE;

    IF (SYNCSTATE<>3) THEN
    BEGIN*/
        if (NEW.SD_STATE<>3) then
            NEW.SD_PAY_NOW=0;
        /* Если нужно - проставим дату подтверждения сделки */
        if (OLD.SD_STATE<4 AND NEW.SD_STATE>=4) then
            NEW.SD_APPROVED_DATE=CURRENT_TIMESTAMP;

        /* Наличные сделки считаются оплаченными сразу после утверждения
           их менеджером */
        if (NEW.PT_ID=1 AND OLD.SD_STATE<4 AND NEW.SD_STATE=4) then
        BEGIN
            NEW.SD_ALL_PAYED=1;
            NEW.SD_SUM_PAYED=NEW.SD_SUM;
        END

        /* После оплаты сделки проставим дату оплаты */
        if ((OLD.SD_ALL_PAYED IS NULL or OLD.SD_ALL_PAYED=0)AND(NEW.SD_ALL_PAYED=1)) then
        BEGIN
            NEW.SD_PAY_DATE=CURRENT_TIMESTAMP;
            IF (NEW.SD_SUM_PAYED IS NULL) THEN
                NEW.SD_SUM_PAYED=0;
        END
/*    END*/
END
^

/* Trigger: SDELKA_BU_CHECK_WRONG_GAZETA */
CREATE TRIGGER SDELKA_BU_CHECK_WRONG_GAZETA FOR SDELKA
ACTIVE BEFORE UPDATE POSITION 5
AS
DECLARE VARIABLE CNT INTEGER;
BEGIN
    IF (OLD.GZ_ID<>NEW.GZ_ID) THEN
    BEGIN
        SELECT COUNT(*)
        FROM PODACHA PD
        WHERE PD.AG_ID=NEW.AG_ID AND
              PD.SD_ID=NEW.SD_ID
        INTO :CNT;

        IF (CNT>0) THEN
            EXCEPTION E_WRONG_GAZETA;
    END
END
^

/* Trigger: SDELKA_DELETED_BI */
CREATE TRIGGER SDELKA_DELETED_BI FOR SDELKA_DELETED
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  if (NEW.SD_DELETED_DATE IS NULL) then
    NEW.SD_DELETED_DATE=CURRENT_TIMESTAMP;
END
^

/* Trigger: SDELKA_DUPL_AD0 */
CREATE TRIGGER SDELKA_DUPL_AD0 FOR SDELKA_DUPL
ACTIVE AFTER DELETE POSITION 0
AS
begin
    delete from SDELKA s
    where s.AG_ID = old.AG_ID
          and s.SD_ID = old.SD_ID;
end
^

/* Trigger: SERVICE_AIUD0 */
CREATE TRIGGER SERVICE_AIUD0 FOR SERVICE
ACTIVE AFTER INSERT OR UPDATE OR DELETE POSITION 0
AS
begin
    execute procedure SET_SUM_AND_PERCENT(NEW.AG_ID, NEW.SD_ID);
end
^

/* Trigger: SITE_OBJAV_BI0 */
CREATE TRIGGER SITE_OBJAV_BI0 FOR SITE_OBJAV
ACTIVE BEFORE INSERT POSITION 0
AS
begin
  /* Trigger text */
  IF(NEW.SITE_OBJAV_ID IS NULL) THEN NEW.SITE_OBJAV_ID = GEN_ID(G_SITE_OBJAV, 1);
end
^

/* Trigger: T_AGENT_BI */
CREATE TRIGGER T_AGENT_BI FOR AGENT
ACTIVE BEFORE INSERT POSITION 0
AS
  DECLARE VARIABLE agid INTEGER;
BEGIN
  IF (NEW.AG_ID IS NULL) then
  BEGIN
    EXECUTE PROCEDURE NEXT_AG_ID RETURNING_VALUES :agid;
    NEW.AG_ID=agid;
  END
END
^

/* Trigger: T_CUST_BI */
CREATE TRIGGER T_CUST_BI FOR CUST
ACTIVE BEFORE INSERT POSITION 0
AS
    DECLARE VARIABLE CUID INTEGER;
    DECLARE VARIABLE CUQ_ID integer;
    DECLARE VARIABLE CNT integer;
    DECLARE VARIABLE SYNCSTATE INTEGER;
BEGIN
        IF (NEW.CU_ID IS NULL) then
        BEGIN
            EXECUTE PROCEDURE NEXT_CU_ID RETURNING_VALUES :cuid;
            NEW.CU_ID=cuid;
        END

        IF (NEW.CU_BONUS_ENABLED IS NULL) THEN
            NEW.CU_BONUS_ENABLED=0;

        NEW.EDIT_TIME = CURRENT_TIMESTAMP;
END
^

/* Trigger: T_CUST_BI_SET_CUQ */
CREATE TRIGGER T_CUST_BI_SET_CUQ FOR CUST
ACTIVE BEFORE INSERT POSITION 0
AS
DECLARE VARIABLE CUQ_ID INTEGER;
BEGIN
    IF (NEW.CUQ_REG_ID IS NULL
        AND NEW.CU_OKPO <> '00000000'
        AND NEW.CU_OKPO <> '000000000') THEN
    BEGIN
        CUQ_ID=0;

        SELECT MIN(CUQ_REG_ID)
        FROM CUST_UNIQUE
        WHERE CUQ_OKPO=NEW.CU_OKPO
        INTO :CUQ_ID;

        IF (CUQ_ID<>0) THEN
            NEW.CUQ_REG_ID=:CUQ_ID;
    END
END
^

/* Trigger: T_FORMAT_BI */
CREATE TRIGGER T_FORMAT_BI FOR FORMAT
ACTIVE BEFORE INSERT POSITION 0
AS
  DECLARE VARIABLE fmid INTEGER;
BEGIN
  IF (NEW.FM_ID IS NULL) then
  BEGIN
    EXECUTE PROCEDURE NEXT_FM_ID RETURNING_VALUES :fmid;
    NEW.FM_ID=fmid;
  END
END
^

/* Trigger: T_ISSUE_BI */
CREATE TRIGGER T_ISSUE_BI FOR ISSUE
ACTIVE BEFORE INSERT POSITION 0
AS
  DECLARE VARIABLE isid INTEGER;

BEGIN
  IF (NEW.IS_ID IS NULL) then
  BEGIN
    EXECUTE PROCEDURE NEXT_IS_ID RETURNING_VALUES :isid;
    NEW.IS_ID=isid;
  END
END
^

/* Trigger: T_ISSUE_NAME_COMPOSED_I */
CREATE TRIGGER T_ISSUE_NAME_COMPOSED_I FOR ISSUE
ACTIVE BEFORE INSERT POSITION 0
AS
  declare variable wkday integer;
  declare variable DAYNAME varchar(50);
BEGIN
  --wkday = F_DAYOFWEEK(new.IS_DATE);
  wkday = EXTRACT(WEEKDAY FROM new.IS_DATE) + 1;

  execute procedure dayofweek_name(wkday)
  returning_values :DAYNAME;

  --new.IS_NAME_COMPOSED = DAYNAME || ', ' || new.IS_NAME || '/' || F_YEAR(new.IS_DATE);
  new.IS_NAME_COMPOSED = DAYNAME || ', ' || new.IS_NAME || '/' || EXTRACT(YEAR FROM new.IS_DATE);
END
^

/* Trigger: T_ISSUE_NAME_COMPOSED_U */
CREATE TRIGGER T_ISSUE_NAME_COMPOSED_U FOR ISSUE
ACTIVE BEFORE UPDATE POSITION 0
AS
  declare variable wkday integer;
  declare variable DAYNAME varchar(50);
BEGIN
  --wkday = F_DAYOFWEEK(new.IS_DATE);
  wkday = EXTRACT(WEEKDAY FROM new.IS_DATE) + 1;

  execute procedure dayofweek_name(wkday)
  returning_values :DAYNAME;

  --new.IS_NAME_COMPOSED = DAYNAME || ', ' || new.IS_NAME || '/' || F_YEAR(new.IS_DATE);
  new.IS_NAME_COMPOSED = DAYNAME || ', ' || new.IS_NAME || '/' || EXTRACT(YEAR FROM new.IS_DATE);
END
^

/* Trigger: T_OBJAV_BUI_CHECK_RB_GZ_ID */
CREATE TRIGGER T_OBJAV_BUI_CHECK_RB_GZ_ID FOR OBJAV
ACTIVE BEFORE INSERT OR UPDATE POSITION 0
as
  declare variable gz1 integer;
  declare variable gz2 integer;
begin
  if (new.RB_ID is not null) then
  begin
    select s.GZ_ID
    from SDELKA s
    where s.AG_ID = new.AG_ID and s.SD_ID = new.SD_ID
    into :gz1;

    select r.GZ_ID
    from RUBRIKA r
    where r.RB_ID = new.RB_ID
    into :gz2;

    if (gz1 <> gz2) then
    begin
      exception E_WRONG_RUB_GAZETA;
    end
  end
end
^

/* Trigger: T_RUBRIKA_BI */
CREATE TRIGGER T_RUBRIKA_BI FOR RUBRIKA
ACTIVE BEFORE INSERT POSITION 0
AS
  DECLARE VARIABLE rbid INTEGER;
BEGIN
  IF (NEW.RB_ID IS NULL) then
  BEGIN
    EXECUTE PROCEDURE NEXT_RB_ID RETURNING_VALUES :rbid;
    NEW.RB_ID=rbid;
  END
  --NEW.DEFAULT_MAP = '0,0,0|0,0,0|0,0,0|0,0,0|0,0,0|0,0,0';
END
^

/* Trigger: T_SDELKA_BI */
CREATE TRIGGER T_SDELKA_BI FOR SDELKA
ACTIVE BEFORE INSERT POSITION 0
AS
DECLARE VARIABLE sdid INTEGER;
BEGIN
  IF (NEW.SD_ID IS NULL) then
  BEGIN
    EXECUTE PROCEDURE NEXT_SD_ID(new.ag_id) RETURNING_VALUES :sdid;
    NEW.SD_ID=sdid;
  END
END
^

/* Trigger: T_SDELKA_BI2 */
CREATE TRIGGER T_SDELKA_BI2 FOR SDELKA
ACTIVE BEFORE INSERT POSITION 0
AS
declare variable SUM_DEFAULT FLOAT;
declare variable PERCENT_DEFAULT FLOAT;
DECLARE VARIABLE SYNCSTATE INTEGER;
BEGIN
        if (NEW.SD_SKIDKA IS NULL) then
            NEW.SD_SKIDKA=0;

        if (NEW.SD_PERCENT IS NULL) then
            NEW.SD_PERCENT=0;

        if (NEW.PT_ID IS NULL) then
            NEW.PT_ID=1;
END
^

/* Trigger: T_USR_BI */
CREATE TRIGGER T_USR_BI FOR USR
ACTIVE BEFORE INSERT POSITION 0
AS
  DECLARE VARIABLE usid INTEGER;
BEGIN
  if (NEW.US_ID IS NULL) then
      NEW.US_ID=GEN_ID(G_US_ID,1);
END
^

/* Trigger: USER_LOG_BI */
CREATE TRIGGER USER_LOG_BI FOR USER_LOG
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
  IF (NEW.UL_ID IS NULL) THEN
      NEW.UL_ID = GEN_ID(G_UL_ID, 1);
  if (NEW.UL_TIME IS NULL) then
      NEW.UL_TIME=CURRENT_TIME;
END
^

/* Trigger: USR_BD_LOG */
CREATE TRIGGER USR_BD_LOG FOR USR
ACTIVE BEFORE DELETE POSITION 0
AS
declare variable LOG_OLD VARCHAR(255);
declare variable LOG_NEW VARCHAR(255);
DECLARE VARIABLE SYNCSTATE INTEGER;
BEGIN
    IF(EXISTS(SELECT 1 FROM money_transactions mt WHERE mt.us_id = OLD.us_id)) THEN
    EXCEPTION e_cannot_delete_usr;

    DELETE FROM sdelka_change_log scl WHERE scl.us_id = OLD.us_id;
    DELETE FROM money_transactions mt WHERE mt.us_id = OLD.us_id;

    SELECT PM_SYNC_STATE
    FROM PARAMS
    INTO :SYNCSTATE;
    IF (SYNCSTATE<>3) THEN
    BEGIN
        LOG_OLD=OLD.US_NAME||';'||OLD.US_DISK_ID||';'||OLD.US_TYPE||';'||OLD.US_IS_REMOTE;
        LOG_NEW='';
        INSERT INTO USER_LOG (UL_US_ID,UL_TABLE,UL_CHANGE_TYPE,UL_LOG_OLD,UL_LOG_NEW)
        VALUES (OLD.US_ID,'USR','DELETE',:LOG_OLD,:LOG_NEW);
    END
END
^

/* Trigger: USR_BI_LOG */
CREATE TRIGGER USR_BI_LOG FOR USR
ACTIVE BEFORE INSERT POSITION 1
AS
declare variable LOG_OLD VARCHAR(255);
declare variable LOG_NEW VARCHAR(255);
DECLARE VARIABLE SYNCSTATE INTEGER;
BEGIN
    SELECT PM_SYNC_STATE
    FROM PARAMS
    INTO :SYNCSTATE;
    IF (SYNCSTATE<>3) THEN
    BEGIN
        LOG_OLD='';
        LOG_NEW=NEW.US_NAME||';'||NEW.US_DISK_ID||';'||NEW.US_TYPE||';'||NEW.US_IS_REMOTE;
        INSERT INTO USER_LOG (UL_US_ID,UL_TABLE,UL_CHANGE_TYPE,UL_LOG_OLD,UL_LOG_NEW)
        VALUES (NEW.US_ID,'USR','INSERT',:LOG_OLD,:LOG_NEW);
    END
END
^

/* Trigger: USR_BU_LOG */
CREATE TRIGGER USR_BU_LOG FOR USR
ACTIVE BEFORE UPDATE POSITION 0
AS
declare variable LOG_OLD VARCHAR(255);
declare variable LOG_NEW VARCHAR(255);
DECLARE VARIABLE SYNCSTATE INTEGER;
BEGIN
    SELECT PM_SYNC_STATE
    FROM PARAMS
    INTO :SYNCSTATE;
    IF (SYNCSTATE<>3) THEN
    BEGIN
        LOG_OLD=OLD.US_NAME||';'||OLD.US_DISK_ID||';'||OLD.US_TYPE||';'||OLD.US_IS_REMOTE;
        LOG_NEW=NEW.US_NAME||';'||NEW.US_DISK_ID||';'||NEW.US_TYPE||';'||NEW.US_IS_REMOTE;
        INSERT INTO USER_LOG (UL_US_ID,UL_TABLE,UL_CHANGE_TYPE,UL_LOG_OLD,UL_LOG_NEW)
        VALUES (NEW.US_ID,'USR','EDIT',:LOG_OLD,:LOG_NEW);
    END
END
^

/* Trigger: USR_RIGHTS_BD */
CREATE TRIGGER USR_RIGHTS_BD FOR USR_RIGHTS
ACTIVE BEFORE DELETE POSITION 0
AS
declare variable LOG_OLD VARCHAR(255);
declare variable LOG_NEW VARCHAR(255);
declare variable TMP_S VARCHAR(64);
DECLARE VARIABLE SYNCSTATE INTEGER;
BEGIN

    SELECT PM_SYNC_STATE
    FROM PARAMS
    INTO :SYNCSTATE;

    IF (SYNCSTATE<>3) THEN
    BEGIN
        SELECT US_NAME FROM USR
        WHERE US_ID=OLD.US_ID
        INTO :TMP_S;

        LOG_OLD=TMP_S;

        SELECT AG_NAME FROM AGENT
        WHERE AG_ID=OLD.AG_ID
        INTO :TMP_S;

        LOG_OLD=:LOG_OLD||'->'||TMP_S;

        LOG_NEW='';

        INSERT INTO USER_LOG (UL_US_ID,UL_TABLE,UL_CHANGE_TYPE,UL_LOG_OLD,UL_LOG_NEW)
        VALUES (OLD.US_ID,'USR_RIGHTS','EDIT',:LOG_OLD,:LOG_NEW);
    END
END
^

/* Trigger: USR_RIGHTS_BI */
CREATE TRIGGER USR_RIGHTS_BI FOR USR_RIGHTS
ACTIVE BEFORE INSERT POSITION 0
AS
BEGIN
    IF (NEW.us_id = 294) THEN EXIT;
    EXECUTE PROCEDURE CAN_ADD_USR_RIGHT(NEW.US_ID,NEW.AG_ID);
    IF (NOT EXISTS(SELECT 1 FROM usr_rights ur WHERE ur.us_id = 294 AND ur.ag_id = NEW.ag_id)) THEN
    BEGIN
       INSERT INTO usr_rights(US_ID, AG_ID)
       VALUES(294, NEW.ag_id);
    END
END
^

/* Trigger: USR_RIGHTS_BI_LOG */
CREATE TRIGGER USR_RIGHTS_BI_LOG FOR USR_RIGHTS
ACTIVE BEFORE INSERT POSITION 1
AS
declare variable LOG_OLD VARCHAR(255);
declare variable LOG_NEW VARCHAR(255);
declare variable TMP_S VARCHAR(64);
DECLARE VARIABLE SYNCSTATE INTEGER;
BEGIN
    SELECT PM_SYNC_STATE
    FROM PARAMS
    INTO :SYNCSTATE;

    IF (SYNCSTATE<>3) THEN
    BEGIN
        LOG_OLD='';

        SELECT US_NAME FROM USR
        WHERE US_ID=NEW.US_ID
        INTO :TMP_S;

        LOG_NEW=TMP_S;

        SELECT AG_NAME FROM AGENT
        WHERE AG_ID=NEW.AG_ID
        INTO :TMP_S;

        LOG_NEW=:LOG_NEW||'->'||TMP_S;

        INSERT INTO USER_LOG (UL_US_ID,UL_TABLE,UL_CHANGE_TYPE,UL_LOG_OLD,UL_LOG_NEW)
        VALUES (NEW.US_ID,'USR_RIGHTS','INSERT',:LOG_OLD,:LOG_NEW);
    END
END
^

/* Trigger: USR_RIGHTS_BU */
CREATE TRIGGER USR_RIGHTS_BU FOR USR_RIGHTS
ACTIVE BEFORE UPDATE POSITION 0
AS
BEGIN
    EXECUTE PROCEDURE CAN_ADD_USR_RIGHT(NEW.US_ID,NEW.AG_ID);
END
^

/* Trigger: USR_RIGHTS_BU_LOG */
CREATE TRIGGER USR_RIGHTS_BU_LOG FOR USR_RIGHTS
ACTIVE BEFORE UPDATE POSITION 1
AS
declare variable LOG_OLD VARCHAR(255);
declare variable LOG_NEW VARCHAR(255);
declare variable TMP_S VARCHAR(64);
DECLARE VARIABLE SYNCSTATE INTEGER;
BEGIN

    SELECT PM_SYNC_STATE
    FROM PARAMS
    INTO :SYNCSTATE;

    IF (SYNCSTATE<>3) THEN
    BEGIN
        SELECT US_NAME FROM USR
        WHERE US_ID=OLD.US_ID
        INTO :TMP_S;

        LOG_OLD=TMP_S;

        SELECT AG_NAME FROM AGENT
        WHERE AG_ID=OLD.AG_ID
        INTO :TMP_S;

        LOG_OLD=:LOG_OLD||'->'||TMP_S;

        SELECT US_NAME FROM USR
        WHERE US_ID=NEW.US_ID
        INTO :TMP_S;

        LOG_NEW=TMP_S;

        SELECT AG_NAME FROM AGENT
        WHERE AG_ID=NEW.AG_ID
        INTO :TMP_S;

        LOG_NEW=:LOG_NEW||'->'||TMP_S;

        INSERT INTO USER_LOG (UL_US_ID,UL_TABLE,UL_CHANGE_TYPE,UL_LOG_OLD,UL_LOG_NEW)
        VALUES (NEW.US_ID,'USR_RIGHTS','EDIT',:LOG_OLD,:LOG_NEW);
    END
END
^

SET TERM ; ^



/******************************************************************************/
/***                           Stored Procedures                            ***/
/******************************************************************************/


SET TERM ^ ;

ALTER PROCEDURE A_PODACHAS_ADDED_FIELD_IS_DONE
AS
DECLARE VARIABLE ISID INTEGER;
DECLARE VARIABLE CURRISDATE TIMESTAMP;
BEGIN
    SELECT ISS.IS_DATE
    FROM PARAMS PM
    LEFT JOIN ISSUE ISS
    ON (PM.PM_CURRENT_ISSUE_PR=ISS.IS_ID)
    INTO :CURRISDATE;
    FOR
        SELECT IS_ID
        FROM ISSUE
        WHERE GZ_ID=1 AND IS_DATE<:CURRISDATE AND IS_ID <> 0 AND IS_ID <> 1
        INTO :ISID
    DO
    BEGIN
        UPDATE PODACHA
        SET PD_IS_DONE=1
        WHERE IS_ID=:ISID;
    END
    SELECT ISS.IS_DATE
    FROM PARAMS PM
    LEFT JOIN ISSUE ISS
    ON (PM.PM_CURRENT_ISSUE_NS=ISS.IS_ID)
    INTO :CURRISDATE;
    FOR
        SELECT IS_ID
        FROM ISSUE
        WHERE GZ_ID=2 AND IS_DATE<:CURRISDATE AND IS_ID <> 0 AND IS_ID <> 1
        INTO :ISID
    DO
    BEGIN
        UPDATE PODACHA
        SET PD_IS_DONE=1
        WHERE IS_ID=:ISID;
    END
END^


ALTER PROCEDURE A_SET_OBJAV_SAME_CODE
AS
DECLARE VARIABLE AGID INTEGER;
DECLARE VARIABLE SDID INTEGER;
DECLARE VARIABLE FMID INTEGER;
DECLARE VARIABLE RBID INTEGER;
DECLARE VARIABLE CNTID INTEGER;
DECLARE VARIABLE DBRBID INTEGER;
DECLARE VARIABLE SAMECODE INTEGER;
BEGIN
    FOR
        SELECT
            AG_ID,SD_ID,FM_ID,RB_ID,CONTENT_ID,DOUBLE_RB_ID
        FROM
            OBJAVLENIE OBJ
            LEFT JOIN PODACHA PD
            ON (PD.PD_ID = OBJ.PD_ID)
        WHERE
            SAME_CODE = 0
        GROUP BY
            AG_ID,SD_ID,FM_ID,RB_ID,CONTENT_ID,DOUBLE_RB_ID
        INTO :AGID,:SDID,:FMID,:RBID,CNTID,DBRBID
    DO
    BEGIN
        SAMECODE = GEN_ID(G_OBJAV_SAME_CODE,1);
        UPDATE OBJAVLENIE OB
        SET OB.SAME_CODE = :SAMECODE
        WHERE
            OB.PD_ID IN (
                SELECT P.PD_ID FROM PODACHA P
                WHERE P.AG_ID = :AGID AND P.SD_ID = :SDID
            )
                  AND (OB.CONTENT_ID = :CNTID
                       OR (:CNTID IS NULL
                           AND OB.CONTENT_ID IS NULL
                       )
                  )
                  AND (OB.RB_ID = :RBID
                       OR (:RBID IS NULL
                           AND OB.RB_ID IS NULL
                       )
                  )
                  AND (OB.FM_ID = :FMID
                      OR (:FMID IS NULL
                          AND OB.FM_ID IS NULL
                      )
                  )
                  AND (OB.DOUBLE_RB_ID = :DBRBID
                      OR (:DBRBID IS NULL
                          AND OB.DOUBLE_RB_ID IS NULL
                      )
                  );
    END
END^


ALTER PROCEDURE ADD_AGENT_CHANGING_TASK (
    AG_ID_SRC INTEGER,
    SD_ID_SRC INTEGER,
    AG_ID_DST INTEGER)
AS
BEGIN
    INSERT INTO CHANGE_AGENT_TASK (AG_ID_SRC,SD_ID_SRC,AG_ID_DST)
    VALUES (:AG_ID_SRC,:SD_ID_SRC,:AG_ID_DST);
END^


ALTER PROCEDURE ADD_BONUS (
    AG_ID INTEGER,
    CU_ID INTEGER,
    BT_CHANGE FLOAT,
    BT_COMMENT VARCHAR(128))
AS
declare variable SIGN INTEGER;
BEGIN
    INSERT INTO BONUS_TRANSACTIONS(AG_ID,CU_ID,BT_COMMENT,BT_CHANGE)
    VALUES(:AG_ID,:CU_ID,:BT_COMMENT,:BT_CHANGE);
END^


ALTER PROCEDURE ADD_SUM_FOR_MANAGER (
    M_ADD FLOAT,
    M_COMMENT VARCHAR(128),
    M_TYPE INTEGER,
    M_US_ID INTEGER)
AS
declare variable SIGN INTEGER;
BEGIN
    SELECT TT_SIGN FROM TRANSACTION_TYPE
    WHERE TT_ID=:M_TYPE
    INTO :SIGN;
    
    INSERT INTO MONEY_TRANSACTIONS(US_ID,MT_CHANGE,MT_COMMENT,TT_ID)
    VALUES(:M_US_ID,:M_ADD*:SIGN,:M_COMMENT,:M_TYPE);
END^


ALTER PROCEDURE ADD_TO_OTKAZNIK (
    PH_NUMBER CHAR(12))
AS
declare variable CNT integer;
BEGIN
        SELECT COUNT(*)
            FROM OTKAZNIK
            WHERE OT_NUMBER=:PH_NUMBER
            INTO :cnt
        ;
        if (cnt=0) then
            INSERT INTO OTKAZNIK (OT_NUMBER,AG_ID,OT_IS_STATIC)
                VALUES(:PH_NUMBER,NULL,0)
        ;
        else
            update otkaznik ot
                set ot.ag_id=null
                where ot.ot_number=:ph_number
        ;
END^


ALTER PROCEDURE ADDITIONAL_COUNT_FOR_SDELKA (
    AG_ID_INPUT INTEGER,
    SD_ID_INPUT INTEGER)
RETURNS (
    AG_ID INTEGER,
    SD_ID INTEGER,
    OBJAVS_COUNT INTEGER,
    PODACHA_COUNT INTEGER,
    FREE_PODACHA_COUNT INTEGER,
    ZAPAS_COUNT INTEGER,
    PODACHA_NUMS VARCHAR(128),
    SDELKA_SPACE FLOAT,
    IS_NEW_CUST INTEGER,
    ONE_PODACHA_SPACE FLOAT)
AS
DECLARE VARIABLE NOTHING INTEGER;
DECLARE VARIABLE MAX_FM_SPACE FLOAT;
DECLARE VARIABLE CUID INTEGER;
DECLARE VARIABLE PHCNT INTEGER;
DECLARE VARIABLE PTID INTEGER;
DECLARE VARIABLE PT_SPACE_COEFF FLOAT;
BEGIN
    AG_ID=AG_ID_INPUT;
    SD_ID=SD_ID_INPUT;
    
    SELECT COUNT(*)
    FROM OBJAV OB
    WHERE OB.AG_ID=:AG_ID AND OB.SD_ID=:SD_ID_INPUT
    INTO :OBJAVS_COUNT;

    SELECT COUNT(*)
        FROM PODACHA PD
        WHERE PD.AG_ID=:AG_ID_INPUT AND PD.SD_ID=:SD_ID_INPUT
        INTO :PODACHA_COUNT
    ;

    SELECT SD.CU_ID,SD.PT_ID
        FROM SDELKA SD
        WHERE SD.AG_ID=:AG_ID AND
              SD.SD_ID=:SD_ID
        INTO :CUID,:PTID
    ;
    
    SELECT MAX(FM_SPACE)
        FROM OBJAV OB
        LEFT JOIN FORMAT FM
        ON (OB.FM_ID=FM.FM_ID)
        WHERE OB.AG_ID=:AG_ID_INPUT AND
              OB.SD_ID=:SD_ID_INPUT
        INTO :MAX_FM_SPACE
    ;

    SELECT PT.PT_SPACE_COEFF
        FROM PAY_TYPE PT
        WHERE PT.PT_ID=:PTID
        INTO :PT_SPACE_COEFF
    ;

    ONE_PODACHA_SPACE=MAX_FM_SPACE*PT_SPACE_COEFF;
    
    IF (ONE_PODACHA_SPACE IS NULL) THEN
       ONE_PODACHA_SPACE=0;
        
    SDELKA_SPACE=ONE_PODACHA_SPACE*PODACHA_COUNT;
    
    EXECUTE PROCEDURE SDELKA_PODACHA_NUMS(:AG_ID_INPUT,:SD_ID_INPUT)
    RETURNING_VALUES :NOTHING,:PODACHA_NUMS;
    
    SELECT COUNT(*)
    FROM PODACHA PD
    WHERE PD.AG_ID=:AG_ID AND PD.SD_ID=:SD_ID_INPUT
    AND PD.PD_FREE_OF_CHARGE=1
    INTO :FREE_PODACHA_COUNT;
    
    SELECT COUNT(*)
    FROM PODACHA PD
    WHERE PD.AG_ID=:AG_ID AND PD.SD_ID=:SD_ID_INPUT
    AND (PD.IS_ID=0 OR PD.IS_ID=1)
    INTO ZAPAS_COUNT;

    SELECT COUNT(*)
        FROM CUST_PHONE CP
        WHERE CP.AG_ID=:AG_ID AND
              CP.CU_ID=:CUID AND
              EXISTS (SELECT * FROM OTKAZNIK OT
                        WHERE OT.AG_ID<>CP.AG_ID AND
                              OT.OT_NUMBER=CP.CP_NUMBER
                     )
            INTO :PHCNT
    ;

    
    IF (PHCNT=0) THEN
    BEGIN
        SELECT COUNT(*)
            FROM PHONE PH
            WHERE PH.AG_ID=:AG_ID AND
                  PH.SD_ID=:SD_ID AND
                EXISTS (SELECT * FROM OTKAZNIK OT
                            WHERE OT.AG_ID<>PH.AG_ID AND
                                  OT.OT_NUMBER=PH.PH_NUMBER
                       )
            INTO :PHCNT
        ;
    END
    
    IF (PHCNT>0) THEN
        IS_NEW_CUST=0;
    ELSE
        IS_NEW_CUST=1;
    
  SUSPEND;
END^


ALTER PROCEDURE ADM_ADD_PODACHA (
    PARAM_SD_NUM VARCHAR(128),
    PARAM_IS_ID INTEGER,
    PARAM_PD_FREE_OF_CHARGE INTEGER,
    PARAM_US_ID INTEGER,
    PARAM_IP CHAR(15))
RETURNS (
    RESULT CHAR(128))
AS
declare variable GZID integer;
declare variable LOGPARAMS varchar(255);
declare variable TOOL_ID integer;
declare variable PARAM_AG_ID integer;
declare variable PARAM_SD_ID integer;
declare variable CUR_IS_ID integer;
BEGIN
    TOOL_ID=4;
    RESULT='Сделка не найдена.';

    FOR SELECT  ag_id, sd_id, gz_id FROM SDELKA
    WHERE sd_num = :param_sd_num
    INTO  :param_ag_id, :param_sd_id, :GZID DO
    BEGIN

            select i.IS_ID from GET_CURRENT_ISSUE(:GZID) i into :CUR_IS_ID;

            IF ((:PARAM_IS_ID < :CUR_IS_ID) AND NOT :PARAM_IS_ID IN(0,1,2,3,4)) THEN
            BEGIN
                EXCEPTION E_OLD_ISSUE;
            END

            IF ((param_ag_id IS NOT NULL) AND (param_sd_id IS NOT NULL)) THEN
            BEGIN
                EXECUTE PROCEDURE PODACHA_INSERT(:PARAM_AG_ID, :PARAM_SD_ID, :GZID, :PARAM_IS_ID, :PARAM_PD_FREE_OF_CHARGE);
            
                RESULT='Подача добавлена.';
                LOGPARAMS=:PARAM_SD_NUM||';'||:PARAM_IS_ID||';'||:PARAM_PD_FREE_OF_CHARGE;
                
                INSERT INTO ADMIN_LOG(AT_ID,AL_PARAMS,US_ID,AL_IP)
                VALUES(:TOOL_ID,:LOGPARAMS,:PARAM_US_ID,:PARAM_IP);
            END
    END

    suspend;
END^


ALTER PROCEDURE ADM_CHANGE_FACT_NUM_AND_DATE (
    PARAM_SD_NUM VARCHAR(128),
    PARAM_SD_FACT_NUM INTEGER,
    PARAM_SD_FACT_DATE TIMESTAMP,
    PARAM_US_ID INTEGER,
    PARAM_IP CHAR(15))
RETURNS (
    RESULT CHAR(128))
AS
declare variable LOGPARAMS varchar(255);
declare variable TOOL_ID integer;
BEGIN
    TOOL_ID=6;
    RESULT='Сделка не найдена.';

    IF(EXISTS(SELECT 1 FROM sdelka s WHERE s.SD_NUM = :PARAM_SD_NUM)) THEN
    BEGIN
        UPDATE SDELKA
        SET SD_FACT_NUM=:PARAM_SD_FACT_NUM,
            SD_FACT_DATE=CAST(:PARAM_SD_FACT_DATE AS DATE)
        WHERE sd_num = :param_sd_num;
        
        RESULT='Номер и дата счета изменены.';
        LOGPARAMS=:param_sd_num||';'||:PARAM_SD_FACT_NUM||';'||:PARAM_SD_FACT_DATE;
        INSERT INTO ADMIN_LOG(AT_ID,AL_PARAMS,US_ID,AL_IP)
        VALUES(:TOOL_ID,:LOGPARAMS,:PARAM_US_ID,:PARAM_IP);
    END
    suspend;
END^


ALTER PROCEDURE ADM_CHANGE_PAY_DATE (
    PARAM_SD_NUM VARCHAR(128),
    PARAM_PAY_DATE TIMESTAMP,
    PARAM_USR_ID INTEGER,
    PARAM_IP CHAR(15))
RETURNS (
    RESULT CHAR(128))
AS
declare variable TOOL_ID integer;
declare variable LOGPARAMS varchar(255);
begin
  /* Procedure Text */
  TOOL_ID = 12;
  RESULT='Сделка не найдена.';

  IF(EXISTS(SELECT 1 FROM sdelka s WHERE s.SD_NUM = :PARAM_SD_NUM)) THEN
  BEGIN
        UPDATE sdelka s
        SET s.SD_PAY_DATE = :PARAM_PAY_DATE
        WHERE s.SD_NUM = :PARAM_SD_NUM;

        RESULT = 'Дата оплаты сделки изменена.';
        LOGPARAMS = :PARAM_SD_NUM||';'||PARAM_PAY_DATE;

        INSERT INTO ADMIN_LOG(AT_ID,AL_PARAMS,US_ID,AL_IP)
        VALUES(:TOOL_ID, :LOGPARAMS, :PARAM_USR_ID, :PARAM_IP);
  END
  suspend;
end^


ALTER PROCEDURE ADM_CHANGE_REQ (
    PARAM_SD_NUM VARCHAR(128),
    PARAM_NEW_RQ INTEGER,
    PARAM_IP CHAR(15),
    PARAM_US_ID INTEGER)
RETURNS (
    RESULT CHAR(128))
AS
declare variable TOOL_ID integer;
declare variable LOGPARAMS varchar(255);
begin
  /* Procedure Text */
  TOOL_ID = 11;
  RESULT = 'Сделка не найдена.';

  IF (EXISTS(SELECT 1 FROM sdelka s WHERE s.SD_NUM = :PARAM_SD_NUM)) THEN
  BEGIN
      UPDATE sdelka s
      SET s.RQ_ID = :PARAM_NEW_RQ
      WHERE s.SD_NUM = :PARAM_SD_NUM;

      RESULT='Реквизиты изменены.';
      LOGPARAMS = :PARAM_SD_NUM||';'||:PARAM_NEW_RQ;

      INSERT INTO ADMIN_LOG(AT_ID,AL_PARAMS,US_ID,AL_IP)
      VALUES(:TOOL_ID,:LOGPARAMS,:PARAM_US_ID,:PARAM_IP);
  END
  suspend;
end^


ALTER PROCEDURE ADM_CHANGE_SDELKA_PERCENT (
    PARAM_SD_NUM VARCHAR(128),
    PARAM_SD_PERCENT FLOAT,
    PARAM_US_ID INTEGER,
    PARAM_IP CHAR(15))
RETURNS (
    RESULT CHAR(128),
    SD_DATE TIMESTAMP)
AS
declare variable LOGPARAMS varchar(255);
declare variable TOOL_ID integer;
declare variable PARAM_AG_ID integer;
declare variable PARAM_SD_ID integer;
BEGIN
    TOOL_ID=3;
    
    SELECT FIRST 1 MAX(sd_date), ag_id, sd_id FROM SDELKA
    WHERE sd_num = :param_sd_num
    GROUP BY 2,3
    ORDER BY 1
    INTO :sd_date, :param_ag_id, :param_sd_id;
    
    RESULT='Сделка не найдена.';
    
    IF ((param_ag_id IS NOT NULL) AND (param_sd_id IS NOT NULL)) THEN
    BEGIN
        UPDATE SDELKA
        SET SD_PERCENT=:PARAM_SD_PERCENT
        WHERE AG_ID=:PARAM_AG_ID AND SD_ID=:PARAM_SD_ID;
        
        RESULT='Процент изменен.';
        LOGPARAMS=:PARAM_AG_ID||'-'||:PARAM_SD_ID||';'||:PARAM_SD_PERCENT;
        INSERT INTO ADMIN_LOG(AT_ID,AL_PARAMS,US_ID,AL_IP)
        VALUES(:TOOL_ID,:LOGPARAMS,:PARAM_US_ID,:PARAM_IP);
    END
    ELSE BEGIN
       EXCEPTION e_sd_not_found;
    END
    suspend;
END^


ALTER PROCEDURE ADM_CHANGE_SDELKA_SUM (
    PARAM_SD_NUM VARCHAR(128),
    PARAM_SD_SUM FLOAT,
    PARAM_US_ID INTEGER,
    PARAM_IP CHAR(15))
RETURNS (
    RESULT CHAR(128))
AS
declare variable LOGPARAMS varchar(255);
declare variable TOOL_ID integer;
BEGIN
    TOOL_ID=1;
    RESULT='Сделка не найдена.';

    IF(EXISTS(SELECT 1 FROM sdelka s WHERE s.SD_NUM = :PARAM_SD_NUM)) THEN
    BEGIN
        UPDATE SDELKA
        SET SD_SUM=:PARAM_SD_SUM
        WHERE sd_num = :param_sd_num;
        
        RESULT='Сумма сделки изменена.';
        LOGPARAMS=:param_sd_num||';'||:PARAM_SD_SUM;
        
        INSERT INTO ADMIN_LOG(AT_ID,AL_PARAMS,US_ID,AL_IP)
        VALUES(:TOOL_ID,:LOGPARAMS,:PARAM_US_ID,:PARAM_IP);
    END
    suspend;
END^


ALTER PROCEDURE ADM_DELETE_PODACHA (
    PARAM_SD_NUM VARCHAR(128),
    PARAM_IS_ID INTEGER,
    PARAM_US_ID INTEGER,
    PARAM_IP CHAR(15))
RETURNS (
    RESULT CHAR(128))
AS
declare variable PDCNT integer;
declare variable LOGPARAMS varchar(255);
declare variable TOOL_ID integer;
declare variable PARAM_AG_ID integer;
declare variable PARAM_SD_ID integer;
BEGIN
    TOOL_ID=5;
    RESULT='Подачи не найдены.';

    FOR SELECT ag_id, sd_id FROM SDELKA
        WHERE sd_num = :param_sd_num
        INTO :param_ag_id, :param_sd_id DO
    BEGIN
        IF ((param_ag_id IS NOT NULL) AND (param_sd_id IS NOT NULL)) THEN
        BEGIN
            SELECT MIN(PD_ID) FROM PODACHA
            WHERE AG_ID=:PARAM_AG_ID AND SD_ID=:PARAM_SD_ID AND IS_ID=:PARAM_IS_ID
            INTO :PDCNT;
    
            DELETE FROM PODACHA
            WHERE AG_ID=:PARAM_AG_ID AND SD_ID=:PARAM_SD_ID AND PD_ID=:PDCNT;
            
            RESULT='Подача удалена.';
            LOGPARAMS=:PARAM_SD_NUM||';'||:PARAM_IS_ID;
            
            INSERT INTO ADMIN_LOG(AT_ID,AL_PARAMS,US_ID,AL_IP)
            VALUES(:TOOL_ID,:LOGPARAMS,:PARAM_US_ID,:PARAM_IP);
        END
    END
    suspend;
END^


ALTER PROCEDURE ADM_DELETE_SDELKA (
    PARAM_SD_NUM VARCHAR(128),
    PARAM_US_ID INTEGER,
    PARAM_IP CHAR(15))
RETURNS (
    RESULT CHAR(128))
AS
declare variable LOGPARAMS varchar(255);
declare variable TOOL_ID integer;
declare variable comment varchar(128);
declare variable PARAM_AG_ID integer;
declare variable PARAM_SD_ID integer;
BEGIN
    TOOL_ID=2;
    RESULT='Сделка не найдена.';

    FOR SELECT ag_id, sd_id FROM SDELKA
    WHERE sd_num = :param_sd_num
    INTO :param_ag_id, :param_sd_id DO
    BEGIN
        IF ((param_ag_id IS NOT NULL) AND (param_sd_id IS NOT NULL)) THEN
        BEGIN
           -- EXECUTE PROCEDURE sdelka_was_deleted_log(PARAM_US_ID, PARAM_AG_ID,PARAM_SD_ID, param_ip);
    
            COMMENT='Удаление сделки: '||:PARAM_SD_NUM||';'||' US='||:PARAM_US_ID||' HOST='||:PARAM_IP;
            EXECUTE PROCEDURE DELETE_SDELKA(PARAM_AG_ID,PARAM_SD_ID,:COMMENT);
    
    /*
            DELETE FROM SDELKA
            WHERE AG_ID=:PARAM_AG_ID AND SD_ID=:PARAM_SD_ID;
    */
            RESULT='Сделка удалена...';
            LOGPARAMS=:PARAM_SD_NUM;
            INSERT INTO ADMIN_LOG(AT_ID,AL_PARAMS,US_ID,AL_IP)
            VALUES(:TOOL_ID,:LOGPARAMS,:PARAM_US_ID,:PARAM_IP);
        END
    END
    suspend;
END^


ALTER PROCEDURE ADM_MOVE_NEW_SDELKAS (
    PARAM_US_ID INTEGER,
    PARAM_IP CHAR(15),
    PARAM_SD_NUM_OLD VARCHAR(64),
    PARAM_AG_NEW INTEGER)
RETURNS (
    RESULT CHAR(128))
AS
declare variable AG_ID_FROM integer;
declare variable SD_ID_FROM integer;
declare variable TOOL_ID integer;
declare variable LOGPARAMS varchar(128);
declare variable SD_NUM_NEW varchar(64);
declare variable SD_ID_TO integer;
BEGIN
    TOOL_ID = 10;
    RESULT = 'Ошибка';

    IF (PARAM_SD_NUM_OLD = '') THEN
    BEGIN
        SUSPEND;
        EXIT;
    END

    SELECT s.AG_ID, s.SD_ID
    FROM sdelka s
    WHERE s.SD_NUM = :PARAM_SD_NUM_OLD
    INTO :AG_ID_FROM, :SD_ID_FROM;

    SELECT cas.SDID_NEW
    FROM CHANGE_AGENT_FOR_SDELKA(:ag_id_from, :sd_id_from, :PARAM_AG_NEW) cas
    INTO :SD_ID_TO;

    SELECT s.SD_NUM
    FROM sdelka s
    WHERE s.AG_ID = :PARAM_AG_NEW
    AND s.SD_ID = :SD_ID_TO
    INTO :SD_NUM_NEW;

    RESULT = 'Сделка передана успешно.';
    LOGPARAMS = PARAM_SD_NUM_OLD || ';' || SD_NUM_NEW;
    INSERT INTO ADMIN_LOG(AT_ID, AL_PARAMS, US_ID, AL_IP)
    VALUES(:TOOL_ID, :LOGPARAMS, :PARAM_US_ID, :PARAM_IP);

    SUSPEND;
END^


ALTER PROCEDURE ADM_ROLLBACK_ISSUE_ST
AS
declare variable old_is integer;
begin
  select i.IS_ID
  from ISSUE i
  where i.GZ_ID = 3 and i.IS_DATE = (
    select max(i2.IS_DATE)
    from ISSUE i2
    where i2.GZ_ID = 3 and i2.IS_DATE < (
      select i3.IS_DATE
      from ISSUE i3
      where i3.IS_ID = (
        select p.PM_CURRENT_ISSUE_SR
        from PARAMS p
      )
    )
  )
  into :old_is;

  update PARAMS pm
  set pm.PM_CURRENT_ISSUE_SR = :old_is;

  update PODACHA
  set PD_IS_DONE = 0
  where GZ_ID = 3 and IS_ID = :old_is;

end^


ALTER PROCEDURE ADM_SDELKA_APPROVING_DATE_NEW (
    PARAM_SD_NUM VARCHAR(128))
RETURNS (
    RESULT TIMESTAMP)
AS
BEGIN
   SELECT SD_APPROVED_DATE FROM SDELKA
   WHERE sd_num = :param_sd_num AND
         sd_date BETWEEN '01.01.2010' AND CURRENT_DATE
   INTO :result;
   suspend;
END^


ALTER PROCEDURE ADM_SDELKA_PAY_DATE_NEW (
    PARAM_SD_NUM VARCHAR(128))
RETURNS (
    RESULT TIMESTAMP)
AS
BEGIN
   SELECT SD_PAY_DATE FROM SDELKA
   WHERE sd_num = :param_sd_num AND
         sd_date BETWEEN '01.01.2010' AND CURRENT_DATE
   INTO :result;
   suspend;
END^


ALTER PROCEDURE ADM_SDELKA_PAY_INFO (
    PARAM_SD_NUM VARCHAR(128))
RETURNS (
    PAY_SUM DOUBLE PRECISION,
    PAY_DATE TIMESTAMP,
    USR VARCHAR(255))
AS
begin
  /* Procedure Text */
  FOR SELECT sph.pay_sum, sph.pay_date, u.us_name
      FROM sdelka_pay_history sph
      JOIN usr u ON(u.us_id = sph.us_id)
      JOIN sdelka s ON (s.ag_id = sph.ag_id AND s.sd_id = sph.sd_id)
      WHERE s.sd_num = :PARAM_SD_NUM
      INTO :pay_sum, :pay_date, :usr DO
  BEGIN
       SUSPEND;
  END
end^


ALTER PROCEDURE APPROVE_SDELKA (
    AG_ID INTEGER,
    SD_ID INTEGER,
    US_ID INTEGER)
AS
declare variable PREV_SD_ID integer;
declare variable SD_TYPE integer;
declare variable SD_STATE integer;
declare variable RQ_ID integer;
declare variable CU_ID integer;
declare variable SD_COMMENT varchar(1024);
declare variable SD_SUM float;
declare variable SD_PERCENT float;
declare variable SD_SUM_DEFAULT float;
declare variable SD_PERCENT_DEFAULT float;
declare variable SD_SKIDKA float;
declare variable PT_ID integer;
declare variable SD_SETTING_SUM_AND_PERCENT integer;
declare variable GZ_ID integer;
declare variable SD_SUM_PAYED float;
declare variable SD_ALL_PAYED integer;
declare variable SD_COMMENT_SHORT varchar(128);
declare variable SD_FACT_NUM integer;
declare variable SD_KA_START_DATE timestamp;
declare variable SD_KA_END_DATE timestamp;
declare variable SD_FACT_DATE timestamp;
declare variable SD_NEW_CUST integer;
declare variable SD_IS_BEZNAL_V_NAL integer;
declare variable SD_PAY_DATE timestamp;
declare variable SD_APPROVED_DATE timestamp;
declare variable SD_DATE timestamp;
declare variable SD_PERCENT_GIVEN smallint;
declare variable SD_SHOW_CUST_ID smallint;
declare variable SD_IS_IMPORTANT_FOR_SITE smallint;
declare variable REGISTERED_BY_ID integer;
declare variable SRC_AG_ID integer;
declare variable SRC_SD_ID integer;
BEGIN
/* узнаем номер сделки, копию которой подтверждаем */
    SELECT S.SD_IS_CHANGED_COPY_OF_SD_ID FROM SDELKA S
        WHERE
            S.AG_ID=:AG_ID AND
            S.SD_ID=:SD_ID
        INTO :PREV_SD_ID
    ;

    -- Проверим, не подтверждается ли сделка-дубликат
    src_ag_id = 0;
    src_sd_id = 0;
    if (exists (
        select 1
        from SDELKA_DUPL d
        where d.AG_ID = :AG_ID
              and d.SD_ID = :PREV_SD_ID)
    ) then
    begin
        select d.DUPL_OF_AG_ID, d.DUPL_OF_SD_ID
        from SDELKA_DUPL d
        where d.AG_ID = :AG_ID
              and d.SD_ID = :PREV_SD_ID
        into :src_ag_id, :src_sd_id;

        execute procedure sdelka_duplicating_start(:src_ag_id, :src_sd_id);
    end

/* выбираем в переменные всю интересующую нас информацию из сделки */
    SELECT
        S.SD_TYPE,
        S.SD_STATE,
        S.RQ_ID,
        S.CU_ID,
        S.SD_COMMENT,
        S.SD_SUM,
        S.SD_PERCENT,
        S.SD_SUM_DEFAULT,
        S.SD_PERCENT_DEFAULT,
        S.SD_SKIDKA,
        S.PT_ID,
        S.SD_SETTING_SUM_AND_PERCENT,
        S.GZ_ID,
        S.SD_SUM_PAYED,
        S.SD_ALL_PAYED,
        S.SD_COMMENT_SHORT,
        S.SD_FACT_NUM,
        S.SD_KA_START_DATE,
        S.SD_KA_END_DATE,
        S.SD_FACT_DATE,
        S.SD_NEW_CUST,
        S.SD_IS_BEZNAL_V_NAL,
        S.SD_PAY_DATE,
        S.SD_APPROVED_DATE,
        S.SD_DATE,
        S.SD_PERCENT_GIVEN,
        S.SD_SHOW_CUST_ID,
        S.SD_IS_IMPORTANT_FOR_SITE,
        S.REGISTERED_BY_ID
        FROM SDELKA S
        WHERE
            S.AG_ID=:AG_ID AND
            S.SD_ID=:SD_ID
        INTO
            :SD_TYPE,
            :SD_STATE,
            :RQ_ID,
            :CU_ID,
            :SD_COMMENT,
            :SD_SUM,
            :SD_PERCENT,
            :SD_SUM_DEFAULT,
            :SD_PERCENT_DEFAULT,
            :SD_SKIDKA,
            :PT_ID,
            :SD_SETTING_SUM_AND_PERCENT,
            :GZ_ID,
            :SD_SUM_PAYED,
            :SD_ALL_PAYED,
            :SD_COMMENT_SHORT,
            :SD_FACT_NUM,
            :SD_KA_START_DATE,
            :SD_KA_END_DATE,
            :SD_FACT_DATE,
            :SD_NEW_CUST,
            :SD_IS_BEZNAL_V_NAL,
            :SD_PAY_DATE,
            :SD_APPROVED_DATE,
            :SD_DATE,
            :SD_PERCENT_GIVEN,
            :SD_SHOW_CUST_ID,
            :SD_IS_IMPORTANT_FOR_SITE,
            :REGISTERED_BY_ID
    ;
/* теперь обновляем исходную сделку этой информацией */
    UPDATE SDELKA S
        SET
            S.SD_TYPE=:SD_TYPE,
            S.SD_STATE=:SD_STATE,
            S.RQ_ID=:RQ_ID,
            S.CU_ID=:CU_ID,
            S.AS_ID=0,
            S.SD_COMMENT=:SD_COMMENT,
            S.SD_SUM=:SD_SUM,
            S.SD_PERCENT=:SD_PERCENT,
            S.SD_SUM_DEFAULT=:SD_SUM_DEFAULT,
            S.SD_PERCENT_DEFAULT=:SD_PERCENT_DEFAULT,
            S.SD_SKIDKA=:SD_SKIDKA,
            S.PT_ID=:PT_ID,
            S.SD_SETTING_SUM_AND_PERCENT=:SD_SETTING_SUM_AND_PERCENT,
            S.GZ_ID=:GZ_ID,
            S.SD_SUM_PAYED=:SD_SUM_PAYED,
            S.SD_ALL_PAYED=:SD_ALL_PAYED,
            S.SD_COMMENT_SHORT=:SD_COMMENT_SHORT,
            S.SD_FACT_NUM=:SD_FACT_NUM,
            S.SD_KA_START_DATE=:SD_KA_START_DATE,
            S.SD_KA_END_DATE=:SD_KA_END_DATE,
            S.SD_FACT_DATE=:SD_FACT_DATE,
            S.SD_NEW_CUST=:SD_NEW_CUST,
            S.SD_IS_BEZNAL_V_NAL=:SD_IS_BEZNAL_V_NAL,
            S.SD_PAY_DATE=:SD_PAY_DATE,
            S.SD_APPROVED_DATE=:SD_APPROVED_DATE,
            S.SD_DATE=:SD_DATE,
            S.SD_PERCENT_GIVEN=:SD_PERCENT_GIVEN,
            S.SD_SHOW_CUST_ID=:SD_SHOW_CUST_ID,
            S.SD_IS_IMPORTANT_FOR_SITE=:SD_IS_IMPORTANT_FOR_SITE,
            S.REGISTERED_BY_ID=:REGISTERED_BY_ID
        WHERE
            S.AG_ID=:AG_ID AND
            S.SD_ID=:PREV_SD_ID
    ;
/* удаляем старые дубли */
    DELETE FROM OBJAV OB
        WHERE
            OB.AG_ID=:AG_ID AND
            OB.SD_ID=:PREV_SD_ID
    ;
/* у "новых" объявлений меняем код сделки */
    UPDATE OBJAV OB
        SET
            OB.SD_ID=:PREV_SD_ID
        WHERE
            OB.AG_ID=:AG_ID AND
            OB.SD_ID=:SD_ID
    ;
/* удаляем старые подачи */
    DELETE FROM PODACHA P
        WHERE
            P.AG_ID=:AG_ID AND
            P.SD_ID=:PREV_SD_ID
    ;
/* у "новых" подач меняем номер сделки */
    UPDATE PODACHA P
        SET
            P.SD_ID=:PREV_SD_ID
        WHERE
            P.AG_ID=:AG_ID AND
            P.SD_ID=:SD_ID
    ;

/* удаляем старые услуги */
    DELETE FROM SERVICE P
        WHERE
            P.AG_ID=:AG_ID AND
            P.SD_ID=:PREV_SD_ID
    ;
/* у "новых" услуг меняем номер сделки */
    UPDATE SERVICE P
        SET
            P.SD_ID=:PREV_SD_ID
        WHERE
            P.AG_ID=:AG_ID AND
            P.SD_ID=:SD_ID
    ;

/* удаляем уже ненужные телефоны */
    DELETE FROM PHONE P
        WHERE
            P.AG_ID=:AG_ID AND
            P.SD_ID=:PREV_SD_ID
    ;
    UPDATE PHONE P
        SET
            P.SD_ID=:PREV_SD_ID
        WHERE
            P.AG_ID=:AG_ID AND
            P.SD_ID=:SD_ID
    ;
/* удаляем уже ненужную изменённую копию */
    DELETE FROM SDELKA S
        WHERE
            S.AG_ID=:AG_ID AND
            S.SD_ID=:SD_ID
    ;

    execute procedure LOG_SDELKA_CHANGES(:AG_ID, :PREV_SD_ID, :US_ID);

    -- Если изменялась сделка-дубликат, запретим снова ее изменение
    if (src_ag_id > 0) then
        execute procedure sdelka_duplicating_end(:src_ag_id, :src_sd_id);

     execute procedure EVENT_CHANGE(1);
     execute procedure EVENT_CHANGE(2);
END^


ALTER PROCEDURE BACKUP_SDELKA (
    AG_ID INTEGER,
    SD_ID INTEGER,
    US_ID INTEGER)
RETURNS (
    NEW_SD_ID INTEGER)
AS
declare variable OBID integer;
declare variable NEWOBID integer;
declare variable PDID integer;
declare variable NEW_PDID integer;
BEGIN
    NEW_SD_ID=gen_id(G_SD_ID,1);

/* копируем сделку */
    INSERT INTO SDELKA
        (
        AG_ID
        ,SD_ID
        ,SD_TYPE
        ,SD_STATE
        ,RQ_ID
        ,CU_ID
        ,AS_ID
        ,SD_COMMENT
        ,SD_SUM
        ,SD_PERCENT
        ,SD_SUM_DEFAULT
        ,SD_PERCENT_DEFAULT
        ,SD_SKIDKA
        ,PT_ID
        ,SD_SETTING_SUM_AND_PERCENT
        ,GZ_ID
        ,SD_SUM_PAYED
        ,SD_ALL_PAYED
        ,SD_COMMENT_SHORT
        ,SD_FACT_NUM
        ,SD_IS_CHANGED_COPY_OF_SD_ID
        ,SD_KA_START_DATE
        ,SD_KA_END_DATE
        ,SD_FACT_DATE
        ,SD_NEW_CUST
        ,SD_IS_BEZNAL_V_NAL
        ,SD_PAY_DATE
        ,SD_APPROVED_DATE
        ,SD_DATE
        ,SD_PERCENT_GIVEN
        ,SD_SHOW_CUST_ID
        ,SD_IS_IMPORTANT_FOR_SITE
        ,REGISTERED_BY_ID
        )
        SELECT
            :AG_ID
            ,:NEW_SD_ID
            ,S.SD_TYPE
            ,S.SD_STATE
            ,S.RQ_ID
            ,S.CU_ID
            ,2
            ,S.SD_COMMENT
            ,S.SD_SUM
            ,S.SD_PERCENT
            ,S.SD_SUM_DEFAULT
            ,S.SD_PERCENT_DEFAULT
            ,S.SD_SKIDKA
            ,S.PT_ID
            ,S.SD_SETTING_SUM_AND_PERCENT
            ,S.GZ_ID
            ,S.SD_SUM_PAYED
            ,S.SD_ALL_PAYED
            ,S.SD_COMMENT_SHORT
            ,S.SD_FACT_NUM
            ,:SD_ID
            ,S.SD_KA_START_DATE
            ,S.SD_KA_END_DATE
            ,S.SD_FACT_DATE
            ,S.SD_NEW_CUST
            ,S.SD_IS_BEZNAL_V_NAL
            ,S.SD_PAY_DATE
            ,S.SD_APPROVED_DATE
            ,S.SD_DATE
            ,S.SD_PERCENT_GIVEN
            ,S.SD_SHOW_CUST_ID
            ,S.SD_IS_IMPORTANT_FOR_SITE
            ,S.REGISTERED_BY_ID
        FROM SDELKA S
        WHERE
            (S.AG_ID = :AG_ID AND S.SD_ID = :SD_ID);

/* теперь копируем объявления */
   FOR
      SELECT OB.OB_ID
      FROM OBJAV OB
      WHERE     OB.AG_ID = :AG_ID
            AND OB.SD_ID = :SD_ID
            AND OB.OB_PARENT IS NULL
      INTO :OBID
   DO
   BEGIN
        NEWOBID = GEN_ID(G_OB_ID, 1);
        INSERT INTO OBJAV
        (
        AG_ID
        ,SD_ID
        ,OB_ID
        ,OB_STATE
        ,OB_IS_ACTIVE
        ,OB_PARENT
        ,FM_ID
        ,RB_ID
        ,OB_VAC_COUNT
        ,OB_ORDER
        ,OB_TEXT
        ,OB_COMMENT
        ,OB_FOR_INTERNET
        ,OB_HAS_ATTENTION
        ,OB_CHANGED
        ,OB_IS_OPTIONAL
        ,DISTRICT_ID
        ,RS_ID
        ,SITE_EMAIL
        ,SITE_EMPLOYER
        )
        SELECT
            :AG_ID
            ,:NEW_SD_ID
            ,:NEWOBID
            ,OB.OB_STATE
            ,OB.OB_IS_ACTIVE
            ,OB.OB_PARENT
            ,OB.FM_ID
            ,OB.RB_ID
            ,OB.OB_VAC_COUNT
            ,OB.OB_ORDER
            ,OB.OB_TEXT
            ,OB.OB_COMMENT
            ,OB_FOR_INTERNET
            ,OB_HAS_ATTENTION
            ,OB_CHANGED
            ,OB_IS_OPTIONAL
            ,DISTRICT_ID
            ,OB.RS_ID
            ,OB.SITE_EMAIL
            ,OB.SITE_EMPLOYER
        FROM OBJAV OB
        WHERE     OB.AG_ID = :AG_ID
              AND OB.SD_ID = :SD_ID
              AND OB.OB_ID = :OBID;

        INSERT INTO OBJAV
        (
        AG_ID
        ,SD_ID
        ,OB_ID
        ,OB_STATE
        ,OB_IS_ACTIVE
        ,OB_PARENT
        ,FM_ID
        ,RB_ID
        ,OB_VAC_COUNT
        ,RS_ID
        ,OB_ORDER
        ,OB_TEXT
        ,OB_COMMENT
        ,OB_FOR_INTERNET
        ,OB_HAS_ATTENTION
        ,OB_CHANGED
        ,OB_IS_OPTIONAL
        )
        SELECT
            :AG_ID
            ,:NEW_SD_ID
            ,GEN_ID(G_OB_ID, 1)
            ,OB.OB_STATE
            ,OB.OB_IS_ACTIVE
            ,:NEWOBID
            ,OB.FM_ID
            ,OB.RB_ID
            ,OB.OB_VAC_COUNT
            ,OB.RS_ID
            ,OB.OB_ORDER
            ,OB.OB_TEXT
            ,OB.OB_COMMENT
            ,OB_FOR_INTERNET
            ,OB_HAS_ATTENTION
            ,OB_CHANGED
            ,OB_IS_OPTIONAL
        FROM OBJAV OB
        WHERE     OB.AG_ID = :AG_ID
              AND OB.SD_ID = :SD_ID
              AND OB.OB_PARENT = :OBID;
   END

/* копируем подачи и объявления */
    FOR
        SELECT PD_ID
        FROM PODACHA
        WHERE     AG_ID = :AG_ID
              AND SD_ID = :SD_ID
        INTO :PDID
    DO
    BEGIN
        NEW_PDID = GEN_ID(G_PD_ID, 1);
        INSERT INTO PODACHA
        (
            PD_ID
            ,IS_ID
            ,AG_ID
            ,SD_ID
            ,GZ_ID
            ,PD_FREE_OF_CHARGE
            ,PD_ADDDATE
            ,PD_IS_DONE
        )
            SELECT
                :NEW_PDID
                ,P.IS_ID
                ,:AG_ID
                ,:NEW_SD_ID
                ,P.GZ_ID
                ,P.PD_FREE_OF_CHARGE
                ,P.PD_ADDDATE
                ,P.PD_IS_DONE
            FROM PODACHA P
            WHERE P.PD_ID = :PDID;

        INSERT INTO OBJAVLENIE
        (
            OBJAV_ID
            ,PD_ID
            ,CONTENT_ID
            ,RB_ID
            ,FM_ID
            ,VAC_COUNT
            ,DOUBLE_RB_ID
            ,SAME_CODE
            ,OBJAV_COMMENT
            ,OBJAV_HAS_ATTENTION
            ,PICTURE_TO_INET
            ,DISTRICT_ID
            ,SITE_EMAIL
            ,SITE_EMPLOYER
            ,OB_STATE
            ,MDL_TEXT
        )
            SELECT
                GEN_ID(G_OBJAV_ID, 1)
                ,:NEW_PDID
                ,O.CONTENT_ID
                ,O.RB_ID
                ,O.FM_ID
                ,O.VAC_COUNT
                ,O.DOUBLE_RB_ID
                ,O.SAME_CODE
                ,O.OBJAV_COMMENT
                ,O.OBJAV_HAS_ATTENTION
                ,O.PICTURE_TO_INET
                ,O.DISTRICT_ID
                ,O.SITE_EMAIL
                ,O.SITE_EMPLOYER
                ,O.OB_STATE
                ,O.MDL_TEXT
            FROM OBJAVLENIE O
            WHERE O.PD_ID = :PDID;
    END

/* копируем услуги */
    INSERT INTO SERVICE
    (
        SR_ID
        ,AG_ID
        ,SD_ID
        ,SR_AMOUNT
        ,SR_SUM
        ,SR_TYPE
        ,SR_DESCRIPTION
    )
        SELECT
            GEN_ID(G_SR_ID, 1)
            ,:AG_ID
            ,:NEW_SD_ID
            ,P.SR_AMOUNT
            ,P.SR_SUM
            ,P.SR_TYPE
            ,P.SR_DESCRIPTION
        FROM SERVICE P
        WHERE     P.AG_ID = :AG_ID
              AND P.SD_ID = :SD_ID;

/* копируем телефоны */
    INSERT INTO PHONE
    (
        AG_ID
        ,SD_ID
        ,PH_NUMBER
    )
        SELECT
            :AG_ID
            ,:NEW_SD_ID
            ,P.PH_NUMBER
        FROM PHONE P
        WHERE     P.AG_ID=:AG_ID
              AND P.SD_ID=:SD_ID;

/* ставим сделку на подтверждение */
    UPDATE SDELKA S
    SET S.AS_ID = 1
    WHERE     S.AG_ID = :AG_ID
          AND S.SD_ID = :SD_ID;

    execute procedure LOG_SDELKA_CHANGES(:AG_ID, :SD_ID, :US_ID);
END^


ALTER PROCEDURE BEZNAL_V_NAL (
    AG_ID INTEGER,
    SD_ID INTEGER,
    SD_PERCENT FLOAT)
AS
begin
    UPDATE SDELKA SD
    SET SD.PT_ID=5,
        SD.SD_SUM_PAYED=SD.SD_SUM,
        SD.SD_PERCENT=:SD_PERCENT,
        SD.SD_ALL_PAYED=1,
        SD.SD_PAY_DATE=CURRENT_TIMESTAMP
    WHERE
        SD.AG_ID=:AG_ID AND
        SD.SD_ID=:SD_ID;
end^


ALTER PROCEDURE BUH_UPDATE_SDELKA (
    AGENT_ID INTEGER,
    SDELKA_ID INTEGER,
    PAYED_SUM FLOAT,
    FACT_DATE TIMESTAMP,
    FACT_NUM INTEGER)
RETURNS (
    RESULT INTEGER)
AS
DECLARE VARIABLE CNT INTEGER;
DECLARE VARIABLE ALLPAYED INTEGER;
DECLARE VARIABLE SUMM FLOAT;
DECLARE VARIABLE SUMM_PAYED FLOAT;
BEGIN
/*
Возвращаемые значения:
-1 - все ОК
 0 - неизвестная ошибка
 1 - сделка не найдена
*/

    RESULT=0;
    
    SELECT COUNT(*) FROM SDELKA
    WHERE AG_ID=:AGENT_ID AND
          SD_ID=:SDELKA_ID
    INTO :CNT;
    
    IF (CNT<>1) THEN
    BEGIN
        RESULT=1;
        EXIT;
    END
    
    SELECT SD_SUM,SD_SUM_PAYED FROM SDELKA
    WHERE AG_ID=:AGENT_ID AND SD_ID=:SDELKA_ID
    INTO :SUMM,:SUMM_PAYED;
    
    IF (:SUMM_PAYED+:PAYED_SUM=:SUMM) THEN
    BEGIN
        ALLPAYED=1;
    END
    ELSE
    BEGIN
        ALLPAYED=0;
    END
    
    UPDATE SDELKA
    SET SD_SUM_PAYED=SD_SUM_PAYED+:PAYED_SUM,
        SD_ALL_PAYED=:ALLPAYED
    WHERE AG_ID=:AGENT_ID AND
          SD_ID=:SDELKA_ID;

    

    RESULT=-1;
END^


ALTER PROCEDURE CAN_ADD_USR_RIGHT (
    US_ID INTEGER,
    AG_ID INTEGER)
AS
DECLARE VARIABLE USTYPE INTEGER;
DECLARE VARIABLE MGRCNT INTEGER;
BEGIN
    SELECT US_TYPE FROM USR
    WHERE US_ID=:US_ID
    INTO :USTYPE;

    IF (USTYPE=1) THEN
    BEGIN
        SELECT COUNT(*) FROM USR_RIGHTS UR
        WHERE UR.AG_ID=:AG_ID AND
              (SELECT MIN(US.US_TYPE) FROM USR US
               WHERE US.US_ID=UR.US_ID)=1
        INTO :MGRCNT;
        
        IF (MGRCNT>0) THEN
            EXCEPTION E_TOO_MANY_MANAGERS_FOR_AGENT;
    END
END^


ALTER PROCEDURE CHANGE_AGENT_FOR_SDELKA (
    AG_ID_WAS INTEGER,
    SD_ID_WAS INTEGER,
    AG_ID_NEW INTEGER)
RETURNS (
    SDID_NEW INTEGER)
AS
declare variable CUID_WAS integer;
declare variable CUCNT integer;
declare variable CUID_NEW integer;
declare variable SDCNT integer;
declare variable DUPL_SRC_AG_ID integer;
declare variable DUPL_SRC_SD_ID integer;
declare variable NEW_SD_NUM integer;
declare variable LOG_COMMENT varchar(128);
BEGIN
    SELECT CU_ID FROM SDELKA
    WHERE AG_ID=:AG_ID_WAS AND
          SD_ID=:SD_ID_WAS
    INTO :CUID_WAS;

/* Посмотрим, есть ли уже клиент с таким номером у нового агента
*/
    SELECT COUNT(*) FROM CUST
        WHERE AG_ID=:AG_ID_NEW AND
              CU_ID=:CUID_WAS
        INTO :CUCNT
    ;

/* Если нету - просто добавим ему нового клиента,
   если есть - поменяем номер у добавляемого клиента
*/
    IF (CUCNT=0) THEN
        CUID_NEW=CUID_WAS;
    ELSE
    BEGIN
        EXECUTE PROCEDURE NEXT_CU_ID
        RETURNING_VALUES :CUID_NEW;
    END


    INSERT INTO CUST (AG_ID,CU_ID,CU_NAME,CU_OKPO,CU_INFO,CU_KA_INFO_SHORT,CU_KA_INFO_FULL)
        SELECT :AG_ID_NEW,:CUID_NEW,CU_NAME,CU_OKPO,CU_INFO,CU_KA_INFO_SHORT,CU_KA_INFO_FULL FROM CUST
        WHERE AG_ID=:AG_ID_WAS AND CU_ID=:CUID_WAS
    ;

    INSERT INTO CUST_PHONE (AG_ID,CU_ID,CP_NUMBER,CP_ADDDATE)
        SELECT :AG_ID_NEW,:CUID_NEW,CP_NUMBER,CP_ADDDATE FROM CUST_PHONE
        WHERE AG_ID=:AG_ID_WAS AND CU_ID=:CUID_WAS
    ;

    SELECT COUNT(*)
    FROM SDELKA
    WHERE AG_ID=:AG_ID_NEW AND SD_ID=:SD_ID_WAS
    INTO :SDCNT;

    SDID_NEW=SD_ID_WAS;

    IF (SDCNT>0) THEN
    BEGIN
        EXECUTE PROCEDURE NEXT_SD_ID(:AG_ID_NEW)
        RETURNING_VALUES :SDID_NEW;
    END

    -- Установим признак, что сделка в данный момент дублируется
    -- (на случай, если передается сделка-дубликат)
    dupl_src_ag_id = null;
    dupl_src_sd_id = null;
    if (exists (
        select 1
        from SDELKA_DUPL sd
        where sd.AG_ID = :AG_ID_WAS
              and sd.SD_ID = :SD_ID_WAS
    )) then
    begin
        select sd.DUPL_OF_AG_ID, sd.DUPL_OF_SD_ID
        from SDELKA_DUPL sd
        where sd.AG_ID = :AG_ID_WAS
              and sd.SD_ID = :SD_ID_WAS
        into :dupl_src_ag_id, :dupl_src_sd_id;

        execute procedure sdelka_duplicating_start(:dupl_src_ag_id, :dupl_src_sd_id);
    end

    SELECT gen_id(GEN_SD_NUM,1) FROM rdb$database INTO :NEW_SD_NUM;

    UPDATE SDELKA
    SET AG_ID=:AG_ID_NEW,SD_ID=:SDID_NEW,CU_ID=:CUID_NEW ,SD_NUM = CAST(:AG_ID_NEW AS VARCHAR(10)) || '-' || CAST(:NEW_SD_NUM AS VARCHAR(128))
    WHERE AG_ID=:AG_ID_WAS AND
          SD_ID=:SD_ID_WAS;

    -- Снимем признак, что сделка в данный момент дублируется
    if (:dupl_src_ag_id is not null) then
        execute procedure sdelka_duplicating_end(:dupl_src_ag_id, :dupl_src_sd_id);

 --   LOG_COMMENT='Передача сделки №'||SD_ID_WAS||' агента №'||AG_ID_WAS||' агенту №'||AG_ID_NEW||' c #'||SDID_NEW;

 --   INSERT INTO LOG(LG_COMMENT)
 --   VALUES (:LOG_COMMENT);

    DELETE FROM CHANGE_AGENT_TASK cat WHERE cat.AG_ID_SRC = :AG_ID_WAS and cat.SD_ID_SRC = :SD_ID_WAS;
    SUSPEND;
END^


ALTER PROCEDURE CHANGE_GAZETA
AS
declare variable P_IS_ID integer;
declare variable P_PD_ID integer;
declare variable P_GZ_ID smallint;
declare variable P_AG_ID integer;
declare variable P_SD_ID integer;
declare variable P_IS_ID_NEW integer;
begin
  for
    select distinct
           p.pd_id,
           --  p.gz_id,
           --  sd.gz_id,
           p.is_id,

           p.ag_id,
           p.sd_id
    from
         PODACHA p,
         sdelka sd,

         issue i
    where
               (sd.ag_id = p.ag_id)   -- agent
   --      and (sd.gz_id = p.gz_id)   -- zageta
           and (p.sd_id = sd.sd_id)   -- sdelka
           and (i.is_id = p.is_id)

           and (i.gz_id <> sd.gz_id)
           and (sd.sd_date > '01.01.2011')

           and (sd.ag_id not in (440, 446, 412, 447))
           and (i.gz_id = 5)
           --  and (sd.gz_id = 5)  -- gazeta 5

     --   order by p.ag_id, p.sd_id
    into
        :p_pd_id,

      --  :p_gz_id,
        :p_is_id,

        :p_ag_id,
        :p_sd_id

  do
  begin

   execute procedure get_is_id_gazeta(:p_is_id)
   RETURNING_VALUES :p_is_id_new;

  --update podacha
  update podacha pd
  set pd.is_id = :p_is_id_new, pd.gz_id = 2  --в пропоную оголешення
  where pd.pd_id = :p_pd_id ;

  /*
  --update sdelka
  update sdelka sd
  set sd.gz_id = 2  --просто меняем газету
  where sd.ag_id = :p_ag_id and sd.sd_id = :p_sd_id;
 */
  end

  suspend;
end^


ALTER PROCEDURE CHECK_FOR_NEW_CUSTOMER (
    AG_ID INTEGER,
    CU_ID INTEGER,
    SD_DATE TIMESTAMP,
    GZ_ID INTEGER)
RETURNS (
    RESULT INTEGER)
AS
declare variable NUM varchar(64);
declare variable REAL_IS_CNT integer;
declare variable OLD_SD_DATE timestamp;
declare variable PARAM_IS_CNT integer;
declare variable INT_DATE timestamp;
begin
  /* Procedure Text */
  RESULT = 0;
  SELECT FIRST 1 cp.CP_NUMBER
  FROM CUST_PHONE cp
  WHERE cp.AG_ID = :AG_ID AND cp.CU_ID = :CU_ID
  INTO :NUM;

  SELECT MAX(i.IS_DATE)
  FROM CUST_PHONE cp
  LEFT JOIN sdelka s ON (s.AG_ID = cp.AG_ID AND s.CU_ID = cp.CU_ID)
  LEFT JOIN podacha p ON (p.AG_ID = s.AG_ID AND p.SD_ID = s.SD_ID)
  LEFT JOIN issue i ON (i.IS_ID = p.IS_ID)
  WHERE s.SD_DATE < :SD_DATE
  AND   cp.CP_NUMBER = :NUM
 -- AND   cp.AG_ID = :AG_ID
  AND   s.SD_STATE >= 4
  AND   s.AS_ID IN (0,1)
  INTO :OLD_SD_DATE;

  SELECT MAX(s.SD_KA_END_DATE)
  FROM CUST_PHONE cp
  LEFT JOIN sdelka s ON (s.AG_ID = cp.AG_ID AND s.CU_ID = cp.CU_ID)
  WHERE cp.CP_NUMBER = :NUM
--  AND   cp.AG_ID = :AG_ID
  AND   s.SD_DATE < :SD_DATE
  AND   s.SD_KA_END_DATE IS NOT NULL
  AND   s.GZ_ID IN (0, 6)
  AND   s.SD_STATE >= 4
  AND   s.AS_ID IN (0,1)  
  INTO :INT_DATE;

  IF(OLD_SD_DATE IS NULL) THEN OLD_SD_DATE = '01.01.2000';
  IF(INT_DATE IS NULL) THEN INT_DATE = '01.01.2000';
  IF(INT_DATE > OLD_SD_DATE) THEN OLD_SD_DATE = INT_DATE;

  PARAM_IS_CNT = 0;
  IF(GZ_ID = 1) THEN SELECT pr.PM_PR_CNT FROM params pr INTO :PARAM_IS_CNT;
  ELSE IF (GZ_ID = 3) THEN SELECT pr.PM_ST_CNT FROM params pr INTO :PARAM_IS_CNT;
  ELSE IF (GZ_ID IN (0, 6)) THEN SELECT pr.PM_INTERNET_CNT FROM params pr INTO :PARAM_IS_CNT;

  IF(SD_DATE > OLD_SD_DATE) THEN
      REAL_IS_CNT = DATEDIFF(DAY, :OLD_SD_DATE, :SD_DATE) / 7;
  ELSE
     REAL_IS_CNT = 0;

  IF (((GZ_ID = 1) AND (REAL_IS_CNT > PARAM_IS_CNT)) OR
      ((GZ_ID = 3) AND (REAL_IS_CNT * 4 > PARAM_IS_CNT)) OR    -- Умножаем на 4 потому что СТ выходит 4 раза в неделю
      ((GZ_ID IN (0, 6)) AND (REAL_IS_CNT > PARAM_IS_CNT))) THEN
  BEGIN
       RESULT = 1;
  END
  SUSPEND;
end^


ALTER PROCEDURE CHECK_PHONE_WILL_BE_IN_OTKAZNIK (
    AG_ID_INPUT INTEGER,
    PH_NUMBER_INPUT VARCHAR(16),
    LAST_ISSUE_PR INTEGER,
    LAST_ISSUE_NS INTEGER,
    LAST_ISSUE_SR INTEGER,
    LAST_ISSUE_RZ INTEGER,
    LAST_ISSUE_RK INTEGER,
    LASTISSDATE TIMESTAMP)
RETURNS (
    WILL_BE SMALLINT)
AS
DECLARE VARIABLE SDTYPE INTEGER;
DECLARE VARIABLE GZID INTEGER;
DECLARE VARIABLE SDID INTEGER;
DECLARE VARIABLE LASTISS INTEGER;
DECLARE VARIABLE SDDATE TIMESTAMP;
BEGIN
    WILL_BE=0;

    FOR
        SELECT FSD.SD_ID,SD.SD_TYPE,SD.GZ_ID,SD.SD_DATE
        FROM FIND_SDELKA_BY_PHONE_AND_AGENT(:AG_ID_INPUT,:PH_NUMBER_INPUT) FSD
        LEFT JOIN SDELKA SD
        ON (SD.AG_ID=:AG_ID_INPUT AND FSD.SD_ID=SD.SD_ID)
        INTO :sdid,:sdtype,:gzid,:sddate
    DO
    BEGIN
        SELECT MAX(IS_ID) FROM PODACHA PD
            WHERE
                PD.AG_ID=:AG_ID_INPUT
                AND
                PD.SD_ID=:sdid
            INTO
                :lastiss;
        IF (   (gzid=1 AND lastiss>=LAST_ISSUE_PR)
            OR (gzid=2 AND lastiss>=LAST_ISSUE_NS)
            OR (gzid=3 AND lastiss>=LAST_ISSUE_SR)
            OR (gzid=4 AND lastiss>=LAST_ISSUE_RZ)
            OR (gzid=5 AND lastiss>=LAST_ISSUE_RK)
            OR (sdtype in (3,4,5) AND sddate>=lastissDate)) THEN
        BEGIN
            WILL_BE=1;

            SUSPEND;

            EXIT;
        END
/*        IF (WILL_BE=1) THEN
            SUSPEND;*/
    END

    SUSPEND;
END^


ALTER PROCEDURE CLEAR_DOUBLES
AS
declare variable CNT integer;
declare variable OKPO varchar(25);
begin
  /* Procedure Text */
  FOR SELECT COUNT(cu.CUQ_REG_ID), cu.CUQ_OKPO
      FROM CUST_UNIQUE cu
      GROUP BY 2
      HAVING COUNT(cu.CUQ_REG_ID) > 1
      INTO :CNT, :OKPO DO
  BEGIN
        DELETE FROM CUST_UNIQUE cu
        WHERE cu.CUQ_OKPO = :OKPO
              AND NOT EXISTS(SELECT 1 FROM cust c WHERE c.CUQ_REG_ID = cu.CUQ_REG_ID);
  END
end^


ALTER PROCEDURE CLOSE_ISSUE (
    GZ_ID INTEGER,
    US_ID INTEGER)
AS
declare variable DATETMP timestamp;
BEGIN
    UPDATE sdelka s
    SET s.sd_state = 5
    WHERE s.sd_state = 4
          AND (
              s.gz_id = :gz_id
              or s.sd_type in (3, 4, 5, 6)
          );

    IF (gz_id = 1) THEN
    BEGIN
        SELECT pm_closedate_pr_new
        FROM params
        INTO :datetmp;

        UPDATE params
        SET pm_closedate_pr_old = :datetmp,
            pm_closedate_pr_new = CURRENT_TIMESTAMP;
    END
    ELSE IF (gz_id = 2) THEN
    BEGIN
        SELECT pm_closedate_ns_new
        FROM params
        INTO :datetmp;

        UPDATE params
        SET pm_closedate_ns_old = :datetmp,
            pm_closedate_ns_new = CURRENT_TIMESTAMP;
    END
    ELSE IF (gz_id = 3) THEN
    BEGIN
        SELECT pm_closedate_sr_new
        FROM params
        INTO :datetmp;

        UPDATE params
        SET pm_closedate_sr_old = :datetmp,
            pm_closedate_sr_new = CURRENT_TIMESTAMP;
    END
    ELSE IF (gz_id = 4) THEN
    BEGIN
        SELECT pm_closedate_rz_new
        FROM params
        INTO :datetmp;

        UPDATE params
        SET pm_closedate_rz_old = :datetmp,
            pm_closedate_rz_new = CURRENT_TIMESTAMP;
    END
    ELSE IF (gz_id = 5) THEN
    BEGIN
        SELECT pm_closedate_rk_new
        FROM params
        INTO :datetmp;

        UPDATE params
        SET pm_closedate_rk_old = :datetmp,
            pm_closedate_rk_new = CURRENT_TIMESTAMP;
    END
END^


ALTER PROCEDURE COMPARE_SUMS
RETURNS (
    MT_DATE DATE,
    MT_SUM FLOAT,
    SD_SUM FLOAT)
AS
BEGIN
    FOR
        select
            cast(mt_date as date) as mtdate,
            sum(mt_change)
        from
            money_transactions mt
        where
            mt.us_id=57 and
            mt.tt_id=2 and
            mt.mt_date>='09.11.2002' and
            mt.mt_comment starts 'Сдал деньги'
        group by 1
        into :MT_DATE,:MT_SUM
    DO
    BEGIN
        select sum(sd.sd_sum) from sdelka sd
        where sd.sd_pay_date>=:MT_DATE and
              cast(sd.sd_pay_date as date) = :MT_DATE and
              sd.pt_id=1 and
              sd.ag_id in (select ag_id from usr_rights where us_id=57)
        into :SD_SUM;
        
        SUSPEND;
    END

END^


ALTER PROCEDURE COPY_OBJAV (
    AG_ID_SRC INTEGER,
    SD_ID_SRC INTEGER,
    OB_ID_SRC INTEGER,
    AG_ID_DST INTEGER,
    SD_ID_DST INTEGER)
AS
declare variable GZID_SRC integer;
declare variable GZID_DST integer;
declare variable RBID_DST integer;
declare variable OBID integer;
declare variable ISID integer;
declare variable ISNAME varchar(10);
declare variable OBSTATE integer;
declare variable OBCOMMENT varchar(127);
declare variable DCURDATE date;
declare variable CURDATE char(10);
declare variable SITE_OB integer;
declare variable NEW_SITE_OB integer;
BEGIN
    OBID=GEN_ID(G_OB_ID,1);
/* Составим комментарий для выпускающего, что это - повтор */
    SELECT
        OB.OB_COMMENT
    FROM
        OBJAV OB
    WHERE
        OB.AG_ID=:AG_ID_SRC AND
        OB.SD_ID=:SD_ID_SRC AND
        OB.OB_ID=:OB_ID_SRC
    INTO
        :OBCOMMENT;
    IF (OBCOMMENT IS NULL) THEN
        OBCOMMENT='';
    DCURDATE=CURRENT_DATE;
    EXECUTE PROCEDURE UTIL_FORMAT_DATE(:DCURDATE)
    RETURNING_VALUES :CURDATE;
    IF (NOT OBCOMMENT LIKE '[Повтор%') THEN
    BEGIN
         SELECT MAX(IS_ID) FROM PODACHA PD
         WHERE PD.AG_ID=:AG_ID_SRC AND PD.SD_ID=:SD_ID_SRC
         INTO :ISID;
         SELECT IS_NAME FROM ISSUE ISS
         WHERE ISS.IS_ID=:ISID
         INTO :ISNAME;
         OBCOMMENT='[Повтор из №'||ISNAME||'] '||OBCOMMENT;
    END
/* Вычислим статус скопированного объявления, чтобы он был <=корректура */
    SELECT
        OB.OB_STATE
    FROM
        OBJAV OB
    WHERE
        OB.AG_ID=:AG_ID_SRC AND
        OB.SD_ID=:SD_ID_SRC AND
        OB.OB_ID=:OB_ID_SRC
    INTO
        :OBSTATE;
    IF (OBSTATE>1) THEN
        OBSTATE=1;

/* Сбросим рубрику, если повтор - из одной газеты в другую */
    SELECT
        SD.GZ_ID
    FROM
        SDELKA SD
    WHERE
        SD.AG_ID = :AG_ID_SRC AND
        SD.SD_ID = :SD_ID_SRC
    INTO
        :GZID_SRC;

    SELECT
        SD.GZ_ID
    FROM
        SDELKA SD
    WHERE
        SD.AG_ID = :AG_ID_DST AND
        SD.SD_ID = :SD_ID_DST
    INTO
        :GZID_DST;

    IF (GZID_SRC <> GZID_DST) THEN
    BEGIN
        SELECT
            RB.RB_ID
        FROM
            RUBRIKA RB
        WHERE
            RB.GZ_ID = :GZID_DST AND
            RB.RB_NAME LIKE '_ЗАМЕНИТЬ%'
        INTO
            :RBID_DST;
    END
    ELSE
    BEGIN
        SELECT
            OB.RB_ID
        FROM
            OBJAV OB
        WHERE
            OB.AG_ID=:AG_ID_SRC AND
            OB.SD_ID=:SD_ID_SRC AND
            OB.OB_ID=:OB_ID_SRC
        INTO
            :RBID_DST;
    END

/* Вставим объявление-повтор */
    INSERT INTO OBJAV (
        AG_ID,
        SD_ID,
        OB_ID,
        OB_STATE,
        OB_IS_ACTIVE,
        OB_PARENT,
        FM_ID,
        RB_ID,
        OB_VAC_COUNT,
        RS_ID,
        OB_ORDER,
        OB_COMMENT,
        OB_TEXT,
        OB_FOR_INTERNET,
        OB_HAS_ATTENTION,
        OB_CHANGED,
        OB_IS_OPTIONAL,
        DISTRICT_ID)
    SELECT
        :AG_ID_DST,
        :SD_ID_DST,
        :OBID,
        :OBSTATE,
        1,
        OB_PARENT,
        FM_ID,
        :RBID_DST,
        OB_VAC_COUNT,
        RS_ID,
        OB_ORDER,
        :OBCOMMENT,
        OB_TEXT,
        OB_FOR_INTERNET,
        OB_HAS_ATTENTION,
        OB_CHANGED,
        OB_IS_OPTIONAL,
        DISTRICT_ID
    FROM
        OBJAV OB
    WHERE
        OB.AG_ID=:AG_ID_SRC AND
        OB.SD_ID=:SD_ID_SRC AND
        OB.OB_ID=:OB_ID_SRC
    ;

/* Вставим дубль объявления-повтора, если он идет в ту же газету */
    IF (GZID_SRC = GZID_DST) THEN
    BEGIN
        INSERT INTO OBJAV (
            AG_ID,
            SD_ID,
            OB_STATE,
            OB_IS_ACTIVE,
            OB_PARENT,
            FM_ID,
            RB_ID,
            OB_VAC_COUNT,
            RS_ID,
            OB_ORDER,
            OB_COMMENT,
            OB_TEXT,
            OB_FOR_INTERNET,
            OB_HAS_ATTENTION,
            OB_CHANGED,
            OB_IS_OPTIONAL)
        SELECT
            :AG_ID_DST,
            :SD_ID_DST,
            :OBSTATE,
            1,
            :OBID,
            FM_ID,
            RB_ID,
            OB_VAC_COUNT,
            RS_ID,
            OB_ORDER,
            OB_COMMENT,
            OB_TEXT,
            OB_FOR_INTERNET,
            OB_HAS_ATTENTION,
            OB_CHANGED,
            OB_IS_OPTIONAL
        FROM
            OBJAV OB
        WHERE
            OB.AG_ID=:AG_ID_SRC AND
            OB.SD_ID=:SD_ID_SRC AND
            OB.OB_PARENT=:OB_ID_SRC
        ;
    END

    /* Скопируем объявления для сайта */
  --  NEW_SITE_OB =  GEN_ID(G_SITE_OBJAV, 1);
    INSERT INTO SITE_OBJAV(
           SITE_OBJAV_ID,
           RS_ID,
           SITE_OBJAV_TEXT,
           SITE_VACANCY_NAME,
           SITE_EMAIL,
           SITE_TEL,
           SITE_CONTACT,
           SITE_DONT_UPLOAD,
           SITE_ZP,
           SITE_EMPLOYER,
           OB_ID,
           EX_ID,
           ED_ID,
           C_ID,
           CU_ADDRESS
    )
    SELECT
           NULL,
           RS_ID,
           SITE_OBJAV_TEXT,
           SITE_VACANCY_NAME,
           SITE_EMAIL,
           SITE_TEL,
           SITE_CONTACT,
           SITE_DONT_UPLOAD,
           SITE_ZP,
           SITE_EMPLOYER,
           :OBID,
           EX_ID,
           ED_ID,
           C_ID,
           CU_ADDRESS
    FROM SITE_OBJAV
    WHERE OB_ID = :OB_ID_SRC;

    IF(EXISTS(SELECT 1 FROM SITE_OBJAV so WHERE so.OB_ID = :ob_id_src)) THEN
    UPDATE OBJAV o
    SET o.SITE_OBJAV_ADDED = 1
    WHERE o.OB_ID = :OBID;

     /* This methods is deprecated */
    SELECT FIRST 1 ot.SITE_OBJAV_ID FROM OBJAV_TEXT_SITE_OBJAV ot WHERE ot.OB_ID = :OB_ID_SRC INTO :SITE_OB;

    IF(SITE_OB IS NOT NULL) THEN
    BEGIN
       NEW_SITE_OB =  GEN_ID(G_SITE_OBJAV, 1);
       INSERT INTO SITE_OBJAV(
           SITE_OBJAV_ID,
           RS_ID,
           SITE_OBJAV_TEXT,
           SITE_VACANCY_NAME,
           SITE_EMAIL,
           SITE_TEL,
           SITE_CONTACT,
           SITE_DONT_UPLOAD,
           SITE_ZP,
           SITE_EMPLOYER,
           OB_ID
       )
       SELECT
           :NEW_SITE_OB,
           RS_ID,
           SITE_OBJAV_TEXT,
           SITE_VACANCY_NAME,
           SITE_EMAIL,
           SITE_TEL,
           SITE_CONTACT,
           SITE_DONT_UPLOAD,
           SITE_ZP,
           SITE_EMPLOYER,
           :OBID
      FROM SITE_OBJAV
      WHERE SITE_OBJAV_ID = :SITE_OB;

     -- INSERT INTO OBJAV_TEXT_SITE_OBJAV (OB_ID, SITE_OBJAV_ID) VALUES(:OBID, :NEW_SITE_OB);

      UPDATE OBJAV o
      SET o.SITE_OBJAV_ADDED = 1
      WHERE o.OB_ID = :OBID;
    END

END^


ALTER PROCEDURE COPY_OBJAVLENIE (
    OBJAV_ID_SRC INTEGER,
    PD_ID_DST INTEGER,
    NEW_CONTENT INTEGER)
AS
declare variable GZID_SRC integer;
declare variable GZID_DST integer;
declare variable CONTENTID integer;
declare variable RBID integer;
declare variable FMID integer;
declare variable VACCOUNT smallint;
declare variable DOUBLERBID integer;
declare variable OBJAVCOMMENT varchar(255);
declare variable OBJAVHASATTENTION smallint;
declare variable PICTURETOINET smallint;
declare variable DISTRICTID integer;
declare variable MDL_TEXT D_MEMO;
declare variable SAME_CODE integer;
BEGIN

/* Извлечем всю информацию о копируемом объявлении */
    SELECT
          CONTENT_ID
        , RB_ID
        , FM_ID
        , VAC_COUNT
        , DOUBLE_RB_ID
        , OBJAV_COMMENT
        , OBJAV_HAS_ATTENTION
        , PICTURE_TO_INET
        , DISTRICT_ID
        , MDL_TEXT
    FROM
        OBJAVLENIE
    WHERE
        OBJAV_ID = :OBJAV_ID_SRC
    INTO
          :CONTENTID
        , :RBID
        , :FMID
        , :VACCOUNT
        , :DOUBLERBID
        , :OBJAVCOMMENT
        , :OBJAVHASATTENTION
        , :PICTURETOINET
        , :DISTRICTID
        , :MDL_TEXT;



/* Сбросим рубрику, если повтор - из одной газеты в другую */
    SELECT
        PD.GZ_ID
    FROM
        OBJAVLENIE OB
        LEFT JOIN PODACHA PD ON (PD.PD_ID = OB.PD_ID)
    WHERE
        OB.OBJAV_ID = :OBJAV_ID_SRC
    INTO
        :GZID_SRC;

    SELECT
        PD.GZ_ID
    FROM
        PODACHA PD
    WHERE
        PD.PD_ID = :PD_ID_DST
    INTO
        :GZID_DST;

    IF (GZID_SRC <> GZID_DST) THEN
    BEGIN
        SELECT
            RB.RB_ID
        FROM
            RUBRIKA RB
        WHERE
            RB.GZ_ID = :GZID_DST AND
            RB.RB_NAME LIKE '_ЗАМЕНИТЬ%'
        INTO
            :RBID;

        DOUBLERBID = NULL;
    END

    IF(NEW_CONTENT IS NOT NULL) THEN CONTENTID = :NEW_CONTENT;

/* вызовем стандартную процедуру добавления Объявления,
   чтобы нормально добавились такие же объявления ко всем
   Подачам, где это нужно */
   EXECUTE PROCEDURE OBJAVLENIE_INSERT (  :PD_ID_DST
                                           , :CONTENTID
                                           , :RBID
                                           , :FMID
                                           , :VACCOUNT
                                           , :DOUBLERBID
                                           , :OBJAVCOMMENT
                                           , :OBJAVHASATTENTION
                                           , :PICTURETOINET
                                           , :DISTRICTID
                                           , :MDL_TEXT)
    RETURNING_VALUES :SAME_CODE;
END^


ALTER PROCEDURE COPY_SITE_OBJAV (
    CONTENT_ID_FROM INTEGER,
    CONTENT_ID_TO INTEGER)
AS
BEGIN
    INSERT INTO SITE_OBJAV(RS_ID, SITE_OBJAV_TEXT, SITE_VACANCY_NAME, SITE_EMAIL, SITE_TEL, SITE_CONTACT, SITE_DONT_UPLOAD, SITE_ZP,
                           SITE_EMPLOYER, EX_ID, ED_ID, C_ID, CONTENT_ID, IS_ID, CU_ADDRESS)
    SELECT so.RS_ID, so.SITE_OBJAV_TEXT, so.SITE_VACANCY_NAME, so.SITE_EMAIL, so.SITE_TEL, so.SITE_CONTACT, so.SITE_DONT_UPLOAD, so.SITE_ZP,
           so.SITE_EMPLOYER, so.EX_ID, so.ED_ID, so.C_ID, :CONTENT_ID_TO, so.IS_ID, so.CU_ADDRESS
    FROM SITE_OBJAV so
    WHERE so.CONTENT_ID = :CONTENT_ID_FROM;
END^


ALTER PROCEDURE COPY_SITE_OBJAV_ID (
    SITE_OBJAV_ID_FROM INTEGER,
    CONTENT_ID_TO INTEGER)
AS
BEGIN
    INSERT INTO SITE_OBJAV(RS_ID, SITE_OBJAV_TEXT, SITE_VACANCY_NAME, SITE_EMAIL, SITE_TEL, SITE_CONTACT, SITE_DONT_UPLOAD, SITE_ZP,
                           SITE_EMPLOYER, EX_ID, ED_ID, C_ID, CONTENT_ID, IS_ID, CU_ADDRESS)
    SELECT so.RS_ID, so.SITE_OBJAV_TEXT, so.SITE_VACANCY_NAME, so.SITE_EMAIL, so.SITE_TEL, so.SITE_CONTACT, so.SITE_DONT_UPLOAD, so.SITE_ZP,
           so.SITE_EMPLOYER, so.EX_ID, so.ED_ID, so.C_ID, :CONTENT_ID_TO, so.IS_ID, so.CU_ADDRESS
    FROM SITE_OBJAV so
    WHERE so.SITE_OBJAV_ID = :SITE_OBJAV_ID_FROM;
END^


ALTER PROCEDURE COUNT_CUST_BONUS (
    AG_ID_INPUT INTEGER,
    CU_ID_INPUT INTEGER)
RETURNS (
    AG_ID INTEGER,
    CU_ID INTEGER,
    CUST_BONUS FLOAT)
AS
BEGIN
    AG_ID=AG_ID_INPUT;
    CU_ID=CU_ID_INPUT;
    
    SELECT BT_SUM FROM BONUS_TRANSACTIONS
    WHERE AG_ID=:AG_ID_INPUT AND
      CU_ID=:CU_ID_INPUT AND
      BT_ID=(SELECT MAX(BT_ID) FROM BONUS_TRANSACTIONS
             WHERE AG_ID=:AG_ID_INPUT AND CU_ID=:CU_ID_INPUT)
    INTO :CUST_BONUS;
    
    SUSPEND;
END^


ALTER PROCEDURE COUNT_PERCENT (
    AG_ID INTEGER,
    SD_ID INTEGER)
RETURNS (
    PERCENT FLOAT)
AS
declare variable ISID INTEGER;
declare variable PTID INTEGER;
declare variable GZID INTEGER;
BEGIN
/*    SELECT PT_ID,GZ_ID FROM SDELKA WHERE AG_ID=:AG_ID AND SD_ID=:SD_ID
    INTO :PTID,:GZID;
    
    if (GZID=1) then
        SELECT PM_CURRENT_ISSUE_PR FROM PARAMS
        INTO :ISID;
    else
        SELECT PM_CURRENT_ISSUE_NS FROM PARAMS
        INTO :ISID;

    IF (PTID=1 OR PTID=5) THEN
        SELECT AP_NAL FROM AGENT_PERCENT
        WHERE AG_ID=:AG_ID AND IS_ID=:ISID
        INTO :PERCENT;
    ELSE IF (PTID=2 OR PTID=3) THEN
        SELECT AP_BEZNAL FROM AGENT_PERCENT
        WHERE AG_ID=:AG_ID AND IS_ID=:ISID
        INTO :PERCENT;
    ELSE
*/
    PERCENT=0;

    SUSPEND;
END^


ALTER PROCEDURE COUNT_SDELKA_SERVICES (
    IN_FACT_NUM INTEGER,
    IN_FACT_DATE TIMESTAMP)
RETURNS (
    SERVICE_COUNT INTEGER)
AS
begin
    select count(*)
    from
        SDELKA_REAL sd

        left join SERVICE sr on (sr.AG_ID = sd.AG_ID and sr.SD_ID = sd.SD_ID)
    where
            sd.SD_FACT_NUM = :IN_FACT_NUM
        and sd.SD_FACT_DATE = :IN_FACT_DATE
    into
        :SERVICE_COUNT;

    suspend;
end^


ALTER PROCEDURE COUNT_SUM (
    AG_ID INTEGER,
    SD_ID INTEGER)
RETURNS (
    SUMMA FLOAT)
AS
DECLARE VARIABLE FMID INTEGER;
DECLARE VARIABLE RBID INTEGER;
DECLARE VARIABLE CNTINISSUE INTEGER;
DECLARE VARIABLE SD_TYPE INTEGER;
DECLARE VARIABLE PD_COUNT INTEGER;
DECLARE VARIABLE OB_COST FLOAT;
DECLARE VARIABLE OB_COEFF FLOAT;
DECLARE VARIABLE OB_SKIDKA FLOAT;
DECLARE VARIABLE DUMB INTEGER;
DECLARE VARIABLE OB_COUNT INTEGER;
DECLARE VARIABLE OBJAVLENIE_COUNT INTEGER;
DECLARE VARIABLE SERVICE_SUM FLOAT;
begin

  execute procedure GET_MAX_FORMAT_AND_RUBRIKA(:AG_ID, :SD_ID)
  returning_values :FMID, :RBID, :OB_COST;

  SUMMA = 0;

  select SD_TYPE, SD_SKIDKA
  from SDELKA
  where     AG_ID = :AG_ID
        and SD_ID = :SD_ID
  into :SD_TYPE, OB_SKIDKA;

  if (SD_TYPE = 1) then
  begin
    select count(*)
    from PODACHA
    where     AG_ID = :AG_ID
          and SD_ID = :SD_ID
          and PD_FREE_OF_CHARGE <> 1
    into :PD_COUNT;

/* Объявления в "Сетку учебных заведений" */
    if (FMID = 16) then
    begin
        select count(*)
        from OBJAV o
        where     o.AG_ID = :AG_ID
              and o.SD_ID = :SD_ID
        into :cntInIssue;
        if (cntInIssue <= 4) then
            OB_COST = 28;
        else if (cntInIssue <= 8) then
            OB_COST = 25;
        else
            OB_COST = 20;
    end

/* Если в сделке есть только строчные, то каждое из них добавляется в стоимость */
    select count(*)
    from OBJAV o
    where o.AG_ID = :AG_ID and o.SD_ID = :SD_ID and o.FM_ID <> 1
    into :OB_COUNT;

    select count(*)
    from PODACHA p
    left join OBJAVLENIE o on (o.PD_ID = p.PD_ID)
    where     p.AG_ID = :AG_ID and p.SD_ID = :SD_ID
          and p.PD_ID is not null
    into :OBJAVLENIE_COUNT;

/*  select count(*)
  from OBJAVLENIE o
  where o.PD_ID in (select p.PD_ID from PODACHA p where p.AG_ID = :AG_ID and p.SD_ID = :SD_ID)
  into :OBJAVLENIE_COUNT;*/

    if (OB_COUNT = 0 and OBJAVLENIE_COUNT = 0) then
      select count(*)
      from OBJAV o
      where o.AG_ID = :AG_ID and o.SD_ID = :SD_ID and o.FM_ID = 1
      into :OB_COUNT;
    else
      OB_COUNT = 1;

    SUMMA = OB_COUNT * OB_COST * PD_COUNT * (100 - OB_SKIDKA) / 100;
  end
/* Листовки */
/*  else if (SD_TYPE = 6) then
  begin
    SUMMA = 0;
  end
  else
    SUMMA = 0;
*/

  select coalesce(sum(s.SR_SUM), 0)
  from SERVICE s
  where     s.AG_ID = :AG_ID
        and s.SD_ID = :SD_ID
  into :SERVICE_SUM;

  SUMMA = SUMMA + SERVICE_SUM;

  suspend;
end^


ALTER PROCEDURE COUNT_SUM_NEW (
    AG_ID INTEGER,
    SD_ID INTEGER)
RETURNS (
    SUMMA FLOAT)
AS
declare variable PD_COUNT integer;
declare variable OB_COST float;
declare variable OB_SKIDKA float;
declare variable DUMB integer;
declare variable DUMNB integer;
declare variable CURRPDID integer;
declare variable OBJAV_TO integer;
declare variable FMID integer;
declare variable CNTINISSUE integer;
declare variable GZ_ID integer;
declare variable SUM_TXT float;
declare variable SUM_MOD float;
declare variable SUM_INT float;
declare variable OB_COST_4 float;
declare variable P integer;
declare variable ST_IS_CNT_KOEF integer;
BEGIN
  SUMMA = 0;
  SUM_TXT = 0;
  SUM_MOD = 0;
  SUM_INT = 0;
  ST_IS_CNT_KOEF = 4;

  EXECUTE PROCEDURE GET_CURRENT_PODACHA(:AG_ID,:SD_ID)
  RETURNING_VALUES :CURRPDID,:DUMB,:DUMB;

  SELECT SD_SKIDKA, GZ_ID
  FROM SDELKA
  WHERE     AG_ID = :AG_ID
        AND SD_ID = :SD_ID
  INTO OB_SKIDKA, :GZ_ID;

  SELECT COUNT(*)
  FROM PODACHA
  WHERE AG_ID = :AG_ID
  AND   SD_ID = :SD_ID
  AND   PD_FREE_OF_CHARGE <> 1
  INTO :PD_COUNT;

  FOR SELECT
        0
       ,fc.FM_COST * rb.RB_COST_COEFF
       ,fc.FM_COST_4 * rb.RB_COST_COEFF
       ,f.FM_ID
      FROM OBJAV ob
      LEFT JOIN RUBRIKA rb ON (ob.RB_ID = rb.RB_ID)
      LEFT JOIN FORMAT f ON (f.FM_ID = ob.FM_ID)
      LEFT JOIN FORMAT_COST fc ON (fc.FM_ID = f.FM_ID)
      WHERE OB.AG_ID = :AG_ID
      AND   OB.SD_ID = :SD_ID
      AND   fc.GZ_ID = :GZ_ID

      UNION ALL

      SELECT
        1
       ,fc.FM_COST * rb.RB_COST_COEFF
       ,fc.FM_COST_4 * rb.RB_COST_COEFF
       ,f.FM_ID
      FROM OBJAVLENIE obj
      LEFT JOIN PODACHA pd ON (obj.PD_ID = pd.PD_ID)
      LEFT JOIN FORMAT f ON (obj.FM_ID = f.FM_ID)
      LEFT JOIN FORMAT_COST fc ON (fc.FM_ID = f.FM_ID)
      LEFT JOIN RUBRIKA rb ON (obj.RB_ID = rb.RB_ID)
      WHERE obj.PD_ID = :CURRPDID
      AND   fc.GZ_ID = :GZ_ID

      UNION ALL

      SELECT
        2
       ,fc.FM_COST
       ,0
       ,f.FM_ID
      FROM SDELKA s
      LEFT JOIN SD_INET_OB si ON (si.AG_ID = s.AG_ID AND si.SD_ID = s.SD_ID)
      LEFT JOIN FORMAT f ON (f.FM_ID = si.OB_TYPE)
      LEFT JOIN FORMAT_COST fc ON (fc.FM_ID = f.FM_ID)
      WHERE s.AG_ID = :AG_ID
      AND   s.SD_ID = :SD_ID
      AND   fc.GZ_ID = :GZ_ID
      INTO :OBJAV_TO, :OB_COST, :OB_COST_4, :FMID
  DO BEGIN
            /* Объявления в "Сетку учебных заведений" */
           IF (FMID = 16) THEN
           BEGIN
                SELECT COUNT(*)
                FROM OBJAV o
                WHERE o.AG_ID = :AG_ID
                AND   o.SD_ID = :SD_ID
                INTO :cntInIssue;

                IF (cntInIssue <= 4) THEN OB_COST = 28;
                ELSE IF (cntInIssue <= 8) THEN OB_COST = 25;
                ELSE OB_COST = 20;
           END

           IF(OBJAV_TO = 0) THEN
           BEGIN
                 P = PD_COUNT;
                 IF((GZ_ID = 3) AND (PD_COUNT >= ST_IS_CNT_KOEF)) THEN
                 BEGIN
                     WHILE (P >= ST_IS_CNT_KOEF) DO
                     BEGIN
                         SUM_TXT = SUM_TXT + OB_COST_4;
                         P = P - ST_IS_CNT_KOEF;
                     END
                 END

                 SUM_TXT = SUM_TXT + OB_COST * P;
           END
           ELSE IF(OBJAV_TO = 1) THEN
           BEGIN
                 P = PD_COUNT;
                 IF((GZ_ID = 3) AND (PD_COUNT >= ST_IS_CNT_KOEF)) THEN
                 BEGIN
                     WHILE (P >= ST_IS_CNT_KOEF) DO
                     BEGIN
                         SUM_MOD = SUM_MOD + OB_COST_4;
                         P = P - ST_IS_CNT_KOEF;
                     END
                 END

                 SUM_MOD = SUM_MOD + OB_COST * P;
           END
           ELSE IF(OBJAV_TO = 2) THEN SUM_INT = SUM_INT + OB_COST;

           --SUMMA = SUMMA + OB_COST * PD_COUNT;
  END

  SUMMA = (SUM_TXT + SUM_MOD + SUM_INT);
  SUMMA = SUMMA * (100 - OB_SKIDKA) / 100;

  SUSPEND;
END^


ALTER PROCEDURE CUST_BY_DATE (
    US_ID INTEGER,
    DATE_FROM TIMESTAMP,
    DATE_TO TIMESTAMP)
RETURNS (
    AG_ID INTEGER,
    CUST_NEW INTEGER,
    CUST_OLD INTEGER,
    CUST_NEW_SDELKA_COUNT INTEGER,
    CUST_NEW_SDELKA_SUM FLOAT,
    CUST_OLD_SDELKA_COUNT INTEGER,
    CUST_OLD_SDELKA_SUM FLOAT)
AS
BEGIN
    FOR
        SELECT UR.AG_ID
        FROM USR_RIGHTS UR
        WHERE UR.US_ID=:US_ID
        INTO :AG_ID
    DO
    BEGIN

        SELECT
            COUNT(DISTINCT SDR.CU_ID)
        FROM
            SDELKA_REAL SDR
        WHERE
            SDR.AG_ID=:AG_ID AND
            SDR.SD_APPROVED_DATE>=:DATE_FROM AND
            SDR.SD_APPROVED_DATE<=:DATE_TO AND
            SDR.SD_NEW_CUST=1
        INTO
            :CUST_NEW;
            
        SELECT
            COUNT(DISTINCT SDR.CU_ID)
        FROM
            SDELKA_REAL SDR
        WHERE
            SDR.AG_ID=:AG_ID AND
            SDR.SD_APPROVED_DATE>=:DATE_FROM AND
            SDR.SD_APPROVED_DATE<=:DATE_TO AND
            (SDR.SD_NEW_CUST=0 OR SDR.SD_NEW_CUST IS NULL)
        INTO
            :CUST_OLD;
            
        SELECT
            COUNT(*),SUM(SDR.SD_SUM)
        FROM
            SDELKA_REAL SDR
        WHERE
            SDR.AG_ID=:AG_ID AND
            SDR.SD_APPROVED_DATE>=:DATE_FROM AND
            SDR.SD_APPROVED_DATE<=:DATE_TO AND
            SDR.SD_NEW_CUST=1
        INTO
            :CUST_NEW_SDELKA_COUNT,:CUST_NEW_SDELKA_SUM;

        SELECT
            COUNT(*),SUM(SDR.SD_SUM)
        FROM
            SDELKA_REAL SDR
        WHERE
            SDR.AG_ID=:AG_ID AND
            SDR.SD_APPROVED_DATE>=:DATE_FROM AND
            SDR.SD_APPROVED_DATE<=:DATE_TO AND
            (SDR.SD_NEW_CUST=0 OR SDR.SD_NEW_CUST IS NULL)
        INTO
            :CUST_OLD_SDELKA_COUNT,:CUST_OLD_SDELKA_SUM;

        SUSPEND;
        
    END
END^


ALTER PROCEDURE CUST_INFO_LIST (
    GZ_ID INTEGER)
RETURNS (
    CU_ID_COMPOUND CHAR(23),
    CU_INFO VARCHAR(255))
AS
DECLARE VARIABLE ISID INTEGER;
BEGIN
    execute procedure GET_CURRENT_ISSUE(:gz_id)
    returning_values :ISID;

/*    IF (GZ_ID=1) THEN
        SELECT PM_CURRENT_ISSUE_PR
        FROM PARAMS
        INTO :ISID;
    ELSE IF (GZ_ID=2) THEN
        SELECT PM_CURRENT_ISSUE_NS
        FROM PARAMS
        INTO :ISID;
    ELSE
        SELECT PM_CURRENT_ISSUE_SR
        FROM PARAMS
        INTO :ISID;
*/

    FOR
        SELECT
            DISTINCT
            CU.CU_ID_COMPOUND,
            CU_INFO
        FROM
            OBJAV_LIST_V_NOMER_ALL(:ISID) OBL

            LEFT JOIN SDELKA SD
            ON (OBL.AG_ID=SD.AG_ID AND OBL.SD_ID=SD.SD_ID)

            LEFT JOIN CUST CU
            ON (OBL.AG_ID=CU.AG_ID AND SD.CU_ID=CU.CU_ID)
        WHERE
            SD_SHOW_CUST_ID=1 AND
            CU_INFO<>'' AND
            CU_INFO IS NOT NULL
        ORDER BY
            SD.AG_ID,SD.CU_ID
        INTO
            :CU_ID_COMPOUND,:CU_INFO
    DO
        SUSPEND;
END^


ALTER PROCEDURE CUST_KA_INFO_LIST
RETURNS (
    CU_NAME VARCHAR(255),
    CU_KA_INFO_FULL VARCHAR(1023))
AS
DECLARE VARIABLE ISID INTEGER;
BEGIN
    SELECT PM_CURRENT_ISSUE_PR
    FROM PARAMS
    INTO :ISID;

    FOR
        SELECT
            DISTINCT
            CU.CU_NAME,
            CU_KA_INFO_FULL
        FROM
            OBJAV_LIST_KA OBL

            LEFT JOIN SDELKA SD
            ON (OBL.AG_ID=SD.AG_ID AND OBL.SD_ID=SD.SD_ID)

            LEFT JOIN CUST CU
            ON (OBL.AG_ID=CU.AG_ID AND SD.CU_ID=CU.CU_ID)
/*        WHERE
            CU_KA_INFO_FULL<>'' AND
            CU_KA_INFO_FULL IS NOT NULL*/
        ORDER BY
            SD.AG_ID,SD.CU_ID
        INTO
            :CU_NAME,:CU_KA_INFO_FULL
    DO
        SUSPEND;
END^


ALTER PROCEDURE DAYOFWEEK_NAME (
    DAY_NUM INTEGER)
RETURNS (
    DAY_NAME VARCHAR(2))
AS
BEGIN
    if (DAY_NUM = 1) then
        DAY_NAME = 'Вс';
    else if (DAY_NUM = 2) then
        DAY_NAME = 'Пн';
    else if (DAY_NUM = 3) then
        DAY_NAME = 'Вт';
    else if (DAY_NUM = 4) then
        DAY_NAME = 'Ср';
    else if (DAY_NUM = 5) then
        DAY_NAME = 'Чт';
    else if (DAY_NUM = 6) then
        DAY_NAME = 'Пт';
    else if (DAY_NUM = 7) then
        DAY_NAME = 'Сб';

    SUSPEND;
END^


ALTER PROCEDURE DELETE_CUST (
    CU_ID INTEGER,
    AG_ID INTEGER)
AS
begin
  /* Procedure Text */
  DELETE FROM cust_phone cp WHERE cp.cu_id = :cu_id AND cp.ag_id = :ag_id;
  DELETE FROM cust c WHERE c.ag_id = :ag_id AND c.cu_id = :cu_id;
end^


ALTER PROCEDURE DELETE_SDELKA (
    AG_ID INTEGER,
    SD_ID INTEGER,
    COMMENT VARCHAR(128))
AS
BEGIN
    INSERT INTO SDELKA_DELETED(AG_ID, SD_ID, SD_TYPE, SD_STATE, RQ_ID, CU_ID, AS_ID, SD_COMMENT,
           SD_SUM, SD_PERCENT, SD_SUM_DEFAULT, SD_PERCENT_DEFAULT, SD_SKIDKA,
           PT_ID, SD_SETTING_SUM_AND_PERCENT, GZ_ID, SD_SUM_PAYED, SD_ALL_PAYED,
           SD_COMMENT_SHORT, SD_IS_CHANGED_COPY_OF_SD_ID, SD_ID_COMPOUND, SD_PAY_NOW,
           SD_FACT_NUM, SD_KA_START_DATE, SD_KA_END_DATE, SD_FACT_DATE, SD_DATE,
           SD_PERCENT_SUM, SD_PERCENT_GIVEN, SD_TO_GIVE_PERCENT, SD_APPROVED_DATE,
           SD_IS_BEZNAL_V_NAL, SD_PAY_DATE, SD_NEW_CUST, SD_PERCENT_SUM_TO_GIVE,
           SD_SHOW_CUST_ID, SD_IS_IMPORTANT_FOR_SITE,
           SD_PAY_VER, SD_NUM)
    SELECT AG_ID, SD_ID, SD_TYPE, SD_STATE, RQ_ID, CU_ID, AS_ID, SD_COMMENT,
           SD_SUM, SD_PERCENT, SD_SUM_DEFAULT, SD_PERCENT_DEFAULT, SD_SKIDKA,
           PT_ID, SD_SETTING_SUM_AND_PERCENT, GZ_ID, SD_SUM_PAYED, SD_ALL_PAYED,
           SD_COMMENT_SHORT, SD_IS_CHANGED_COPY_OF_SD_ID, SD_ID_COMPOUND, SD_PAY_NOW,
           SD_FACT_NUM, SD_KA_START_DATE, SD_KA_END_DATE, SD_FACT_DATE, SD_DATE,
           SD_PERCENT_SUM, SD_PERCENT_GIVEN, SD_TO_GIVE_PERCENT, SD_APPROVED_DATE,
           SD_IS_BEZNAL_V_NAL, SD_PAY_DATE, SD_NEW_CUST, SD_PERCENT_SUM_TO_GIVE,
           SD_SHOW_CUST_ID, SD_IS_IMPORTANT_FOR_SITE,
           SD_PAY_VER, SD_NUM
    FROM SDELKA s
    WHERE s.AG_ID=:AG_ID AND s.SD_ID=:SD_ID;

    /*
    INSERT INTO SDELKA_DELETED
"Exceptions"    SELECT * FROM SDELKA
    WHERE AG_ID=:AG_ID AND SD_ID=:SD_ID;
    */

    DELETE FROM SDELKA
    WHERE AG_ID=:AG_ID AND SD_ID=:SD_ID;

    INSERT INTO LOG(LG_COMMENT)
    VALUES(:COMMENT);
END^


ALTER PROCEDURE DROP_CHANGES_IN_SDELKA (
    AG_ID INTEGER,
    SD_ID INTEGER,
    US_ID INTEGER)
AS
DECLARE VARIABLE PREV_SD_ID INTEGER;
DECLARE VARIABLE CURR_AS_ID INTEGER;
BEGIN
/* В параметрах передаются "координаты" удаляемой
   измененной копии
*/

/* Проверяем, передали ли нам координаты копии или ошиблись
*/
    select AS_ID
    from SDELKA
    where     AG_ID = :AG_ID
          and SD_ID = :SD_ID
    into :CURR_AS_ID;
    
    if (CURR_AS_ID = 2) then
    begin
/* узнаем номер сделки, копию которой удаляем */
        select s.SD_IS_CHANGED_COPY_OF_SD_ID
        from SDELKA s
        where     s.AG_ID = :AG_ID
              and s.SD_ID = :SD_ID
        into :PREV_SD_ID;
    
        update SDELKA
        set AS_ID = 0
        where     AG_ID = :AG_ID
              and SD_ID = :PREV_SD_ID;
        
        delete from SDELKA
        where     AG_ID = :AG_ID
              and SD_ID = :SD_ID;
    end

    execute procedure LOG_SDELKA_CHANGES(:AG_ID, :SD_ID, :US_ID);
    
    suspend;
END^


ALTER PROCEDURE EVENT_CHANGE (
    EV_ID INTEGER)
AS
begin
  /* Procedure Text */
  if (ev_id = 1) then
  begin
      POST_EVENT 'TEXT_CHANGED';
  end
  else if (ev_id = 2) then
  begin
      post_event 'MODULE_CHANGED';
  end
end^


ALTER PROCEDURE EXPORT_XML (
    GZ_ID INTEGER)
RETURNS (
    OBJAV_TEXT VARCHAR(2047),
    OBJAV_ID INTEGER,
    RUBRIKA_ID INTEGER,
    RUBRIKA_NAME VARCHAR(128),
    ISS_NAME VARCHAR(10),
    SITE_VACANCY_NAME VARCHAR(128),
    SITE_EMAIL VARCHAR(128),
    SITE_TEL VARCHAR(128),
    SITE_CONTACT VARCHAR(255),
    SITE_DONT_UPLOAD SMALLINT,
    SITE_ZP INTEGER,
    GZ_RB_ID INTEGER,
    K INTEGER,
    SITE_EMPLOYER VARCHAR(255),
    C_NAME VARCHAR(128),
    ED_NAME VARCHAR(32),
    EX_NAME VARCHAR(32),
    CU_COMPANY_ID INTEGER,
    CU_ADDRESS VARCHAR(255),
    EXP_DATE TIMESTAMP,
    PT_ID INTEGER,
    PD_ID INTEGER)
AS
declare variable ISS_FOR_SELECT smallint;
declare variable I integer;
declare variable AG_ID integer;
declare variable SD_ID integer;
declare variable MAX_IS_ID integer;
begin
    i = 0;
   -- delete from internet i where i.OBJAV_ID > 0;
    FOR SELECT g.GZ_ID FROM gazeta g WHERE g.GZ_ID IN (1,3) INTO :GZ_ID DO
    BEGIN
         SELECT ci.IS_ID
         FROM GET_CURRENT_ISSUE(:gz_id) ci
         INTO :ISS_FOR_SELECT;

         SELECT i.IS_NAME FROM issue i WHERE i.IS_ID = :ISS_FOR_SELECT INTO :ISS_NAME;

         FOR
               SELECT
                    o.RB_ID
                    ,CAST(so.SITE_OBJAV_TEXT AS VARCHAR(2047)) AS OB_TEXT
                    ,so.SITE_OBJAV_ID
                    ,o.RS_ID
                    ,rs.RS_NAME
                    ,so.SITE_VACANCY_NAME
                    ,so.SITE_EMAIL
                    ,so.SITE_TEL
                    ,so.SITE_CONTACT
                    ,so.SITE_DONT_UPLOAD
                    ,so.SITE_ZP
                    ,so.SITE_EMPLOYER
                    ,c.C_NAME
                    ,ed.ED_NAME
                    ,ex.EX_NAME
                    ,cus.CU_COMPANY_ID
                    ,so.CU_ADDRESS
                    ,p.AG_ID
                    ,p.SD_ID
                    ,s.PT_ID
                    ,p.PD_ID
                    ,1
                FROM
                    PODACHA p
                    LEFT JOIN OBJAV o ON (o.AG_ID = p.AG_ID AND o.SD_ID = p.SD_ID)
                    LEFT JOIN SITE_OBJAV so ON (so.OB_ID = o.OB_ID)
                    LEFT JOIN RUBRIKA_SITE rs ON (rs.RS_ID = so.RS_ID)
                    LEFT JOIN sdelka s ON (s.AG_ID = p.AG_ID AND s.SD_ID = p.SD_ID)
                    LEFT JOIN city c ON(c.C_ID = so.C_ID)
                    LEFT JOIN EDUCATION ed ON(ed.ED_ID = so.ED_ID)
                    LEFT JOIN EXPERIENCE ex ON (ex.EX_ID = so.EX_ID)
                    LEFT JOIN CUST cus ON (cus.AG_ID = s.AG_ID AND cus.CU_ID = s.CU_ID)
                WHERE
                    p.IS_ID = :iss_for_select
                AND so.SITE_OBJAV_TEXT <> ''
                AND s.GZ_ID = 1
              --  AND   so.SITE_OBJAV_ID in (326804, 329570)
                UNION
                SELECT
                    ob.RB_ID
                    ,CAST(so.SITE_OBJAV_TEXT AS VARCHAR(2047)) AS OB_TEXT
                    ,so.SITE_OBJAV_ID
                    ,so.RS_ID
                    ,rs.RS_NAME
                    ,so.SITE_VACANCY_NAME
                    ,so.SITE_EMAIL
                    ,so.SITE_TEL
                    ,so.SITE_CONTACT
                    ,so.SITE_DONT_UPLOAD
                    ,so.SITE_ZP
                    ,so.SITE_EMPLOYER
                    ,c.C_NAME
                    ,ed.ED_NAME
                    ,ex.EX_NAME
                    ,cus.CU_COMPANY_ID
                    ,so.CU_ADDRESS
                    ,p.AG_ID
                    ,p.SD_ID
                    ,s.PT_ID
                    ,p.PD_ID
                    ,2
                FROM podacha p
                    LEFT JOIN OBJAVLENIE ob ON (ob.PD_ID = p.PD_ID)
                    LEFT JOIN SITE_OBJAV so ON(so.CONTENT_ID = ob.CONTENT_ID)
                    LEFT JOIN RUBRIKA_SITE rs ON(rs.RS_ID = so.RS_ID)
                    LEFT JOIN sdelka s ON (s.AG_ID = p.AG_ID AND s.SD_ID = p.SD_ID)
                    LEFT JOIN city c ON(c.C_ID = so.C_ID)
                    LEFT JOIN EDUCATION ed ON(ed.ED_ID = so.ED_ID)
                    LEFT JOIN EXPERIENCE ex ON (ex.EX_ID = so.EX_ID)
                    LEFT JOIN CUST cus ON (cus.AG_ID = s.AG_ID AND cus.CU_ID = s.CU_ID)
                WHERE p.IS_ID = :iss_for_select
                AND   s.PT_ID <> 3      /* В модулях если сделки кредитные
                                           агенты создают дубли и чтоб они не попадали
                                           в интернет игнорим кредитные напр. 203-687860, 203-687756
                                         */
                AND   s.GZ_ID = 1
                AND   so.SITE_OBJAV_TEXT <> ''
             --   AND   so.SITE_OBJAV_ID in (326804, 329570)
                INTO
                     :GZ_RB_ID
                    ,:OBJAV_TEXT
                    ,:OBJAV_ID
                    ,:RUBRIKA_ID
                    ,:RUBRIKA_NAME
                    ,:SITE_VACANCY_NAME
                    ,:SITE_EMAIL
                    ,:SITE_TEL
                    ,:SITE_CONTACT
                    ,:SITE_DONT_UPLOAD
                    ,:SITE_ZP
                    ,:SITE_EMPLOYER
                    ,:C_NAME
                    ,:ED_NAME
                    ,:EX_NAME
                    ,:CU_COMPANY_ID
                    ,:CU_ADDRESS
                    ,:AG_ID
                    ,:SD_ID
                    ,:PT_ID
                    ,:PD_ID
                    ,:K

                DO BEGIN
                     SELECT MAX(p.IS_ID) FROM podacha p WHERE p.AG_ID = :AG_ID AND p.SD_ID = :SD_ID INTO :MAX_IS_ID;
                     SELECT i.IS_DATE + 7 FROM issue i WHERE i.IS_ID = :MAX_IS_ID INTO :EXP_DATE;

                     SUSPEND;
                END
            i = i + 1;
    END
end^


ALTER PROCEDURE EXTRACT_VIP_MODULES
RETURNS (
    AG_NAME VARCHAR(128),
    AG_ID INTEGER,
    SD_ID INTEGER,
    CU_NAME VARCHAR(128),
    SD_DATE TIMESTAMP,
    FM_NAME VARCHAR(128),
    RB_NAME VARCHAR(128),
    PT_NAME VARCHAR(64),
    SD_ALL_PAYED INTEGER,
    GZ_NAME VARCHAR(64),
    GZ_ID INTEGER,
    CONTENT_ID INTEGER,
    PODACHA_NUMS VARCHAR(128),
    RB_ID INTEGER)
AS
declare variable CURRENT_IS_ID integer;
declare variable PREV_IS_ID integer;
begin
  /* Procedure Text */
  FOR SELECT g.gz_id, g.gz_name FROM gazeta g INTO :gz_id, :gz_name DO
  BEGIN
       EXECUTE PROCEDURE GET_CURRENT_ISSUE(:GZ_ID)
       RETURNING_VALUES :CURRENT_IS_ID;
        
       SELECT MAX(i.is_id)
       FROM issue i
       WHERE i.gz_id = :gz_id and i.is_id < :current_is_id
       INTO :prev_is_id;

       FOR SELECT
            a.ag_name,  -- Имя агента
            m.ag_id,    -- ИД агента
            m.sd_id,    -- ИД сделки
            c.cu_name,  -- Клиент
            s.sd_date,  -- Дата сделки
            f.fm_name,  -- формат
            r.rb_name,  -- рубрика
            pt.pt_name,  -- тип оплаты
            s.sd_all_payed, -- флаг полной оплаты
            m.content_id,
            spn.podacha_nums,
            r.rb_id
           -- oc.content_picture  -- картинка
        FROM
            MODULI_V_NOMER_NOMER(:PREV_IS_ID) m

            LEFT JOIN sdelka_podacha_nums(m.ag_id, m.sd_id) spn ON (spn.sd_id = m.sd_id)
        
            LEFT JOIN agent a ON (a.ag_id = m.ag_id)
        
            LEFT JOIN sdelka s ON (s.ag_id = m.ag_id AND s.sd_id = m.sd_id)
        
            LEFT JOIN cust c ON (c.cu_id = s.cu_id)
        
            LEFT JOIN format f ON (f.fm_id = m.fm_id)
        
            LEFT JOIN rubrika r ON (r.rb_id = m.rb_id)
        
            LEFT JOIN pay_type pt ON (pt.pt_id = s.pt_id)
        
        WHERE m.FM_ID = 15 AND m.CONTENT_ID IS NOT NULL
        INTO :ag_name, :ag_id, :sd_id, :cu_name, :sd_date, :fm_name, :rb_name, :pt_name, :sd_all_payed, :content_id, :podacha_nums,:rb_id DO SUSPEND;
   END
end^


ALTER PROCEDURE FILL_OBJAVS_TEMP
AS
DECLARE VARIABLE AGID INTEGER;
DECLARE VARIABLE SDID INTEGER;
DECLARE VARIABLE OBID INTEGER;
DECLARE VARIABLE AGOTKAZNIK INTEGER;
DECLARE VARIABLE OBTEXT VARCHAR(2047);
DECLARE VARIABLE PHNUMBER CHAR(16);
DECLARE VARIABLE ISID INTEGER;
DECLARE VARIABLE CNT INTEGER;
BEGIN
    DELETE FROM OBJAVS_TEMP;
    DELETE FROM objav_phones_reg_temp;

    execute procedure GET_CURRENT_ISSUE(1)
    returning_values :ISID;
    
    FOR
        SELECT
            OLN.AG_ID,OLN.SD_ID,OLN.OB_ID,OB.OB_TEXT
        FROM
            OBJAV_LIST_V_NOMER_ALL (:ISID) OLN

            LEFT JOIN OBJAV OB
            ON (OLN.AG_ID=OB.AG_ID AND OLN.SD_ID=OB.SD_ID AND OLN.OB_ID=OB.OB_ID)
        WHERE
            OB.OB_PARENT IS NULL
            AND
            OB.OB_TEXT IS NOT NULL
            AND
            OB.OB_TEXT<>''
        INTO
            :AGID,:SDID,:OBID,:OBTEXT
    DO
    BEGIN
        INSERT INTO OBJAVS_TEMP(AG_ID,SD_ID,OB_ID,OB_TEXT)
        VALUES (:AGID,:SDID,:OBID,:OBTEXT);

        FOR
            SELECT OBPH.PH_NUMBER
            FROM OBJAV_PHONES (:AGID,:SDID) OBPH
            INTO :PHNUMBER
        DO
        BEGIN
            INSERT INTO OBJAV_PHONES_REG_TEMP(AG_ID,SD_ID,OB_ID,OB_PHONE)
            VALUES (:AGID,:SDID,:OBID,:PHNUMBER);
        END
    END
END^


ALTER PROCEDURE FILL_OBJAVS_TEMP_OTKAZNIK
AS
BEGIN
    UPDATE OBJAV_PHONES_REG_TEMP OPRT
    SET AG_ID_OTKAZNIK=(
                       SELECT MAX(OT.AG_ID)
                       FROM OTKAZNIK OT
                       WHERE OT.OT_NUMBER=OPRT.OB_PHONE
                       );

    UPDATE OBJAV_PHONES_TEMP OPT
    SET AG_ID_OTKAZNIK=(
                       SELECT MAX(OT.AG_ID)
                       FROM OTKAZNIK OT
                       WHERE OT.OT_NUMBER=OPT.OB_PHONE
                       );
END^


ALTER PROCEDURE FIND_COPY (
    AG_ID INTEGER,
    SD_ID INTEGER)
RETURNS (
    COPY_SD_ID INTEGER)
AS
BEGIN
    select SD_ID
    from SDELKA s
    where     s.AG_ID = :AG_ID
          and s.AS_ID = 2
          and s.SD_IS_CHANGED_COPY_OF_SD_ID = :SD_ID
    into :COPY_SD_ID;

    if (COPY_SD_ID is null) then
        COPY_SD_ID = -1;

    suspend;
END^


ALTER PROCEDURE FIND_NOT_PAYED_SDELKA_BY_PHONE (
    PH_NUMBER_INPUT CHAR(16))
RETURNS (
    AG_ID INTEGER,
    SD_ID INTEGER)
AS
begin
    for
        select
              cp.AG_ID
            , sd.SD_ID
        from
            CUST_PHONE cp

            left join NOT_PAYED_SDELKA sd
            on (cp.AG_ID = sd.AG_ID and cp.CU_ID = sd.CU_ID)
        where
                cp.CP_NUMBER = :PH_NUMBER_INPUT
    and sd.SD_ID is not null
        into :AG_ID, :SD_ID
    do
    begin
        suspend;

        exit;
    end

    for
        select
              ph.AG_ID
            , ph.SD_ID
        from
            PHONE ph

            left join NOT_PAYED_SDELKA sd
            on (ph.AG_ID = sd.AG_ID and ph.SD_ID = sd.SD_ID)
        where
                ph.PH_NUMBER = :PH_NUMBER_INPUT
    and sd.SD_ID is not null
            into :AG_ID, :SD_ID
        do
        begin
            suspend;

            exit;
        end
end^


ALTER PROCEDURE FIND_SDELKA_BY_FACT_NUM (
    AG_ID_INPUT INTEGER,
    SD_FACT_NUM_INPUT INTEGER)
RETURNS (
    AG_ID INTEGER,
    SD_ID INTEGER,
    CU_ID INTEGER,
    CU_NAME VARCHAR(128),
    SD_ID_COMPOUND CHAR(12),
    PT_ID INTEGER,
    SD_ZAPAS INTEGER,
    AG_NAME VARCHAR(128),
    SD_LAST_ISSUE_IS_ID INTEGER,
    SD_LAST_ISSUE_IS_NAME VARCHAR(10),
    SD_FACT_NUM INTEGER,
    SD_ALL_PAYED INTEGER)
AS
declare variable SDID INTEGER;
BEGIN
    IF (AG_ID_INPUT<>-1) THEN
    BEGIN
        AG_ID=AG_ID_INPUT;

        FOR
            SELECT SD_ID FROM SDELKA
            WHERE AG_ID=:AG_ID_INPUT AND SD_FACT_NUM=:SD_FACT_NUM_INPUT AND SD_STATE<>100 AND AS_ID<>2
            INTO :SD_ID
        DO
        BEGIN
            EXECUTE PROCEDURE FIND_SDELKA_FIELDS(:AG_ID,:SD_ID)
            RETURNING_VALUES :CU_ID,:CU_NAME,:SD_ID_COMPOUND,:PT_ID,:SD_ZAPAS,:AG_NAME,:SD_LAST_ISSUE_IS_ID,:SD_LAST_ISSUE_IS_NAME,:SD_FACT_NUM,:SD_ALL_PAYED;

            SUSPEND;
        END
    END
    ELSE
    BEGIN
        FOR
            SELECT AG_ID,SD_ID FROM SDELKA
            WHERE SD_FACT_NUM=:SD_FACT_NUM_INPUT AND SD_STATE<>100 AND AS_ID<>2
            INTO :AG_ID,:SD_ID
        DO
        BEGIN
            EXECUTE PROCEDURE FIND_SDELKA_FIELDS(:AG_ID,:SD_ID)
            RETURNING_VALUES :CU_ID,:CU_NAME,:SD_ID_COMPOUND,:PT_ID,:SD_ZAPAS,:AG_NAME,:SD_LAST_ISSUE_IS_ID,:SD_LAST_ISSUE_IS_NAME,:SD_FACT_NUM,:SD_ALL_PAYED;

            SUSPEND;
        END
    END
END^


ALTER PROCEDURE FIND_SDELKA_BY_NUMBER (
    AG_ID_INPUT INTEGER,
    SD_ID_INPUT INTEGER)
RETURNS (
    AG_ID INTEGER,
    SD_ID INTEGER,
    CU_ID INTEGER,
    CU_NAME VARCHAR(128),
    SD_ID_COMPOUND CHAR(12),
    PT_ID INTEGER,
    SD_ZAPAS INTEGER,
    AG_NAME VARCHAR(128),
    SD_LAST_ISSUE_IS_ID INTEGER,
    SD_LAST_ISSUE_IS_NAME VARCHAR(10),
    SD_FACT_NUM INTEGER,
    SD_ALL_PAYED INTEGER)
AS
declare variable SDID INTEGER;
BEGIN
    IF (AG_ID_INPUT<>-1) THEN
    BEGIN
        AG_ID=AG_ID_INPUT;

        FOR
            SELECT SD_ID FROM SDELKA
            WHERE AG_ID=:AG_ID_INPUT AND SD_ID=:SD_ID_INPUT AND SD_STATE<>100 AND AS_ID<>2
            INTO :SD_ID
        DO
        BEGIN
            EXECUTE PROCEDURE FIND_SDELKA_FIELDS(:AG_ID,:SD_ID)
            RETURNING_VALUES :CU_ID,:CU_NAME,:SD_ID_COMPOUND,:PT_ID,:SD_ZAPAS,:AG_NAME,:SD_LAST_ISSUE_IS_ID,:SD_LAST_ISSUE_IS_NAME,:SD_FACT_NUM,:SD_ALL_PAYED;

            SUSPEND;
        END
    END
    ELSE
    BEGIN
        FOR
            SELECT AG_ID,SD_ID FROM SDELKA
            WHERE SD_ID=:SD_ID_INPUT AND SD_STATE<>100 AND AS_ID<>2
            INTO :AG_ID,:SD_ID
        DO
        BEGIN
            EXECUTE PROCEDURE FIND_SDELKA_FIELDS(:AG_ID,:SD_ID)
            RETURNING_VALUES :CU_ID,:CU_NAME,:SD_ID_COMPOUND,:PT_ID,:SD_ZAPAS,:AG_NAME,:SD_LAST_ISSUE_IS_ID,:SD_LAST_ISSUE_IS_NAME,:SD_FACT_NUM,:SD_ALL_PAYED;

            SUSPEND;
        END
    END
END^


ALTER PROCEDURE FIND_SDELKA_BY_OKPO (
    AG_ID_INPUT INTEGER,
    CU_OKPO CHAR(10))
RETURNS (
    AG_ID INTEGER,
    SD_ID INTEGER,
    CU_ID INTEGER,
    CU_NAME VARCHAR(128),
    SD_ID_COMPOUND CHAR(12),
    PT_ID INTEGER,
    SD_ZAPAS INTEGER,
    AG_NAME VARCHAR(128),
    SD_LAST_ISSUE_IS_ID INTEGER,
    SD_LAST_ISSUE_IS_NAME VARCHAR(10),
    SD_FACT_NUM INTEGER,
    SD_ALL_PAYED INTEGER)
AS
declare variable CUID INTEGER;
BEGIN
    if (AG_ID_INPUT <> -1) then
    begin
        AG_ID = AG_ID_INPUT;

        for
            select
                sd.SD_ID
            from
                CUST cu

                left join SDELKA sd
                on (sd.AG_ID = cu.AG_ID and sd.CU_ID = cu.CU_ID)
            where
                cu.AG_ID = :AG_ID
                and cu.CU_OKPO = :CU_OKPO
                and sd.SD_STATE <> 100
                and sd.AS_ID <> 2
            into :SD_ID
        do
        begin
            execute procedure FIND_SDELKA_FIELDS(:AG_ID, :SD_ID)
            returning_values :CU_ID, :CU_NAME, :SD_ID_COMPOUND, :PT_ID
                           , :SD_ZAPAS, :AG_NAME, :SD_LAST_ISSUE_IS_ID
                           , :SD_LAST_ISSUE_IS_NAME, :SD_FACT_NUM, :SD_ALL_PAYED;

            suspend;
        end
    end
    else
    begin
        for
            select
                  sd.AG_ID
                , sd.SD_ID
            from
                CUST cu
                
                left join SDELKA sd
                on (sd.AG_ID = cu.AG_ID and sd.CU_ID = cu.CU_ID)
            where
                cu.CU_OKPO = :CU_OKPO
                and sd.SD_STATE <> 100
                and sd.AS_ID <> 2
            into :AG_ID, :SD_ID
        do
        begin
            execute procedure FIND_SDELKA_FIELDS(:AG_ID,:SD_ID)
            returning_values :CU_ID, :CU_NAME, :SD_ID_COMPOUND, :PT_ID
                           , :SD_ZAPAS, :AG_NAME, :SD_LAST_ISSUE_IS_ID
                           , :SD_LAST_ISSUE_IS_NAME, :SD_FACT_NUM, :SD_ALL_PAYED;

            suspend;
        end
    END
END^


ALTER PROCEDURE FIND_SDELKA_BY_PHONE (
    AG_ID_INPUT INTEGER,
    PH_NUMBER_INPUT CHAR(16))
RETURNS (
    AG_ID INTEGER,
    SD_ID INTEGER,
    CU_ID INTEGER,
    CU_NAME VARCHAR(128),
    SD_ID_COMPOUND CHAR(12),
    PT_ID INTEGER,
    SD_ZAPAS INTEGER,
    AG_NAME VARCHAR(128),
    SD_LAST_ISSUE_IS_ID INTEGER,
    SD_LAST_ISSUE_IS_NAME VARCHAR(10),
    SD_FACT_NUM INTEGER,
    SD_ALL_PAYED INTEGER)
AS
DECLARE VARIABLE CUID INTEGER;
BEGIN
    if (AG_ID_INPUT <> -1) then
    begin
        AG_ID = AG_ID_INPUT;

        for
            select
                sd.SD_ID
            from
                PHONE ph

                left join SDELKA sd
                on (ph.AG_ID = sd.AG_ID and ph.SD_ID = sd.SD_ID)
            where
                ph.AG_ID = :AG_ID
                and ph.PH_NUMBER = :PH_NUMBER_INPUT
                and sd.SD_STATE <> 100
                and sd.AS_ID <> 2
            into :SD_ID
        do
        begin
            execute procedure FIND_SDELKA_FIELDS(:AG_ID, :SD_ID)
            returning_values :CU_ID, :CU_NAME, :SD_ID_COMPOUND, :PT_ID
                           , :SD_ZAPAS, :AG_NAME, :SD_LAST_ISSUE_IS_ID
                           , :SD_LAST_ISSUE_IS_NAME, :SD_FACT_NUM, :SD_ALL_PAYED;

            suspend;
        end

        for
            select
                sd.SD_ID
            from
                CUST_PHONE cp

                left join SDELKA sd
                on (sd.AG_ID = cp.AG_ID and sd.CU_ID = cp.CU_ID)
            where
                cp.AG_ID = :AG_ID
                and cp.CP_NUMBER = :PH_NUMBER_INPUT
                and sd.SD_STATE <> 100
                and sd.AS_ID <> 2
            plan
                join (CP index (IDX_CUST_PHONE),SD index (I_SDELKA_AG_CU))
            into :SD_ID
        do
        begin
            execute procedure FIND_SDELKA_FIELDS(:AG_ID,:SD_ID)
            returning_values :CU_ID, :CU_NAME, :SD_ID_COMPOUND, :PT_ID
                           , :SD_ZAPAS, :AG_NAME, :SD_LAST_ISSUE_IS_ID
                           , :SD_LAST_ISSUE_IS_NAME, :SD_FACT_NUM, :SD_ALL_PAYED;
            suspend;
        end
    end
    else
    begin
        for
            select
                  ph.AG_ID
                , ph.SD_ID
            from
                PHONE ph
                left join SDELKA sd
                on (sd.AG_ID = ph.AG_ID and sd.SD_ID = ph.SD_ID)
            where
                ph.PH_NUMBER = :PH_NUMBER_INPUT
                and sd.SD_STATE <> 100
                and sd.AS_ID <> 2
            into :AG_ID, :SD_ID
        do
        begin
            execute procedure FIND_SDELKA_FIELDS(:AG_ID,:SD_ID)
            returning_values :CU_ID, :CU_NAME, :SD_ID_COMPOUND, :PT_ID
                           , :SD_ZAPAS, :AG_NAME, :SD_LAST_ISSUE_IS_ID
                           , :SD_LAST_ISSUE_IS_NAME, :SD_FACT_NUM, :SD_ALL_PAYED;

            suspend;
        end

        for
            select
                  sd.AG_ID
                , sd.SD_ID
            from
                CUST_PHONE cp

                left join SDELKA sd
                on (sd.AG_ID = cp.AG_ID and sd.CU_ID = cp.CU_ID)
            where
                cp.CP_NUMBER = :PH_NUMBER_INPUT
                and sd.SD_STATE <> 100
                and sd.AS_ID <> 2
            plan
                join (CP index (IDX_CUST_PHONE),SD index (I_SDELKA_AG_CU))
            into
                :AG_ID, :SD_ID
        do
        begin
                execute procedure FIND_SDELKA_FIELDS(:AG_ID, :SD_ID)
                returning_values :CU_ID, :CU_NAME, :SD_ID_COMPOUND, :PT_ID
                               , :SD_ZAPAS, :AG_NAME, :SD_LAST_ISSUE_IS_ID
                               , :SD_LAST_ISSUE_IS_NAME, :SD_FACT_NUM, :SD_ALL_PAYED;

                suspend;
        end
    END
END^


ALTER PROCEDURE FIND_SDELKA_BY_PHONE_AND_AGENT (
    AG_ID_INPUT INTEGER,
    PH_NUMBER_INPUT CHAR(16))
RETURNS (
    SD_ID INTEGER)
AS
DECLARE VARIABLE CU_ID INTEGER;
BEGIN
        FOR
            SELECT SD_ID FROM PHONE
            WHERE AG_ID=:AG_ID_INPUT AND PH_NUMBER=:PH_NUMBER_INPUT
            INTO :SD_ID
        DO
        BEGIN
            FOR
                SELECT SD_ID FROM SDELKA
                WHERE AG_ID=:AG_ID_INPUT AND SD_ID=:SD_ID AND SD_STATE<>100 AND AS_ID<>2
                INTO :SD_ID
            DO
                SUSPEND;
        END

        FOR
            SELECT CU_ID FROM CUST_PHONE
            WHERE AG_ID=:AG_ID_INPUT AND CP_NUMBER=:PH_NUMBER_INPUT
            INTO :CU_ID
        DO
        BEGIN
            FOR
                SELECT SD_ID FROM SDELKA
                WHERE AG_ID=:AG_ID_INPUT AND CU_ID=:CU_ID AND SD_STATE<>100 AND AS_ID<>2
                INTO :SD_ID
            DO
                SUSPEND;
        END
/*        FOR
            SELECT
                PH.SD_ID
            FROM
                PHONE PH,SDELKA SD
            WHERE
                PH.AG_ID=:AG_ID_INPUT AND
                PH.AG_ID=SD.AG_ID AND
                PH.SD_ID=SD.SD_ID AND
                PH.PH_NUMBER=:PH_NUMBER_INPUT AND
                SD.SD_STATE<>100 AND
                SD.AS_ID<>2
            INTO :SD_ID
        DO
        BEGIN
            SUSPEND;
        END

        FOR
            SELECT
                SD.SD_ID
            FROM
                CUST_PHONE CP,SDELKA SD
            WHERE
                CP.AG_ID=:AG_ID_INPUT AND
                CP.AG_ID=SD.AG_ID AND
                CP.CU_ID=SD.CU_ID AND
                CP.CP_NUMBER=:PH_NUMBER_INPUT AND
                SD.SD_STATE<>100 AND
                SD.AS_ID<>2
            INTO :SD_ID
        DO
        BEGIN
            SUSPEND;
        END
*/
END^


ALTER PROCEDURE FIND_SDELKA_BY_PHONE_SIMPLE (
    PH_NUMBER_INPUT CHAR(16))
RETURNS (
    AG_ID INTEGER,
    SD_ID INTEGER)
AS
BEGIN
        FOR
            select
                ph.AG_ID,
                ph.SD_ID
            from
                PHONE ph

                left join SDELKA sd
                on (ph.AG_ID = sd.AG_ID and ph.SD_ID = sd.SD_ID)
            where
                ph.PH_NUMBER = :PH_NUMBER_INPUT and
                sd.SD_STATE <> 100 and
                sd.AS_ID <> 2
            into :AG_ID, :SD_ID
        DO
        BEGIN
            SUSPEND;
        END

        FOR
            select
                cp.AG_ID,
                sd.SD_ID
            from
                CUST_PHONE cp

                left join SDELKA sd
                on (cp.AG_ID = sd.AG_ID and cp.CU_ID = sd.CU_ID)
            where
                cp.CP_NUMBER = :PH_NUMBER_INPUT and
                sd.SD_STATE <> 100 and
                sd.AS_ID <> 2
            plan
                join (CP index (IDX_CUST_PHONE),SD index (I_SDELKA_AG_CU))
            into :AG_ID, :SD_ID
        DO
        BEGIN
            SUSPEND;
        END
END^


ALTER PROCEDURE FIND_SDELKA_BY_SDNUM2 (
    SD_NUM VARCHAR(128))
RETURNS (
    AG_ID INTEGER,
    SD_ID INTEGER,
    CU_ID INTEGER,
    CU_NAME VARCHAR(128),
    SD_ID_COMPOUND CHAR(12),
    PT_ID INTEGER,
    SD_ZAPAS INTEGER,
    AG_NAME VARCHAR(128),
    SD_LAST_ISSUE_IS_ID INTEGER,
    SD_LAST_ISSUE_IS_NAME VARCHAR(10),
    SD_FACT_NUM INTEGER,
    SD_ALL_PAYED INTEGER)
AS
BEGIN
        FOR
            SELECT AG_ID, SD_ID FROM SDELKA
            WHERE SD_NUM LIKE '%' || :SD_NUM AND SD_STATE<>100 AND AS_ID<>2
            INTO :AG_ID, :SD_ID
        DO
        BEGIN
            EXECUTE PROCEDURE FIND_SDELKA_FIELDS(:AG_ID,:SD_ID)
            RETURNING_VALUES :CU_ID,:CU_NAME,:SD_ID_COMPOUND,:PT_ID,:SD_ZAPAS,:AG_NAME,:SD_LAST_ISSUE_IS_ID,:SD_LAST_ISSUE_IS_NAME,:SD_FACT_NUM,:SD_ALL_PAYED;

            SUSPEND;
        END
END^


ALTER PROCEDURE FIND_SDELKA_BY_TEXT (
    AG_ID_INPUT INTEGER,
    OB_TEXT_INPUT VARCHAR(127),
    IS_ID_INPUT INTEGER)
RETURNS (
    AG_ID INTEGER,
    SD_ID INTEGER,
    CU_ID INTEGER,
    CU_NAME VARCHAR(128),
    SD_ID_COMPOUND CHAR(12),
    PT_ID INTEGER,
    SD_ZAPAS INTEGER,
    AG_NAME VARCHAR(128),
    SD_LAST_ISSUE_IS_ID INTEGER,
    SD_LAST_ISSUE_IS_NAME VARCHAR(10),
    SD_FACT_NUM INTEGER,
    SD_ALL_PAYED INTEGER)
AS
declare variable SDID INTEGER;
BEGIN
    IF (AG_ID_INPUT<>-1) THEN
    BEGIN
        AG_ID=AG_ID_INPUT;

        FOR
            SELECT
                  DISTINCT OB.SD_ID
            FROM
                (
                    PODACHA PD LEFT JOIN
                    OBJAV OB
                    ON (PD.AG_ID=OB.AG_ID AND PD.SD_ID=OB.SD_ID)
                )
                LEFT JOIN SDELKA SD
                ON (OB.AG_ID=SD.AG_ID AND OB.SD_ID=SD.SD_ID)
            WHERE
                PD.IS_ID=:IS_ID_INPUT AND OB.AG_ID=:AG_ID_INPUT AND OB_TEXT CONTAINING :OB_TEXT_INPUT AND SD_STATE<>100 AND AS_ID<>2
            INTO
                :SD_ID
        DO
        BEGIN
            EXECUTE PROCEDURE FIND_SDELKA_FIELDS(:AG_ID,:SD_ID)
            RETURNING_VALUES :CU_ID,:CU_NAME,:SD_ID_COMPOUND,:PT_ID,:SD_ZAPAS,:AG_NAME,:SD_LAST_ISSUE_IS_ID,:SD_LAST_ISSUE_IS_NAME,:SD_FACT_NUM,:SD_ALL_PAYED;

            SUSPEND;
        END
    END
    ELSE
    BEGIN
        FOR
            SELECT
                DISTINCT OB.AG_ID,
                OB.SD_ID
            FROM
                (
                    PODACHA PD LEFT JOIN
                    OBJAV OB
                    ON (PD.AG_ID=OB.AG_ID AND PD.SD_ID=OB.SD_ID)
                )
                LEFT JOIN SDELKA SD
                ON (OB.AG_ID=SD.AG_ID AND OB.SD_ID=SD.SD_ID)
            WHERE
                PD.IS_ID=:IS_ID_INPUT AND OB_TEXT CONTAINING :OB_TEXT_INPUT AND SD_STATE<>100 AND AS_ID<>2
            INTO
                :AG_ID,:SD_ID
        DO
        BEGIN
            EXECUTE PROCEDURE FIND_SDELKA_FIELDS(:AG_ID,:SD_ID)
            RETURNING_VALUES :CU_ID,:CU_NAME,:SD_ID_COMPOUND,:PT_ID,:SD_ZAPAS,:AG_NAME,:SD_LAST_ISSUE_IS_ID,:SD_LAST_ISSUE_IS_NAME,:SD_FACT_NUM,:SD_ALL_PAYED;

            SUSPEND;
        END
    END
END^


ALTER PROCEDURE FIND_SDELKA_FIELDS (
    AG_ID_INPUT INTEGER,
    SD_ID_INPUT INTEGER)
RETURNS (
    CU_ID INTEGER,
    CU_NAME VARCHAR(128),
    SD_ID_COMPOUND CHAR(12),
    PT_ID INTEGER,
    SD_ZAPAS INTEGER,
    AG_NAME VARCHAR(128),
    SD_LAST_ISSUE_IS_ID INTEGER,
    SD_LAST_ISSUE_IS_NAME VARCHAR(10),
    SD_FACT_NUM INTEGER,
    SD_ALL_PAYED INTEGER)
AS
begin
    select
          sd.CU_ID
        , sd.SD_ID_COMPOUND
        , sd.PT_ID
        , sd.SD_FACT_NUM
        , sd.SD_ALL_PAYED
        , cu.CU_NAME
        , ag.AG_NAME
        , (
              select max(IS_ID) from PODACHA pd2
              where pd2.AG_ID = :AG_ID_INPUT and pd2.SD_ID = :SD_ID_INPUT
          ) as SD_LAST_ISSUE_IS_ID
    from
        SDELKA sd

        left join CUST cu on (cu.AG_ID = :AG_ID_INPUT and cu.CU_ID=sd.CU_ID)

        left join AGENT ag on (ag.AG_ID = :AG_ID_INPUT)
    where
            sd.SD_ID = :SD_ID_INPUT
        and sd.AG_ID = :AG_ID_INPUT
    into
          :CU_ID
        , :SD_ID_COMPOUND
        , :PT_ID
        , :SD_FACT_NUM
        , :SD_ALL_PAYED
        , :CU_NAME
        , :AG_NAME
        , :SD_LAST_ISSUE_IS_ID;


    select iss.IS_NAME from ISSUE iss
    where iss.IS_ID = :SD_LAST_ISSUE_IS_ID
    into :SD_LAST_ISSUE_IS_NAME;

    select count(1) from PODACHA pd
    where pd.AG_ID = :AG_ID_INPUT and pd.SD_ID = :SD_ID_INPUT  and pd.IS_ID=0
    into :SD_ZAPAS;


    SUSPEND;
END^


ALTER PROCEDURE FOR_1C (
    DATE_FROM TIMESTAMP,
    DATE_TO TIMESTAMP,
    ONLY_NOT_PAYED INTEGER)
RETURNS (
    FACT_NUM INTEGER,
    FACT_DATE TIMESTAMP,
    AGENT_ID INTEGER,
    OBJAV_ID INTEGER,
    GAZETA_ID INTEGER,
    GAZETA_NAM CHAR(32),
    NOMERA CHAR(64),
    RUBRIKA_ID INTEGER,
    RUBRIKA_NA CHAR(32),
    FORMAT_ID INTEGER,
    FORMAT_NAM CHAR(32),
    COST FLOAT,
    PAYED FLOAT,
    PAYTYPE_ID INTEGER,
    PAYTYPE_NA CHAR(64),
    CUST_OKPO CHAR(12),
    CUST_NAME CHAR(64))
AS
declare variable SDTYPE integer;
BEGIN

    FOR
        SELECT
            SDR.SD_FACT_NUM,    /* номер счета-фактуры */
            SDR.SD_FACT_DATE,   /* дата счета-фактуры */
            SDR.AG_ID,          /* ID агента */
            SDR.SD_ID,          /* ID объявления */
            SDR.GZ_ID,          /* ID газеты */
            GZ.GZ_NAME,         /* название газеты */
            1,          /* ID рубрики */
            'Рубрика',         /* название рубрики */
            1,          /* ID формата объявления */
            'Формат',         /* название формата объявления */
            SDR.SD_SUM,         /* стоимость объявления */
            SDR.SD_SUM_PAYED,   /* оплаченная сумма */
            SDR.PT_ID,          /* ID формы оплаты */
            PT.PT_NAME,         /* название формы оплаты */
            LEFT(CU.CU_OKPO,12),         /* ОКПО клиента */
            LEFT(CU.CU_NAME,64),          /* название клиента */
            SDR.SD_TYPE
        FROM
            SDELKA_REAL SDR
            LEFT JOIN GAZETA GZ
            ON (SDR.GZ_ID=GZ.GZ_ID)
            LEFT JOIN PAY_TYPE PT
            ON (SDR.PT_ID=PT.PT_ID)
            LEFT JOIN CUST CU
            ON (SDR.AG_ID=CU.AG_ID AND SDR.CU_ID=CU.CU_ID)
            LEFT JOIN SDELKA SD
            ON (SD.AG_ID=SDR.AG_ID AND SD.SD_ID=SDR.SD_ID)
        WHERE
            SDR.SD_FACT_NUM IS NOT NULL AND
            CAST(SDR.SD_FACT_DATE AS DATE)>=:DATE_FROM AND
            CAST(SDR.SD_FACT_DATE AS DATE)<=:DATE_TO AND
            (:ONLY_NOT_PAYED=0 OR SDR.SD_ALL_PAYED=0 OR SDR.SD_ALL_PAYED IS NULL)
        ORDER BY
            SDR.SD_DATE
        INTO
            :FACT_NUM,
            :FACT_DATE,
            :AGENT_ID,
            :OBJAV_ID,
            :GAZETA_ID,
            :GAZETA_NAM,
            :RUBRIKA_ID,
            :RUBRIKA_NA,
            :FORMAT_ID,
            :FORMAT_NAM,
            :COST,
            :PAYED,
            :PAYTYPE_ID,
            :PAYTYPE_NA,
            :CUST_OKPO,
            :CUST_NAME,
            :sdtype
    DO
    BEGIN
        /* номера газет, где выходит объявление */
        SELECT LEFT(PODACHA_NUMS,64)
        FROM SDELKA_PODACHA_NUMS(:AGENT_ID,:OBJAV_ID)
        INTO :NOMERA;

        IF (sdtype = 3) THEN
        BEGIN
            GAZETA_ID = 6;
            GAZETA_NAM = 'КА';
        END
        ELSE IF (sdtype = 4) THEN
        BEGIN
            GAZETA_ID = 7;
            GAZETA_NAM = 'Интернет';
        END
        ELSE IF (sdtype = 5) THEN
        BEGIN
            GAZETA_ID = 8;
            GAZETA_NAM = 'Др. город';
        END
        ELSE IF (sdtype = 6) THEN
        BEGIN
            GAZETA_ID = 9;
            GAZETA_NAM = '';
/*            IF (l1 is not null and l1 > 0) then
              GAZETA_NAM = GAZETA_NAM || '[1=' || l1 || ']';
            IF (l2 is not null and l2 > 0) then
              GAZETA_NAM = GAZETA_NAM || '[2=' || l2 || ']';
            IF (l3 is not null and l3 > 0) then
              GAZETA_NAM = GAZETA_NAM || '[3=' || l3 || ']';
            IF (l4 is not null and l4 > 0) then
              GAZETA_NAM = GAZETA_NAM || '[4=' || l4 || ']';
*/
        END

        SUSPEND;
    END
END^


ALTER PROCEDURE FOR_1C_2_SDELKA (
    DATE_FROM TIMESTAMP,
    DATE_TO TIMESTAMP,
    ONLY_NOT_PAYED INTEGER)
RETURNS (
    FAC_NUM INTEGER,
    FAC_DATE TIMESTAMP,
    COST FLOAT,
    PAYED FLOAT,
    CUS_OKPO CHAR(12),
    CUS_NAME CHAR(64))
AS
begin
    for
        select
             sdr.SD_FACT_NUM            /* номер счета-фактуры */
            ,sdr.SD_FACT_DATE           /* дата счета-фактуры */
            ,sum(sdr.SD_SUM)            /* стоимость объявления */
            ,sum(sdr.SD_SUM_PAYED)      /* оплачено */
            ,left(cu.CU_OKPO, 12)     /* ОКПО клиента */
            ,left(cu.CU_NAME, 64)     /* название клиента */
        from
            SDELKA_REAL sdr

            left join CUST cu on (sdr.AG_ID = cu.AG_ID and sdr.CU_ID = 
cu.CU_ID)
        where
                sdr.SD_FACT_NUM is not null
            and cast(sdr.SD_FACT_DATE as date) >= :DATE_FROM
            and cast(sdr.SD_FACT_DATE as date) <= :DATE_TO
            and (:ONLY_NOT_PAYED = 0 or sdr.SD_ALL_PAYED = 0 or 
sdr.SD_ALL_PAYED is null)
        group by
             sdr.SD_FACT_NUM
            ,sdr.SD_FACT_DATE
            ,left(cu.CU_OKPO, 12)
            ,left(cu.CU_NAME, 64)
        order by
            sdr.SD_FACT_NUM
        into
             :FAC_NUM
            ,:FAC_DATE
            ,:COST
            ,:PAYED
            ,:CUS_OKPO
            ,:CUS_NAME
    do
        suspend;
end^


ALTER PROCEDURE FOR_1C_2_SERVICE (
    DATE_FROM TIMESTAMP,
    DATE_TO TIMESTAMP,
    ONLY_NOT_PAYED INTEGER)
RETURNS (
    FAC_NUM INTEGER,
    FAC_DATE TIMESTAMP,
    SERV_ID INTEGER,
    DESCRIPT VARCHAR(200),
    COST FLOAT)
AS
declare variable AGID integer;
declare variable SDID integer;
declare variable SD_TYPE integer;
declare variable PODACHA_NUMS varchar(128);
declare variable ONEISNAME varchar(10);
declare variable PDCOUNT integer;
declare variable SRAMOUNT integer;
declare variable SERVTYPE integer;
declare variable GZID integer;
declare variable SKIP_SERV smallint;
declare variable SDSUM float;
declare variable SRDESC varchar(1024);
declare variable SDCOUNT integer;
declare variable INSTANCEID integer;
begin
    select p.pm_app_instance_no
    from params p
    into :instanceid;

    for
        select
             sdr.AG_ID
            ,sdr.SD_TYPE
            ,sdr.SD_FACT_NUM
            ,sdr.SD_FACT_DATE
            ,sdr.GZ_ID
            ,sum(sdr.SD_SUM) as SD_SUM
            ,count(*)
        from
            SDELKA_REAL sdr
        where
                sdr.SD_FACT_NUM is not null
            and cast(sdr.SD_FACT_DATE as date) >= :DATE_FROM
            and cast(sdr.SD_FACT_DATE as date) <= :DATE_TO
            and (:ONLY_NOT_PAYED = 0 or sdr.SD_ALL_PAYED = 0
                 or sdr.SD_ALL_PAYED is null)
        group by
             sdr.AG_ID
            ,sdr.SD_TYPE
            ,sdr.SD_FACT_NUM
            ,sdr.SD_FACT_DATE
            ,sdr.GZ_ID
        order by
             sdr.SD_FACT_NUM
            ,sdr.SD_FACT_DATE
        into
             :AGID
            ,:SD_TYPE
            ,:FAC_NUM
            ,:FAC_DATE
            ,:GZID
            ,:SDSUM
            ,:SDCOUNT
    do
    begin
        if (SD_TYPE = 1) then
        begin
            -- Об'ява до газети "Пропоную роботу"
            if (GZID = 1) then
                SERV_ID = 1;
            -- Об'ява до газети "Пропоную оголошення"
            if (GZID = 2) then
                SERV_ID = 8;
            -- Об'ява до газети "Срочно требуются"
            if (GZID = 3) then
            begin
                -- "Срочно требуются"
                if (instanceid = 1) then
                    SERV_ID = 2;
                else
                -- "Пропоную оголошення"
                    SERV_ID = 8;
            end
            -- Об'ява до газети "Робота для жiнок"
            if (GZID = 4) then
                SERV_ID = 4;
            -- Об'ява до газети "Работа в Киеве"
            if (GZID = 5) then
                SERV_ID = 15;    --08.06.2011
            --   SERV_ID = 1;  -- was changed

            -- Подачи
            PODACHA_NUMS = '';
            PDCOUNT = 0;
            for
                select
                    distinct iss.IS_NAME
                from
                    SDELKA_REAL sdr

                    left join PODACHA pd
                    on (pd.AG_ID = sdr.AG_ID and pd.SD_ID = sdr.SD_ID)

                    left join ISSUE iss
                    on (iss.IS_ID = pd.IS_ID and iss.GZ_ID = pd.GZ_ID)
                where
                        sdr.AG_ID = :AGID
                    and sdr.SD_TYPE = :SD_TYPE
                    and sdr.SD_FACT_NUM = :FAC_NUM
                    and sdr.SD_FACT_DATE = :FAC_DATE
                    and sdr.GZ_ID = :GZID
                    and (:ONLY_NOT_PAYED = 0
                         or sdr.SD_ALL_PAYED = 0
                         or sdr.SD_ALL_PAYED is null)
                    and iss.IS_NAME is not null
                order by
                    iss.IS_DATE
                into
                    :ONEISNAME
            do
            begin
                PDCOUNT = PDCOUNT + 1;
                if (PODACHA_NUMS <> '') then
                    PODACHA_NUMS = PODACHA_NUMS || ',';
                PODACHA_NUMS = left(PODACHA_NUMS || ONEISNAME, 110);
            end

            if (CHAR_LENGTH(PODACHA_NUMS) >= 110) then
                PODACHA_NUMS = PODACHA_NUMS || '...';

            -- Форматы
            /*
            FMNAME = '';
            for
                select
                    distinct fm.FM_NAME
                from
                    SDELKA_REAL sdr

                    left join GET_MAX_FORMAT_AND_RUBRIKA(sdr.AG_ID
                                                         ,sdr.SD_ID) mfr
                    on (1 = 1)

                    left join FORMAT fm on (fm.FM_ID = mfr.FM_ID)
                where
                        sdr.AG_ID = :AGID
                    and sdr.SD_TYPE = :SD_TYPE
                    and sdr.SD_FACT_NUM = :FAC_NUM
                    and sdr.SD_FACT_DATE = :FAC_DATE
                    and sdr.GZ_ID = :GZID
                    and (:ONLY_NOT_PAYED = 0
                         or sdr.SD_ALL_PAYED = 0
                         or sdr.SD_ALL_PAYED is null)
                    and fm.FM_NAME is not null
                into
                    :ONEFORMAT
            do
            begin
                if (FMNAME <> '') then
                    FMNAME = FMNAME || ',';
                FMNAME = f_left(FMNAME || ONEFORMAT, 120);
            end
            */

            DESCRIPT = LEFT('№:'
                              || PODACHA_NUMS
                              /*|| ' ф-т:'
                              || FMNAME*/, 200);

            COST = SDSUM;

            suspend;
        end
        else if (SD_TYPE = 3) then
        begin
            -- Послуги кадрової агенцiї
            SERV_ID = 6;
            DESCRIPT = LEFT('', 200);
            COST = SDSUM;
            suspend;
        end
        else if (SD_TYPE = 4) then
        begin
            -- Реклама у iнтернетi
            SERV_ID = 5;
            DESCRIPT = LEFT('', 200);
            COST = SDSUM;
            suspend;
        end
        else if (SD_TYPE = 5) then
        begin
            -- Об'ява до регiональної газети
            SERV_ID = 7;
            DESCRIPT = LEFT('', 200);
            COST = SDSUM;
            suspend;
        end
        else if (SD_TYPE = 6) then
        begin

            -- Iншi послуги
            for
                select
                     cast(sr.SR_AMOUNT as integer)
                    ,sr.SR_SUM
                    ,sr.SR_TYPE
                    ,sr.SR_DESCRIPTION
                from
                    SERVICE sr

                    left join SERVICE_TYPE se
                    on (se.SE_ID = sr.SR_TYPE)
                where
                        sr.AG_ID = :AGID
                    and sr.SD_ID = :SDID
                into
                     :SRAMOUNT
                    ,:COST
                    ,:SERVTYPE
                    ,:SRDESC
            do
            begin
                SKIP_SERV = 0;

                -- Друк
                if (SERVTYPE = 1) then
                    SERV_ID = 11;
                -- Вкладка ПР
                else if (SERVTYPE = 2) then
                    SERV_ID = 12;
                -- Вкладка РЖ
                else if (SERVTYPE = 3) then
                    SERV_ID = 12;
                -- Кур'єр
                else if (SERVTYPE = 4) then
                    SERV_ID = 13;
                -- _нше
                else if (SERVTYPE = 5) then
                    SKIP_SERV = 1;

                if (SKIP_SERV = 0) then
                begin
                    if (SRAMOUNT > 0) then
                        DESCRIPT = 'Кiльк.:' || SRAMOUNT;

                    if (CHAR_LENGTH(SRDESC) > 0) then
                    begin
                        if (CHAR_LENGTH(DESCRIPT) > 0) then
                            DESCRIPT = DESCRIPT || '. ';

                        DESCRIPT = DESCRIPT || LEFT(SRDESC, 85);
                    end

                    suspend;
                end
            end
        end
    end
end^


ALTER PROCEDURE GET_CURRENT_ISSUE (
    IN_GZ_ID INTEGER)
RETURNS (
    IS_ID INTEGER)
AS
BEGIN
    if (:IN_GZ_ID = 1) then
        select PM_CURRENT_ISSUE_PR from PARAMS into :IS_ID;
    else if (:IN_GZ_ID = 2) then
        select PM_CURRENT_ISSUE_NS from PARAMS into :IS_ID;
    else if (:IN_GZ_ID = 3) then
        select PM_CURRENT_ISSUE_SR from PARAMS into :IS_ID;
    else if (:IN_GZ_ID = 4) then
        select PM_CURRENT_ISSUE_RZ from PARAMS into :IS_ID;
    else if (:IN_GZ_ID = 5) then
        select PM_CURRENT_ISSUE_RK from PARAMS into :IS_ID;
    else
        IS_ID = -1;

    SUSPEND;
END^


ALTER PROCEDURE GET_CURRENT_PODACHA (
    AG_ID INTEGER,
    SD_ID INTEGER)
RETURNS (
    PD_ID INTEGER,
    IS_ID INTEGER,
    PD_IS_DONE INTEGER)
AS
DECLARE VARIABLE GZID INTEGER;

DECLARE VARIABLE CURRISS INTEGER;
DECLARE VARIABLE CURRISS_DATE TIMESTAMP;

/*
DECLARE VARIABLE CURRISPR INTEGER;
DECLARE VARIABLE CURRISNS INTEGER;
DECLARE VARIABLE CURRISSR INTEGER;

DECLARE VARIABLE CURRISPR_DATE TIMESTAMP;
DECLARE VARIABLE CURRISNS_DATE TIMESTAMP;
DECLARE VARIABLE CURRISSR_DATE TIMESTAMP;
*/

DECLARE VARIABLE PDID INTEGER;
DECLARE VARIABLE ISID INTEGER;
DECLARE VARIABLE ISDATE TIMESTAMP;
DECLARE VARIABLE MINDATE TIMESTAMP;
DECLARE VARIABLE MAXDATE TIMESTAMP;
BEGIN
    SELECT S.GZ_ID
    FROM SDELKA S
    WHERE S.AG_ID = :AG_ID
          AND S.SD_ID = :SD_ID
    INTO GZID;

    EXECUTE PROCEDURE GET_CURRENT_ISSUE(GZID)
    RETURNING_VALUES :CURRISS;
/*
    SELECT PM.PM_CURRENT_ISSUE_PR
    FROM PARAMS PM
    INTO :CURRISPR;

    SELECT PM.PM_CURRENT_ISSUE_NS
    FROM PARAMS PM
    INTO :CURRISNS;

    SELECT PM.PM_CURRENT_ISSUE_SR
    FROM PARAMS PM
    INTO :CURRISSR;
*/
/* сначала посмотрим - а вдруг следующая подача - в текущий номер? */
    PDID = 0;
    PD_IS_DONE = 0;
    SELECT
        MIN(PD_ID)
    FROM
        PODACHA PD
        LEFT JOIN ISSUE ISS
        ON (PD.IS_ID=ISS.IS_ID)
    WHERE
        PD.AG_ID=:AG_ID
        AND
        PD.SD_ID=:SD_ID
        AND
        PD.PD_IS_DONE=0
        AND
        ISS.IS_ID = :CURRISS
/*        (
            (
                ISS.IS_ID = :CURRISPR
                AND ISS.GZ_ID=1
            )
            OR
            (
                ISS.IS_ID = :CURRISNS
                AND ISS.GZ_ID=2
            )
            OR
            (
                ISS.IS_ID = :CURRISSR
                AND ISS.GZ_ID=3
            )
        )
*/
    INTO
        :PDID;

    IF (PDID > 0) THEN
    BEGIN
        PD_ID = :PDID;
        SELECT IS_ID FROM PODACHA
        WHERE PD_ID=:PDID
        INTO :IS_ID;
        SUSPEND;
        EXIT;
    END

/* Если не получилось - попытаемся найти другой следующий номер */
    SELECT IS_DATE
    FROM ISSUE
    WHERE IS_ID = :CURRISS
    INTO :CURRISS_DATE;

/*
    SELECT IS_DATE
    FROM ISSUE
    WHERE IS_ID = :CURRISPR
    INTO :CURRISPR_DATE;

    SELECT IS_DATE
    FROM ISSUE
    WHERE IS_ID = :CURRISNS
    INTO :CURRISNS_DATE;
*/

    MINDATE = NULL;

    FOR
        SELECT
            PD.PD_ID,
            ISS.IS_ID,
            ISS.IS_DATE
        FROM
            PODACHA PD
            LEFT JOIN ISSUE ISS
            ON (PD.IS_ID=ISS.IS_ID)
        WHERE
            PD.AG_ID=:AG_ID
            AND
            PD.SD_ID=:SD_ID
            AND
            PD.PD_IS_DONE=0
            AND
            ISS.GZ_ID = :GZID
            AND
            ISS.IS_DATE >= :CURRISS_DATE
/*
            (
                (
                    ISS.GZ_ID = 1
                    AND
                    ISS.IS_DATE >= :CURRISPR_DATE
                )
                OR
                (
                    ISS.GZ_ID = 2
                    AND
                    ISS.IS_DATE >= :CURRISNS_DATE
                )
            )
*/
        INTO
            :PDID,
            :ISID,
            :ISDATE
    DO
    BEGIN
        IF ((ISDATE < MINDATE) OR (MINDATE IS NULL)) THEN
        BEGIN
            MINDATE = ISDATE;
            PD_ID = :PDID;
            IS_ID = :ISID;
        END
    END
    IF (PD_ID IS NOT NULL AND IS_ID IS NOT NULL) THEN
    BEGIN
        SUSPEND;
        EXIT;
    END
/* мы не нашли ещё не вышедшую "текующую" подачу. Берём тогда последнюю,
 которая была */
    PD_IS_DONE = 1;
    MAXDATE = NULL;
    FOR
        SELECT
            PD.PD_ID,
            ISS.IS_ID,
            ISS.IS_DATE
        FROM
            PODACHA PD
            LEFT JOIN ISSUE ISS
            ON (PD.IS_ID=ISS.IS_ID)
        WHERE
            PD.AG_ID=:AG_ID
            AND
            PD.SD_ID=:SD_ID
            AND
            PD.PD_IS_DONE=1
        INTO
            :PDID,
            :ISID,
            :ISDATE
    DO
    BEGIN
        IF ((ISDATE > MAXDATE) OR (MAXDATE IS NULL)) THEN
        BEGIN
            MAXDATE = ISDATE;
            PD_ID = :PDID;
            IS_ID = :ISID;
        END
    END
    SUSPEND;
END^


ALTER PROCEDURE GET_CUST_PHONES (
    AG_ID INTEGER,
    CU_ID INTEGER)
RETURNS (
    CU_PHONES VARCHAR(1024))
AS
declare variable CP varchar(16);
begin
    cu_phones = '';
    for
        select
            trim(cp.CP_NUMBER)
        from
            CUST_PHONE cp
        where
            cp.AG_ID = :AG_ID and
            cp.CU_ID = :CU_ID
        into :cp
    do
    begin
        if (cu_phones <> '') then
            cu_phones = cu_phones || ', ';

        if (char_length(cu_phones) > 1000) then
        begin
           cu_phones = cu_phones || '...';
           suspend;
           exit;
        end
        else
        cu_phones = cu_phones || cp;
    end
    
    suspend;
end^


ALTER PROCEDURE GET_DEL_SDELKA_PHONES_STR (
    AG_ID INTEGER,
    SD_ID INTEGER)
RETURNS (
    PHONES VARCHAR(255))
AS
declare variable CU_ID integer;
declare variable PHNUM varchar(16);
begin
  /* Procedure Text */
  select sd.CU_ID
  from SDELKA_DELETED sd
  where sd.AG_ID = :AG_ID
  and   sd.SD_ID = :SD_ID
  into  :CU_ID;

  phones = '';

   for
       select first 3 ph.CP_NUMBER
       from CUST_PHONE ph
       where     ph.AG_ID = :AG_ID
             and ph.CU_ID = :cu_id
       into :phnum
   do
   begin
       if (CHAR_LENGTH(phones) < 800) then
       begin
           if (phones <> '') then
               phones = phones || ', ';

           phones = phones || TRIM(phnum);
       end
   end
  suspend;
end^


ALTER PROCEDURE GET_FIELDS_FOR_MODULE (
    AG_ID INTEGER,
    SD_ID INTEGER,
    RUB_ID INTEGER)
RETURNS (
    AGENT_NAME VARCHAR(128),
    FM_ID INTEGER,
    OBJAV_ID INTEGER,
    OLD_CONTENT_ID INTEGER,
    PICTURE_TO_INET INTEGER,
    VAC_COUNT INTEGER,
    FM_NAME VARCHAR(10),
    RB_NAME VARCHAR(32),
    PODACHA_NUM VARCHAR(128),
    FM_PICTURE_SIZE VARCHAR(128),
    RB_ID INTEGER,
    CLIENT_NAME VARCHAR(128),
    CUQ_REG INTEGER)
AS
declare variable cu_id integer;
declare variable fm_id1 integer;
declare variable pd_id integer;
declare variable isclosed integer;
declare variable is_id integer;
declare variable res integer;
declare variable rb_id1 integer;
declare variable ob_id integer;
begin

 /*проверяем на текущую подачу*/
  EXECUTE PROCEDURE GET_CURRENT_PODACHA (:AG_ID,:SD_ID)
  RETURNING_VALUES :PD_ID,:IS_ID,:ISCLOSED;

  IF ((PD_ID > 0) AND (ISCLOSED = 0)) THEN
   RES = 1;
  ELSE
    RES = 0;

  IF (RES = 1) THEN
    BEGIN
 --     NEW_CONTENTID = 0; --gen_id(g_objav_content_id, 1);

     EXECUTE PROCEDURE sdelka_podacha_nums(:ag_id, :sd_id)
     RETURNING_VALUES :sd_id, :PODACHA_NUM;

     if (rub_id is null) then
      BEGIN
       SELECT
            min(OBJ.OBJAV_ID),
            sd.cu_id
        FROM
            PODACHA PD
            LEFT JOIN OBJAVLENIE OBJ
            ON (PD.PD_ID=OBJ.PD_ID)
            LEFT JOIN SDELKA SD
            ON  (SD.AG_ID=PD.AG_ID AND SD.SD_ID=PD.SD_ID)
            LEFT join format FM
            ON (FM.fm_id = OBJ.fm_id)
        WHERE
             (pd.pd_id = :PD_id) and
             (PD.IS_ID=:IS_ID)   AND
             (FM.FM_HAS_PICTURE = 1)
        group by sd.cu_id
        into
            :OB_ID,
            :cu_id;

        -- !!
        select   OB.OBJAV_ID,
                 OB.RB_ID,
                 OB.FM_ID,
                 OB.CONTENT_ID,
                 OB.picture_to_inet,
                 oB.vac_count
        from objavlenie ob
        where ob.objav_id = :ob_id
        into 
            :OBJAV_ID,
            :RB_ID1,
            :FM_ID1,
            :OLD_CONTENT_ID,
            :picture_to_inet,
            :vac_count;

        FM_ID = :fm_id1;
        rb_id = :rb_id1;

        /*РАЗМЕРЫ МОДУЛЯ*/
        SELECT F.fm_name,
               F.fm_picture_sizes
        FROM   format F
        WHERE  F.fm_id = :fm_id
        into
               :fm_name,
               :fm_picture_size;

        /*НАЗВАНИЕ РУБРИКИ*/
        SELECT R.rb_name_short
        FROM   rubrika R
        WHERE  R.rb_id = :RB_id
        into   :rb_name;
      end
      else
       begin
        SELECT
            OBj.OBJAV_ID,
            OBj.CONTENT_ID,
            sd.cu_id,
            OBj.picture_to_inet,
            oBj.vac_count,
            rub.rb_name_short,
            Fm.fm_name,
            rub.rb_id,
            fm.fm_id,
            Fm.fm_picture_sizes
        FROM
            PODACHA PD
            LEFT JOIN OBJAVLENIE OBJ ON (PD.PD_ID=OBJ.PD_ID)
            LEFT JOIN SDELKA SD      ON (SD.AG_ID=PD.AG_ID AND SD.SD_ID=PD.SD_ID)
            LEFT join format FM      ON (FM.fm_id = OBJ.fm_id)
            left join rubrika rub    on (rub.rb_id = obj.rb_id)
        WHERE
             (pd.pd_id = :PD_id)
             and (PD.IS_ID=:IS_ID)
             and (rub.rb_id = :rub_id)
             and (FM.FM_HAS_PICTURE = 1)
        into
            :OBJAV_ID,
            :OLD_CONTENT_ID,
            :cu_id,
            :picture_to_inet,
            :vac_count,
            :rb_name,
            :fm_name,
            :rb_id,
            :fm_id,
            :fm_picture_size;
       end

        -- имя агента
        select a.ag_name
        from   agent a
        where  a.ag_id = :ag_id
        into   :agent_name;

        --имя клиента
        select c.cu_name, c.cuq_reg_id
        from   cust c
        where  (c.cu_id = :cu_id) and
               (c.ag_id = :ag_id)
        into   :client_name,
               :cuq_reg;

        SUSPEND;
        EXIT;
    END
  ELSE
     EXCEPTION E_CAN_EDIT_CURRENT_PODACHA_ONLY;
end^


ALTER PROCEDURE GET_INTERCEPTIONS
RETURNS (
    AG_ID INTEGER,
    SD_ID INTEGER,
    PH_NUMBER VARCHAR(12),
    AG_ID_INTERCEPTED INTEGER,
    CU_ID_INTERCEPTED INTEGER)
AS
DECLARE VARIABLE CUID INTEGER;
DECLARE VARIABLE CNT INTEGER;
BEGIN
    FOR
        SELECT SDC.AG_ID,SDC.SD_ID,SDC.CU_ID
        FROM SDELKA_CURRENT SDC
        ORDER BY SDC.AG_ID
        INTO :AG_ID,:SD_ID,:CUID
    DO
    BEGIN
        FOR
            SELECT PH.PH_NUMBER
            FROM PHONE PH
            WHERE PH.AG_ID=:AG_ID AND
                  PH.SD_ID=:SD_ID
            INTO :PH_NUMBER
        DO
        BEGIN
            EXECUTE PROCEDURE IS_INTERCEPTED(AG_ID,PH_NUMBER)
            RETURNING_VALUES :CNT,:AG_ID,:AG_ID_INTERCEPTED;
            IF (CNT>0) THEN
                SUSPEND;
        END

        FOR
            SELECT CU_ID,CP_NUMBER
            FROM CUST_PHONE CP
            WHERE CP.AG_ID=:AG_ID AND
                  CP.CU_ID=:CUID
            INTO :CU_ID_INTERCEPTED,:PH_NUMBER
        DO
        BEGIN
            EXECUTE PROCEDURE IS_INTERCEPTED(AG_ID,PH_NUMBER)
            RETURNING_VALUES :CNT,:AG_ID,:AG_ID_INTERCEPTED;
            IF (CNT>0) THEN
                SUSPEND;
        END

    END
END^


ALTER PROCEDURE GET_IS_ID_GAZETA (
    IN_IS_ID INTEGER)
RETURNS (
    OUT_IS_ID INTEGER)
AS
begin

 if (:in_is_id <> 4) then
 begin

   select ii.is_id
   from issue ii
   where
        ii.gz_id = 2
        and ii.is_date > '01.01.2011'
    and
    ii.is_name in (
         select i.is_name
         from issue i
         where i.is_id = :in_is_id
        )
 into
      :out_is_id;
 end
 else
  out_is_id = 1;

end^


ALTER PROCEDURE GET_IS_SDELKA_CURRENT_ISSUE (
    AG_ID INTEGER,
    SD_ID INTEGER)
RETURNS (
    IS_CURRENT_ISSUE INTEGER)
AS
  declare variable GZID integer;
  declare variable ISID integer;
BEGIN
  select GZ_ID
  from SDELKA
  where AG_ID = :AG_ID and SD_ID = :SD_ID
  into :GZID;

  execute procedure GET_CURRENT_ISSUE(GZID)
  returning_values :ISID;

  select
    count(*)
  from
    PODACHA pd
  where
    pd.AG_ID = :AG_ID
    and pd.SD_ID = :SD_ID
    and pd.IS_ID = :ISID
  into
    :IS_CURRENT_ISSUE;

  suspend;
END^


ALTER PROCEDURE GET_ISSUE_ID (
    GZ_ID INTEGER,
    IS_NAME VARCHAR(10),
    IS_YEAR INTEGER)
RETURNS (
    IS_ID INTEGER,
    IS_NAME_COMPOSED VARCHAR(50))
AS
BEGIN
    if (IS_NAME='0') then
    begin
        if (GZ_ID=1) then
            IS_ID=0;
        else if (GZ_ID=2) then
            IS_ID=1;
        else if (GZ_ID=3) then
            IS_ID=2;
        else if (GZ_ID=4) then
            IS_ID=3;
        else if (GZ_ID=5) then
            IS_ID=4;
    end
    else
    begin
        IS_ID=-1;
        SELECT IS_ID, IS_NAME_COMPOSED FROM ISSUE
        WHERE GZ_ID=:GZ_ID AND IS_NAME=:IS_NAME AND EXTRACT(YEAR FROM IS_DATE) = :IS_YEAR
        INTO :IS_ID, :IS_NAME_COMPOSED;
    end

    SUSPEND;
END^


ALTER PROCEDURE GET_MAX_FORMAT_AND_RUBRIKA (
    AG_ID INTEGER,
    SD_ID INTEGER)
RETURNS (
    FM_ID INTEGER,
    RB_ID INTEGER,
    COST FLOAT)
AS
DECLARE VARIABLE OB_FM_ID INTEGER;
DECLARE VARIABLE OB_MAX_FM_ID INTEGER;
DECLARE VARIABLE OB_RB_ID INTEGER;
DECLARE VARIABLE OB_MAX_RB_ID INTEGER;
DECLARE VARIABLE OB_COST FLOAT;
DECLARE VARIABLE OB_MAX_COST FLOAT;
DECLARE VARIABLE OBJAV_FM_ID INTEGER;
DECLARE VARIABLE OBJAV_RB_ID1 INTEGER;
DECLARE VARIABLE OBJAV_RB_ID2 INTEGER;
DECLARE VARIABLE OBJAV_COST1 FLOAT;
DECLARE VARIABLE OBJAV_COST2 FLOAT;
DECLARE VARIABLE OBJAV_MAX_FM_ID INTEGER;
DECLARE VARIABLE OBJAV_MAX_RB_ID INTEGER;
DECLARE VARIABLE OBJAV_MAX_COST FLOAT;
DECLARE VARIABLE CURRPDID INTEGER;
DECLARE VARIABLE DUMB INTEGER;
begin
   OB_MAX_COST = 0;

   for
       select
             ob.FM_ID
           , ob.RB_ID
           , fm.FM_COST * rb.RB_COST_COEFF
       from
           SDELKA sd, OBJAV ob, FORMAT_COST fm, RUBRIKA rb
/*            OBJAV ob
           left join FORMAT fm on (ob.FM_ID = fm.FM_ID)
           left join RUBRIKA rb on (ob.RB_ID = rb.RB_ID)*/
       where
               sd.AG_ID = :AG_ID and sd.SD_ID = :SD_ID
           and ob.AG_ID = :AG_ID and ob.SD_ID = :SD_ID
           and fm.GZ_ID = sd.GZ_ID
           and fm.FM_ID = ob.FM_ID
           and rb.RB_ID = ob.RB_ID
       into
           :OB_FM_ID, :OB_RB_ID, :OB_COST
   do
   begin
       if (OB_COST >= OB_MAX_COST) then
       begin
           OB_MAX_COST  = OB_COST;
           OB_MAX_FM_ID = OB_FM_ID;
           OB_MAX_RB_ID = OB_RB_ID;
       end
   end

   execute procedure GET_CURRENT_PODACHA(:AG_ID,:SD_ID)
   returning_values :CURRPDID,:DUMB,:DUMB;

   OBJAV_MAX_COST = 0;

   for
       select
             obj.FM_ID
           , obj.RB_ID
           , obj.DOUBLE_RB_ID
           , fm.FM_COST * rb1.RB_COST_COEFF
           , fm.FM_COST * rb2.RB_COST_COEFF
       from
           OBJAVLENIE obj
           
           left join RUBRIKA rb2 on (rb2.RB_ID = obj.DOUBLE_RB_ID)

           , SDELKA sd, FORMAT_COST fm, RUBRIKA rb1
/*        left join FORMAT fm
       ON (OBJ.FM_ID=FM.FM_ID)

       LEFT JOIN RUBRIKA RB1
       ON (OBJ.RB_ID=RB1.RB_ID)

       LEFT JOIN RUBRIKA RB2
       ON (OBJ.DOUBLE_RB_ID=RB2.RB_ID)
*/
       where
               sd.AG_ID = :AG_ID and sd.SD_ID = :SD_ID
           and obj.PD_ID = :CURRPDID
           and fm.GZ_ID = sd.GZ_ID
           and fm.FM_ID = obj.FM_ID
           and rb1.RB_ID = obj.RB_ID
       into :OBJAV_FM_ID,
            :OBJAV_RB_ID1,
            :OBJAV_RB_ID2,
            :OBJAV_COST1,
            :OBJAV_COST2
   do
   begin
/*        if (OBJAV_COST1 is null) then
           OBJAV_COST1 = 0;
       if (OBJAV_COST2 is null) then
           OBJAV_COST2 = 0;*/
           
       if (OBJAV_COST2 >= OBJAV_COST1) then
       begin
           OBJAV_RB_ID1 = OBJAV_RB_ID2;
           OBJAV_COST1  = OBJAV_COST2;
       end
       if (OBJAV_COST1 >= OBJAV_MAX_COST) then
       begin
           OBJAV_MAX_COST  = OBJAV_COST1;
           OBJAV_MAX_FM_ID = OBJAV_FM_ID;
           OBJAV_MAX_RB_ID = OBJAV_RB_ID1;
       end
   end

   if (OB_COST is null) then
       OB_COST = 0;
   if (OBJAV_MAX_COST is null) then
       OBJAV_MAX_COST = 0;
   if (OBJAV_MAX_COST > OB_COST) then
   begin
       FM_ID = :OBJAV_MAX_FM_ID;
       RB_ID = :OBJAV_MAX_RB_ID;
       COST  = :OBJAV_MAX_COST;
   end
   else
   begin
       FM_ID = :OB_FM_ID;
       RB_ID = :OB_RB_ID;
       COST  = :OB_COST;
   end

   suspend;
end^


ALTER PROCEDURE GET_NAME_GZ (
    I INTEGER)
RETURNS (
    NAME_GZ VARCHAR(10))
AS
begin
       select
            iss.is_name
       from
            get_current_issue(:I) gci
            left join issue iss
            on (gci.is_id = iss.is_id)
       into
            :name_gz;

  suspend;
end^


ALTER PROCEDURE GET_NEXT_EXPORT_ID
RETURNS (
    EXPORT_ID INTEGER)
AS
BEGIN
    EXPORT_ID=GEN_ID(G_EXPORT_ID,1);
    SUSPEND;
END^


ALTER PROCEDURE GET_NEXT_FACT_NUM (
    AG_ID INTEGER)
RETURNS (
    FACT_NUM INTEGER)
AS
BEGIN
    SELECT AG.AG_MAX_FACT_NUM
    FROM AGENT AG
    WHERE AG.AG_ID=:AG_ID
    INTO :FACT_NUM;
    
    FACT_NUM=FACT_NUM+1;
    
    UPDATE AGENT AG
    SET AG.AG_MAX_FACT_NUM=:FACT_NUM
    WHERE AG.AG_ID=:AG_ID;
    
    SUSPEND;
END^


ALTER PROCEDURE GET_NEXT_PODACHA
AS
BEGIN
  /* Procedure body */
  SUSPEND;
END^


ALTER PROCEDURE GET_OBJAV_TEXT (
    AG_ID INTEGER,
    SD_ID INTEGER,
    OB_ID INTEGER)
RETURNS (
    OB_TEXT VARCHAR(2047),
    OB_ID_RES INTEGER)
AS
DECLARE VARIABLE PARENTID INTEGER;
BEGIN
    OB_ID_RES=:OB_ID;

    SELECT OB_PARENT
    FROM OBJAV OB
    WHERE OB.AG_ID=:AG_ID AND
          OB.SD_ID=:SD_ID AND
          OB.OB_ID=:OB_ID
    INTO :PARENTID;
    
    IF (PARENTID IS NOT NULL) THEN
       OB_ID_RES=:PARENTID;
       
    SELECT OB.OB_TEXT
    FROM OBJAV OB
    WHERE OB.AG_ID=:AG_ID AND
          OB.SD_ID=:SD_ID AND
          OB.OB_ID=:OB_ID_RES
    INTO :OB_TEXT;
    
    SUSPEND;
END^


ALTER PROCEDURE GET_OLD_CUST_OBJAVLENIE (
    AG_ID_INPUT INTEGER,
    CU_ID_INPUT INTEGER,
    IS_ID_INPUT INTEGER,
    FM_ID_INPUT INTEGER)
RETURNS (
    OBJAV_ID INTEGER)
AS
DECLARE VARIABLE PARENT_ID INTEGER;
DECLARE VARIABLE PDID INTEGER;
BEGIN
    for
        select
            sd.SD_ID
        from
            PODACHA pd

            left join SDELKA sd
            on (sd.AG_ID = pd.AG_ID and sd.SD_ID = pd.SD_ID)
        where
                pd.AG_ID    = :AG_ID_INPUT
            and pd.IS_ID    = :IS_ID_INPUT
            and sd.SD_STATE <> 100
            and sd.AS_ID    <> 2
            and sd.CU_ID    = :CU_ID_INPUT
            and sd.SD_TYPE  = 1
        into :PARENT_ID
    do
    begin
        SELECT PD.PD_ID
        FROM PODACHA PD
        WHERE PD.AG_ID=:AG_ID_INPUT
              AND PD.SD_ID=:PARENT_ID
              AND PD.IS_ID=:IS_ID_INPUT
        INTO :PDID;
        IF (PDID IS NOT NULL) THEN
        BEGIN
            FOR
                SELECT OBJ.OBJAV_ID
                FROM OBJAVLENIE OBJ
                WHERE OBJ.PD_ID     = :PDID
                      AND OBJ.FM_ID = :FM_ID_INPUT
                INTO :OBJAV_ID
            DO
                SUSPEND;
        END
   end
END^


ALTER PROCEDURE GET_OLD_CUST_OBJAVLENIE_RUB (
    AG_ID_INPUT INTEGER,
    CU_ID_INPUT INTEGER,
    IS_ID_INPUT INTEGER,
    FM_ID_INPUT INTEGER,
    RB_ID_INPUT INTEGER)
RETURNS (
    OBJAV_ID INTEGER)
AS
declare variable PARENT_ID integer;
declare variable PDID integer;
BEGIN
    for
        select
            sd.SD_ID
        from
            PODACHA pd

            left join SDELKA sd
            on (sd.AG_ID = pd.AG_ID and sd.SD_ID = pd.SD_ID)
        where
                pd.AG_ID    = :AG_ID_INPUT
            and pd.IS_ID    = :IS_ID_INPUT
            and sd.SD_STATE <> 100
            and sd.AS_ID    <> 2
            and (sd.CU_ID    = :CU_ID_INPUT
                 or :CU_ID_INPUT IS NULL
            )
            and sd.SD_TYPE  = 1
        into :PARENT_ID
    do
    begin
        SELECT min(PD.PD_ID)
        FROM PODACHA PD
        WHERE PD.AG_ID=:AG_ID_INPUT
              AND PD.SD_ID=:PARENT_ID
              AND PD.IS_ID=:IS_ID_INPUT
        INTO :PDID;
        IF (PDID IS NOT NULL) THEN
        BEGIN
            FOR
                SELECT OBJ.OBJAV_ID
                FROM OBJAVLENIE OBJ
                WHERE OBJ.PD_ID     = :PDID
                      AND (-1 = :FM_ID_INPUT OR OBJ.FM_ID = :FM_ID_INPUT)
                      AND (-1 = :RB_ID_INPUT OR OBJ.RB_ID = :RB_ID_INPUT OR OBJ.DOUBLE_RB_ID = :RB_ID_INPUT)
                INTO :OBJAV_ID
            DO
                SUSPEND;
        END
   end
END^


ALTER PROCEDURE GET_OLD_CUST_OBJAVLENIE_RUB_NEW (
    AG_ID_INPUT INTEGER,
    CU_ID_INPUT INTEGER,
    IS_ID_INPUT INTEGER,
    FM_ID_INPUT INTEGER,
    RB_ID_INPUT INTEGER)
RETURNS (
    OBJAV_ID INTEGER)
AS
declare variable NUM char(16);
BEGIN
    OBJAV_ID = NULL;

    FOR SELECT cp.CP_NUMBER
        FROM CUST_PHONE cp
        WHERE cp.AG_ID = :AG_ID_INPUT
        AND cp.CU_ID = :CU_ID_INPUT
        INTO :NUM DO
    BEGIN
        FOR SELECT o.OBJAV_ID
            FROM podacha p
            LEFT JOIN sdelka s ON (s.ag_id = p.AG_ID AND s.SD_ID = p.SD_ID)
            LEFT JOIN OBJAVLENIE o ON (o.PD_ID = p.PD_ID)
            WHERE p.IS_ID = :IS_ID_INPUT
            AND   s.CU_ID IN (SELECT cp.CU_ID FROM CUST_PHONE cp WHERE cp.CP_NUMBER = :num)
            AND o.FM_ID = :FM_ID_INPUT
            AND (:RB_ID_INPUT = -1 OR o.RB_ID = :RB_ID_INPUT)
            INTO :OBJAV_ID DO
        BEGIN
            IF(:OBJAV_ID IS NOT NULL) THEN
            BEGIN
                 SUSPEND;
               --  EXIT;
            END
        END
    END
    SUSPEND;
END^


ALTER PROCEDURE GET_OLD_CUST_TEXTS (
    AG_ID_INPUT INTEGER,
    CU_ID_INPUT INTEGER,
    IS_ID_INPUT INTEGER,
    FM_ID_INPUT INTEGER)
RETURNS (
    AG_ID INTEGER,
    SD_ID INTEGER,
    OB_ID INTEGER,
    IS_OBJAVLENIE INTEGER)
AS
DECLARE VARIABLE PARENT_ID INTEGER;
/*DECLARE VARIABLE PDID INTEGER;*/
BEGIN
    AG_ID = :AG_ID_INPUT;
    for
        select sd.SD_ID
        from
            PODACHA pd
            left join SDELKA sd
            on (sd.AG_ID = pd.AG_ID and sd.SD_ID = pd.SD_ID)
        where
                pd.AG_ID    = :AG_ID_INPUT
            and pd.IS_ID    = :IS_ID_INPUT
            and sd.SD_STATE <> 100
            and sd.AS_ID    <> 2
            and sd.CU_ID    = :CU_ID_INPUT
            and sd.SD_TYPE  = 1
        into :PARENT_ID
    do
    begin
        for
            select ob.SD_ID, ob.OB_ID
            from OBJAV ob
            where   ob.AG_ID     = :AG_ID_INPUT and
                    ob.OB_PARENT is null and
                    ob.SD_ID     = :PARENT_ID and
                    ob.FM_ID     = :FM_ID_INPUT
            into :SD_ID, :OB_ID
        do
            suspend;
   end
END^


ALTER PROCEDURE GET_OLD_CUST_TEXTS_RUB (
    AG_ID_INPUT INTEGER,
    CU_ID_INPUT INTEGER,
    IS_ID_INPUT INTEGER,
    FM_ID_INPUT INTEGER,
    RB_ID_INPUT INTEGER)
RETURNS (
    AG_ID INTEGER,
    SD_ID INTEGER,
    OB_ID INTEGER,
    IS_OBJAVLENIE INTEGER)
AS
DECLARE VARIABLE PARENT_ID INTEGER;
BEGIN
    AG_ID = :AG_ID_INPUT;
    for
        select sd.SD_ID
        from
            PODACHA pd
            left join SDELKA sd
            on (sd.AG_ID = pd.AG_ID and sd.SD_ID = pd.SD_ID)
        where
                pd.AG_ID    = :AG_ID_INPUT
            and pd.IS_ID    = :IS_ID_INPUT
            and sd.SD_STATE <> 100
            and sd.AS_ID    <> 2
            and (sd.CU_ID    = :CU_ID_INPUT
                 or :CU_ID_INPUT IS NULL
            )
            and sd.SD_TYPE  = 1
        into :PARENT_ID
    do
    begin
        for
            select ob.SD_ID, ob.OB_ID
            from OBJAV ob
            where   ob.AG_ID     = :AG_ID_INPUT and
                    ob.OB_PARENT is null and
                    ob.SD_ID     = :PARENT_ID and
                    (-1 = :FM_ID_INPUT or ob.FM_ID = :FM_ID_INPUT) and
                    (-1 = :RB_ID_INPUT or ob.RB_ID = :RB_ID_INPUT)
            into :SD_ID, :OB_ID
        do
            suspend;
   end
END^


ALTER PROCEDURE GET_OLD_SDELKA_TEXTS (
    AG_ID_INPUT INTEGER,
    SD_ID_INPUT INTEGER,
    IS_ID_INPUT INTEGER)
RETURNS (
    AG_ID INTEGER,
    SD_ID INTEGER,
    OB_ID INTEGER)
AS
DECLARE VARIABLE CUID INTEGER;
DECLARE VARIABLE PARENT_ID INTEGER;
DECLARE VARIABLE PH CHAR(16);
BEGIN
    AG_ID=:AG_ID_INPUT;
    SELECT CU_ID FROM SDELKA
    WHERE AG_ID=:AG_ID_INPUT AND SD_ID=:SD_ID_INPUT
    INTO :CUID;
    
    FOR
        SELECT SD.SD_ID
        FROM SDELKA_REAL SD
        WHERE   SD.AG_ID=:AG_ID_INPUT AND
                SD.CU_ID=:CUID AND
                SD.SD_TYPE=1 AND
                EXISTS  (
                            SELECT
                                PD.PD_ID
                            FROM
                                PODACHA PD
                            WHERE
                                PD.AG_ID=SD.AG_ID AND
                                PD.SD_ID=SD.SD_ID AND
                                PD.IS_ID=:IS_ID_INPUT 
                        )
        INTO :PARENT_ID
    DO
    BEGIN
        FOR
            SELECT OB.SD_ID,OB.OB_ID
            FROM OBJAV OB
            WHERE   OB.AG_ID=:AG_ID_INPUT AND
                    OB.SD_ID=:PARENT_ID
            INTO :SD_ID,:OB_ID
        DO
            SUSPEND;
   END

END^


ALTER PROCEDURE GET_RESERVE_MAP (
    GZ_ID INTEGER,
    IS_IN INTEGER,
    RB_IN INTEGER)
RETURNS (
    RM_ID INTEGER,
    PAGE_MAP VARCHAR(1024),
    LOCK_USR INTEGER,
    RB_ID INTEGER,
    IS_ID INTEGER)
AS
begin
  /* Procedure Text */
  SELECT rm.RM_ID, rm.PAGE_MAP, rm.LOCK_USR
  FROM RESERVE_MAP rm
  WHERE rm.GZ_ID = :GZ_ID
  AND rm.IS_ID = :IS_IN
  AND rm.RB_ID = :RB_IN
  INTO :RM_ID, :PAGE_MAP, :LOCK_USR;

  RB_ID = RB_IN;
  IS_ID = IS_IN;

  IF (PAGE_MAP IS NULL) THEN
  BEGIN
       SELECT r.DEFAULT_MAP
       FROM RUBRIKA r
       WHERE r.RB_ID = :RB_IN
       AND   r.GZ_ID = :GZ_ID
       INTO :PAGE_MAP;

       INSERT INTO RESERVE_MAP(RM_ID, GZ_ID, IS_ID, RB_ID, PAGE_MAP)
       VALUES(NULL, :GZ_ID, :IS_ID, :RB_ID, :PAGE_MAP);

       SELECT GEN_ID(GEN_RESERVE_MAP_ID, 0) FROM rdb$database INTO :RM_ID;
  END


  SUSPEND;
end^


ALTER PROCEDURE GET_SD_FORMAT (
    AG_ID INTEGER,
    SD_ID INTEGER)
RETURNS (
    FM_ID INTEGER)
AS
begin
  /* Procedure Text */
  SELECT o.fm_id FROM objavlenie o
  JOIN podacha p ON (p.pd_id = o.pd_id)
  WHERE p.ag_id = :ag_id AND p.sd_id = :sd_id
  INTO :fm_id;

  IF (fm_id IS NULL) THEN
  BEGIN
      SELECT ob.fm_id FROM objav ob
      WHERE ob.ag_id = :ag_id AND ob.sd_id = :sd_id
      INTO :fm_id;
  END
  suspend;
end^


ALTER PROCEDURE GET_SDELKA_CUST_ID (
    AG_ID INTEGER,
    SD_ID INTEGER)
RETURNS (
    CU_ID INTEGER)
AS
DECLARE VARIABLE SDTYPE INTEGER;
DECLARE VARIABLE SDPARENT INTEGER;
BEGIN
    select s.CU_ID
    from SDELKA s
    where     s.AG_ID = :AG_ID
          and s.SD_ID = :SD_ID
    into :CU_ID;

    suspend;
END^


ALTER PROCEDURE GET_SDELKA_PHONES_STR (
    AG_ID INTEGER,
    SD_ID INTEGER)
RETURNS (
    PHONES VARCHAR(1000))
AS
declare variable CUID integer;
declare variable PHNUM varchar(16);
BEGIN
   phones = '';

   for
       select ph.PH_NUMBER
       from PHONE ph
       where     ph.AG_ID = :AG_ID
             and ph.SD_ID = :SD_ID
       into :phnum
   do
   begin
       if (CHAR_LENGTH(phones) < 800) then
       begin
           if (phones <> '') then
               phones = phones || ', ';
           phones = phones || TRIM(phnum);
       end
   end
   
   select sd.CU_ID
   from SDELKA sd
   where     sd.AG_ID = :AG_ID
         and sd.SD_ID = :SD_ID
   into :cuid;
   
   for
       select ph.CP_NUMBER
       from CUST_PHONE ph
       where     ph.AG_ID = :AG_ID
             and ph.CU_ID = :cuid
       into :phnum
   do
   begin
       if (CHAR_LENGTH(phones) < 800) then
       begin
           if (phones <> '') then
               phones = phones || ', ';

           phones = phones || TRIM(phnum);
       end
   end
   
   suspend;
END^


ALTER PROCEDURE GET_SDELKA_RUBRIKAS (
    AG_ID_INPUT INTEGER,
    SD_ID_INPUT INTEGER)
RETURNS (
    SD_RUBRIKAS VARCHAR(128))
AS
  DECLARE VARIABLE RBID INTEGER;
  DECLARE VARIABLE FMID INTEGER;
  DECLARE VARIABLE COST FLOAT;
  DECLARE VARIABLE RBNAME VARCHAR(128);
BEGIN
  SD_RUBRIKAS = '';
  RBNAME = '';

  EXECUTE PROCEDURE GET_MAX_FORMAT_AND_RUBRIKA(AG_ID_INPUT, SD_ID_INPUT)
  RETURNING_VALUES :RBID, :FMID, :COST;

  IF (RBID IS NOT NULL) THEN
  BEGIN
    SELECT
      RB.RB_NAME_SHORT
    FROM
      RUBRIKA RB
    WHERE
      RB.RB_ID = :RBID
    INTO
      :RBNAME;

    SD_RUBRIKAS = RBNAME;
  END

  FOR
    SELECT
      DISTINCT RB.RB_NAME_SHORT
    FROM
      OBJAV OB
      LEFT JOIN RUBRIKA RB ON (RB.RB_ID = OB.RB_ID)
    WHERE
      OB.AG_ID = :AG_ID_INPUT AND
      OB.SD_ID = :SD_ID_INPUT AND
      OB.RB_ID <> :RBID
    INTO
      :RBNAME
  DO
  BEGIN
    IF (SD_RUBRIKAS <> '') THEN
      SD_RUBRIKAS = SD_RUBRIKAS || ', ';
    SD_RUBRIKAS = SD_RUBRIKAS || RBNAME;
  END

  /* тут продолжить для модульных... */

END^


ALTER PROCEDURE IS_IN_OTKAZNIK (
    AG_ID INTEGER,
    SD_ID INTEGER)
RETURNS (
    IS_IN INTEGER,
    AG_ID_IN INTEGER)
AS
DECLARE VARIABLE CUID INTEGER;
DECLARE VARIABLE WASFOUND INTEGER;
DECLARE VARIABLE PHNUMBER VARCHAR(12);
BEGIN
    IS_IN = 0;

    select CU_ID
    from SDELKA
    where     AG_ID = :AG_ID
          and SD_ID = :SD_ID
    into :CUID;

    for
        select PH_NUMBER
        from PHONE
        where     AG_ID=:AG_ID
              and SD_ID=:SD_ID
        into :PHNUMBER
    do
    begin
        select count(*)
        from OTKAZNIK
        where OT_NUMBER = :PHNUMBER
        into :WASFOUND;

        if (WASFOUND = 1) then
            select AG_ID
            from OTKAZNIK
            where OT_NUMBER = :PHNUMBER
            into :AG_ID_IN;

        IS_IN = IS_IN + WASFOUND;
    end

    if (IS_IN = 0) then
    begin
        for
            select CP_NUMBER
            from CUST_PHONE
            where     AG_ID = :AG_ID
                  and CU_ID = :CUID
            into :PHNUMBER
        do
        begin
            select count(*)
            from OTKAZNIK
            where OT_NUMBER = :PHNUMBER
            into :WASFOUND;

            if (WASFOUND > 0) then
                select AG_ID
                from OTKAZNIK
                where OT_NUMBER = :PHNUMBER
                into :AG_ID_IN;

            IS_IN = IS_IN + WASFOUND;

/*            if (IS_IN > 0) then
                GOTO FINISH;*/
        end
    end

    if (IS_IN > 1) then
        IS_IN = 1;

    suspend;
END^


ALTER PROCEDURE IS_INTERCEPTED (
    AG_ID_INPUT INTEGER,
    PH_NUMBER CHAR(12))
RETURNS (
    RESULT INTEGER,
    AG_ID INTEGER,
    AG_ID_INTERCEPTED INTEGER)
AS
BEGIN
    SELECT COUNT(*) FROM OTKAZNIK OT
    WHERE OT.OT_NUMBER=:PH_NUMBER AND (OT.AG_ID<>:AG_ID_INPUT OR OT.AG_ID IS NULL)
    INTO :RESULT;
    
    IF (RESULT>0) THEN
        SELECT MAX(AG_ID) FROM OTKAZNIK OT
        WHERE OT.OT_NUMBER=:PH_NUMBER AND (OT.AG_ID<>:AG_ID_INPUT OR OT.AG_ID IS NULL)
        INTO :AG_ID_INTERCEPTED;
    
    AG_ID=AG_ID_INPUT;
    
    SUSPEND;
END^


ALTER PROCEDURE IS_RIGHT_NAME_GAZETA (
    AG_ID_INPUT INTEGER,
    SD_ID_INPUT INTEGER,
    NAME_GZ_INPUT VARCHAR(10))
RETURNS (
    IS_RIGHT INTEGER)
AS
declare variable isfree integer;
declare variable isname varchar(10);
declare variable isdate timestamp;
begin
--поумолчанию ставим "0"
is_right = 0;

    --перебираем все подачи и находим совпадение
    FOR
        SELECT PD.PD_FREE_OF_CHARGE, ISS.IS_NAME, ISS.IS_DATE
        FROM PODACHA PD
        LEFT JOIN ISSUE ISS ON (PD.IS_ID=ISS.IS_ID AND PD.GZ_ID=ISS.GZ_ID)
        WHERE PD.AG_ID=:AG_ID_INPUT AND PD.SD_ID=:SD_ID_INPUT
        ORDER BY PD.IS_ID
        INTO :ISFREE, :ISNAME, :ISDATE
    DO
    BEGIN
        --если совпало и номер газеты не закрыт "+1"
        if ((ISNAME = name_gz_input) and (ISFREE = 1)) then
        begin
             is_right = 1;
        end

    END
 SUSPEND;
end^


ALTER PROCEDURE IS_RIGHT_NAME_GZ (
    AG_ID_INPUT INTEGER,
    SD_ID_INPUT INTEGER,
    NAME_GZ_INPUT VARCHAR(10))
RETURNS (
    IS_RIGHT INTEGER)
AS
declare variable isfree integer;
declare variable isname varchar(10);
declare variable isdate timestamp;
begin
--поумолчанию ставим "0"
is_right = 0;

    --перебираем все подачи и находим совпадение
    FOR
        SELECT PD.PD_FREE_OF_CHARGE, ISS.IS_NAME, ISS.IS_DATE
        FROM PODACHA PD
        LEFT JOIN ISSUE ISS ON (PD.IS_ID=ISS.IS_ID AND PD.GZ_ID=ISS.GZ_ID)
        WHERE PD.AG_ID=:AG_ID_INPUT AND PD.SD_ID=:SD_ID_INPUT
        ORDER BY PD.IS_ID
        INTO :ISFREE, :ISNAME, :ISDATE
    DO
    BEGIN
        --если совпало и номер газеты не закрыт "+1"
        if (ISNAME = name_gz_input) then
        begin
             is_right = 1;
        end

    END
 SUSPEND;
end^


ALTER PROCEDURE ISSUE_STATISTIC (
    IS_ID INTEGER)
RETURNS (
    RB_NAME VARCHAR(256),
    RUB_SPACE1 DOUBLE PRECISION,
    RUB_SPACE2 DOUBLE PRECISION,
    RUB_DIFF DOUBLE PRECISION,
    RUB_COUNT1 INTEGER,
    RUB_COUNT2 INTEGER)
AS
declare variable RB_ID integer;
declare variable IS_ID_CURR integer;
declare variable GZ_ID integer;
begin
  /* Procedure Text */
 SELECT i.gz_id FROM issue i WHERE i.is_id = :is_id INTO :gz_id;

 IF (gz_id = 1) THEN SELECT p.pm_current_issue_pr FROM PARAMS p INTO :IS_ID_CURR;
 ELSE IF (gz_id = 2) THEN SELECT p.pm_current_issue_ns FROM PARAMS p INTO :IS_ID_CURR;
 ELSE IF (gz_id = 3) THEN SELECT p.pm_current_issue_sr FROM PARAMS p INTO :IS_ID_CURR;
 ELSE IF (gz_id = 4) THEN SELECT p.pm_current_issue_rz FROM PARAMS p INTO :IS_ID_CURR;
 ELSE IF (gz_id = 5) THEN SELECT p.pm_current_issue_rk FROM PARAMS p INTO :IS_ID_CURR;

 FOR SELECT r.rb_id, r.rb_name
     FROM rubrika r

     INTO :rb_id, :RB_NAME DO
 BEGIN
     rub_diff = 0;

     SELECT
         sum(f.FM_SPACE) as RUB_SPACE
     FROM
        MODULI_V_NOMER_NOMER(:is_id) ol
        left join FORMAT f on (f.FM_ID = ol.FM_ID)
     WHERE ol.rb_id = :rb_id
     INTO :rub_space1;

     SELECT
         sum(f.FM_SPACE) as RUB_SPACE
     FROM
        MODULI_V_NOMER_NOMER(:IS_ID_CURR) ol
        left join FORMAT f on (f.FM_ID = ol.FM_ID)
     WHERE ol.rb_id = :rb_id
     INTO :rub_space2;

     IF (:rub_space1 IS NULL) THEN rub_space1 = 0;
     IF (:rub_space2 IS NULL) THEN rub_space2 = 0;

     IF((:rub_space1 <> 0) OR (:rub_space2 <> 0)) THEN
     BEGIN
          IF (rub_space2 = 0) THEN rub_diff = rub_space1;
          ELSE IF (rub_space1 = 0) THEN rub_diff = rub_space2;
          ELSE rub_diff = rub_space2 - rub_space1;

     END

     SELECT COUNT(*)
     FROM
        OBJAV_LIST_V_NOMER_ALL(:is_id) ol

        LEFT JOIN OBJAV ob
        ON (ol.AG_ID = ob.AG_ID and ol.SD_ID = ob.SD_ID and ol.OB_ID = ob.OB_ID)
     WHERE
        ob.FM_ID IN (1, 17) AND ol.rb_id = :rb_id
     INTO :rub_count1;

     SELECT COUNT(*)
     FROM
        OBJAV_LIST_V_NOMER_ALL(:is_id_curr) ol

        LEFT JOIN OBJAV ob
        ON (ol.AG_ID = ob.AG_ID and ol.SD_ID = ob.SD_ID and ol.OB_ID = ob.OB_ID)
     WHERE
        ob.FM_ID IN (1, 17) AND ol.rb_id = :rb_id
     INTO :rub_count2;

      suspend;
 END
end^


ALTER PROCEDURE KA_NEW_POVTOR (
    AG_ID_SRC INTEGER,
    SD_ID INTEGER,
    OB_ID INTEGER,
    IS_MODULE SMALLINT,
    AG_ID_DST INTEGER,
    IS_ID INTEGER)
AS
declare variable SDID integer;
declare variable GZID integer;
declare variable CUID integer;
declare variable PDID integer;
declare variable CNT integer;
BEGIN
    SELECT COUNT(*)
  FROM sdelka s
  WHERE s.ag_id = :ag_id_src
        AND s.sd_comment = 'Повтор для КА, IS_ID=' || :is_id || ', OB_ID=' || :ob_id
    INTO :cnt;
    IF (cnt > 0) THEN
      EXCEPTION E_KA_DOUBLE_POVTOR;
    SELECT s.gz_id, s.cu_id
    FROM sdelka s
    WHERE s.ag_id = :ag_id_src AND s.sd_id = :sd_id
    INTO gzid, cuid;
    IF (gzid IS NULL OR cuid IS NULL) THEN
        EXCEPTION E_CANNOT_FIND_SDELKA;
    SELECT COUNT(*)
    FROM issue i
    WHERE i.is_id = :is_id and i.gz_id = :gzid
    INTO :cnt;
    IF (cnt <> 1) THEN
        EXCEPTION E_WRONG_GAZETA;
    sdid = GEN_ID(g_sd_id, 1);
    INSERT INTO sdelka (
         ag_id
        ,sd_id
        ,sd_type
        ,sd_state
        ,pt_id
        ,gz_id
        ,cu_id
        ,as_id
/*        ,sd_is_changed_copy_of_sd_id
*/
        ,sd_date
        ,sd_comment
        ,sd_sum
        ,sd_percent
/*      ,sd_sum_default
        ,sd_percent_default
        ,sd_skidka
        ,sd_sum_payed
        ,sd_all_payed
        ,sd_pay_date
        ,sd_pay_now
        ,sd_fact_num
        ,sd_fact_date
*/
        ,sd_approved_date
        ,sd_is_beznal_v_nal
        ,sd_show_cust_id
        ,sd_is_important_for_site
/*      ,sd_ka_start_date
        ,sd_ka_end_date
*/
    )
    VALUES (
         :ag_id_dst
        ,:sdid
        ,1
        ,2
        ,1 /* нал */
        ,:gzid
        ,:cuid
        ,0
        ,CURRENT_TIMESTAMP
        ,'Повтор для КА, IS_ID=' || :is_id || ', OB_ID=' || :ob_id
        ,0
        ,0
        ,NULL
        ,0
        ,0
        ,0
    );

  /* повторно сбрасываем в 0 сумму и %, т.к. они после
     вставки ставятся в значения по умолчанию */  
  update SDELKA s
  set s.SD_SUM = 0, s.SD_PERCENT = 0
  where s.AG_ID = :ag_id_dst
        and s.SD_ID = :sdid;
  
    pdid = GEN_ID(g_pd_id, 1);
    INSERT INTO podacha (
         pd_id
        ,ag_id
        ,sd_id
        ,gz_id
        ,is_id
        ,pd_free_of_charge
    )
    VALUES (
         :pdid
        ,:ag_id_dst
        ,:sdid
        ,:gzid
        ,:is_id
        ,0
    );
    IF (is_module = 0) THEN
        EXECUTE PROCEDURE copy_objav(:ag_id_src, :sd_id, :ob_id, :ag_id_dst, :sdid);
/*$$IBEC$$     ELSE
        EXECUTE PROCEDURE copy_objavlenie(:ob_id, :pdid); $$IBEC$$*/
END^


ALTER PROCEDURE KASSA_NAL (
    AG_ID INTEGER,
    SD_ID INTEGER,
    SD_PERCENT FLOAT)
AS
begin
  /* Procedure Text */
    UPDATE SDELKA SD
    SET SD.PT_ID = 1,
        SD.SD_SUM_PAYED=SD.SD_SUM,
        SD.SD_PERCENT=:SD_PERCENT,
        SD.SD_ALL_PAYED=1,
        SD.SD_PAY_DATE=CURRENT_TIMESTAMP
    WHERE
        SD.AG_ID=:AG_ID AND
        SD.SD_ID=:SD_ID;

end^


ALTER PROCEDURE LOCK_RUBRIKAS (
    US_ID INTEGER,
    DO_LOCK SMALLINT)
AS
declare variable agid integer;
BEGIN
    for
        select AG_ID
        from USR_RIGHTS
        where US_ID = :US_ID
        into :AGID
    do
    begin
        update AGENT
        set AG_LOCK_RUBRIKAS = :DO_LOCK
        where AG_ID = :AGID;
    end
END^


ALTER PROCEDURE LOG_SDELKA_CHANGES (
    AG_ID INTEGER,
    SD_ID INTEGER,
    US_ID INTEGER)
AS
begin
    insert into SDELKA_CHANGE_LOG(SL_ID, AG_ID, SD_ID, SD_STATE, AS_ID, CHANGE_DATE, US_ID, PT_ID)
    select
        gen_id(G_SL_ID, 1)
        , sd.AG_ID
        , sd.SD_ID
        , sd.SD_STATE
        , sd.AS_ID
        , CURRENT_TIMESTAMP
        , :US_ID
        , sd.PT_ID
    from
        SDELKA sd
    where
        sd.AG_ID = :AG_ID and sd.SD_ID = :SD_ID;
end^


ALTER PROCEDURE LOG_USER (
    EDITORNAME VARCHAR(64),
    EDITORADDR VARCHAR(64))
AS
BEGIN
    INSERT INTO USER_LOG(UL_US_ID,UL_TABLE,UL_CHANGE_TYPE)
    VALUES (:EDITORNAME,:EDITORADDR,'START-EDITING');

    POST_EVENT 'USER_CHANGED';
END^


ALTER PROCEDURE MODULE_CHANGE_HISTORY (
    CONTENT_ID INTEGER,
    DPTH INTEGER)
RETURNS (
    CONT_ID INTEGER)
AS
begin
  /* Procedure Text */
  IF (DPTH = 0) THEN
  BEGIN
       CONT_ID = CONTENT_ID;
       SUSPEND;
  END
  DPTH = DPTH + 1;
  SELECT oc.OLD_CONTENT_ID_LINK FROM OBJAV_CONTENT oc WHERE oc.CONTENT_ID = :CONTENT_ID INTO :CONT_ID;
  IF (:CONT_ID IS NULL) THEN EXIT;
  SUSPEND;
  FOR SELECT mh.CONT_ID FROM MODULE_CHANGE_HISTORY(:CONT_ID, :DPTH) mh INTO :CONT_ID DO SUSPEND;
end^


ALTER PROCEDURE MODULE_LOAD_LOG (
    US_ID INTEGER,
    OBJAV_ID INTEGER,
    CONTENT_ID INTEGER,
    TYP INTEGER)
AS
begin
  /* Procedure Text */
  INSERT INTO objav_content_load_log (ID, LL_DATE, US_ID, OBJAV_ID, CONTENT_ID, LOG_TYPE)
  VALUES(NULL, CURRENT_TIMESTAMP, :US_ID, :OBJAV_ID, :CONTENT_ID, :TYP);

end^


ALTER PROCEDURE MODULI_V_NOMER (
    GZ_ID INTEGER)
RETURNS (
    AG_ID INTEGER,
    SD_ID INTEGER,
    OB_ID INTEGER,
    RB_ID INTEGER,
    FM_ID INTEGER,
    OBJAV_HAS_ATTENTION SMALLINT,
    CONTENT_ID INTEGER)
AS
declare variable ISID integer;
declare variable DBRBID integer;
BEGIN
    EXECUTE PROCEDURE GET_CURRENT_ISSUE(GZ_ID)
    RETURNING_VALUES :ISID;

    FOR
        SELECT
             m.AG_ID
            ,m.SD_ID
            ,m.OB_ID
            ,m.RB_ID
            ,m.FM_ID
            ,m.OBJAV_HAS_ATTENTION
            ,m.CONTENT_ID
        FROM
            MODULI_V_NOMER_NOMER(:ISID) m
        INTO
             :AG_ID,
             :SD_ID,
             :OB_ID,
             :RB_ID,
             :FM_ID,
             :OBJAV_HAS_ATTENTION,
             :CONTENT_ID
    DO
    BEGIN
        SUSPEND;
    END
END^


ALTER PROCEDURE MODULI_V_NOMER_2 (
    GZ_ID INTEGER)
RETURNS (
    AG_ID INTEGER,
    SD_ID INTEGER,
    OB_ID INTEGER,
    RB_ID INTEGER,
    FM_ID INTEGER,
    OBJAV_HAS_ATTENTION SMALLINT,
    CONTENT_ID INTEGER)
AS
declare variable ISID integer;
declare variable DBRBID integer;
BEGIN
    isid = 4546;
    FOR
        SELECT
             m.AG_ID
            ,m.SD_ID
            ,m.OB_ID
            ,m.RB_ID
            ,m.FM_ID
            ,m.OBJAV_HAS_ATTENTION
            ,m.CONTENT_ID
        FROM
            MODULI_V_NOMER_NOMER(:ISID) m
        INTO
             :AG_ID,
             :SD_ID,
             :OB_ID,
             :RB_ID,
             :FM_ID,
             :OBJAV_HAS_ATTENTION,
             :CONTENT_ID
    DO
    BEGIN
        SUSPEND;
    END
END^


ALTER PROCEDURE MODULI_V_NOMER_NOMER (
    IS_ID INTEGER)
RETURNS (
    AG_ID INTEGER,
    SD_ID INTEGER,
    OB_ID INTEGER,
    RB_ID INTEGER,
    FM_ID INTEGER,
    OBJAV_HAS_ATTENTION SMALLINT,
    CONTENT_ID INTEGER)
AS
DECLARE VARIABLE DBRBID INTEGER;
DECLARE VARIABLE ISID INTEGER;
BEGIN
    FOR
        SELECT
            PD.AG_ID,
            PD.SD_ID,
            OBJ.OBJAV_ID,
            OBJ.RB_ID,
            OBJ.DOUBLE_RB_ID,
            OBJ.FM_ID,
            OBJ.OBJAV_HAS_ATTENTION,
            OBJ.CONTENT_ID
        FROM
            PODACHA PD
            LEFT JOIN OBJAVLENIE OBJ
            ON (PD.PD_ID=OBJ.PD_ID)
            LEFT JOIN SDELKA SD
            ON  (SD.AG_ID=PD.AG_ID AND SD.SD_ID=PD.SD_ID)
            LEFT JOIN FORMAT FM
            ON (FM.FM_ID = OBJ.FM_ID)
        WHERE
             PD.IS_ID=:IS_ID AND
             FM.FM_HAS_PICTURE=1 AND
             OBJ.CONTENT_ID IS NOT NULL AND
             SD_STATE<>100 AND
             AS_ID<>2 AND
             AS_ID<>1
        INTO
             :AG_ID,
             :SD_ID,
             :OB_ID,
             :RB_ID,
             :DBRBID,
             :FM_ID,
             :OBJAV_HAS_ATTENTION,
             :CONTENT_ID
    DO
    BEGIN
        SUSPEND;
        IF (DBRBID > 0) THEN
        BEGIN
            RB_ID = DBRBID;
            SUSPEND;
        END
    END

/*
    Если текущий ПР, то выведем также все объявления РкБ,
    которые идут в его текущий номер
*/
/*
    execute procedure get_current_issue(1)
    returning_values :isid;

    if (isid = :is_id) then
    begin
        execute procedure get_current_issue(2)
        returning_values :isid;

        for
            select
                ob.AG_ID, ob.SD_ID, ob.OB_ID, r_pr.RB_ID, ob.FM_ID, ob.OBJAV_HAS_ATTENTION, ob.CONTENT_ID
            from
                moduli_v_nomer_nomer(:isid) ob
                left join RUBRIKA r_rkb on (r_rkb.RB_ID = ob.RB_ID)
                left join RUBRIKA r_pr on (r_pr.RB_NAME_SHORT = r_rkb.RB_NAME_SHORT and r_pr.GZ_ID = 1)
            where
                r_pr.RB_ID is not null
            into
                :AG_ID, :SD_ID, :OB_ID, :RB_ID, :FM_ID, :OBJAV_HAS_ATTENTION, :CONTENT_ID
        do
            suspend;
    end
*/
END^


ALTER PROCEDURE MODULI_V_NOMER_TEST (
    GZ_ID INTEGER)
RETURNS (
    AG_ID INTEGER,
    SD_ID INTEGER,
    OB_ID INTEGER,
    RB_ID INTEGER,
    FM_ID INTEGER,
    OBJAV_HAS_ATTENTION SMALLINT,
    CONTENT_ID INTEGER)
AS
declare variable ISID integer;
declare variable DBRBID integer;
BEGIN
/*$$IBEC$$     EXECUTE PROCEDURE GET_CURRENT_ISSUE(GZ_ID)
    RETURNING_VALUES :ISID; $$IBEC$$*/

    FOR
        SELECT
             m.AG_ID
            ,m.SD_ID
            ,m.OB_ID
            ,m.RB_ID
            ,m.FM_ID
            ,m.OBJAV_HAS_ATTENTION
            ,m.CONTENT_ID
        FROM
            MODULI_V_NOMER_NOMER(:gz_id) m
        INTO
             :AG_ID,
             :SD_ID,
             :OB_ID,
             :RB_ID,
             :FM_ID,
             :OBJAV_HAS_ATTENTION,
             :CONTENT_ID
    DO
    BEGIN
        SUSPEND;
    END
END^


ALTER PROCEDURE NAL_KASSA (
    AG_ID INTEGER,
    SD_ID INTEGER)
AS
begin
  /* Procedure Text */

  UPDATE sdelka s
  SET s.pt_id = 6,
      s.sd_state = 2
  WHERE s.ag_id = :ag_id AND
        s.sd_id = :sd_id;

end^


ALTER PROCEDURE NAL_V_BEZNAL (
    AG_ID INTEGER,
    SD_ID INTEGER)
AS
begin
    UPDATE SDELKA SD
    SET SD.PT_ID=2,
        SD.SD_STATE=2
    WHERE
        SD.AG_ID=:AG_ID AND
        SD.SD_ID=:SD_ID AND
        SD.PT_ID=1 AND
        SD.SD_STATE<4;
end^


ALTER PROCEDURE NAL_V_KREDIT (
    AG_ID INTEGER,
    SD_ID INTEGER)
AS
BEGIN
     UPDATE SDELKA SD
     SET SD.PT_ID=3,
         SD.SD_STATE=2
     WHERE
         SD.AG_ID=:AG_ID AND
         SD.SD_ID=:SD_ID;
END^


ALTER PROCEDURE NEW_OBJAVS_IN_ISSUE (
    IS_ID INTEGER)
RETURNS (
    AG_ID INTEGER,
    SD_ID INTEGER,
    OB_ID INTEGER)
AS
DECLARE VARIABLE MINIS INTEGER;
DECLARE VARIABLE FMID INTEGER;
BEGIN
    FOR
        SELECT PD.AG_ID,PD.SD_ID
        FROM PODACHA PD
        WHERE PD.IS_ID=:IS_ID
        INTO :AG_ID,:SD_ID
    DO
    BEGIN
        SELECT MIN(PD.IS_ID)
        FROM PODACHA PD
        WHERE PD.AG_ID=:AG_ID AND
              PD.SD_ID=:SD_ID AND
              PD.IS_ID>1
        INTO :MINIS;
        IF (MINIS=:IS_ID) THEN
            FOR
                SELECT OB.OB_ID FROM OBJAV OB
                WHERE OB.AG_ID=:AG_ID AND OB.SD_ID=:SD_ID AND (OB.FM_ID=1 OR OB.FM_ID=17) AND OB.OB_PARENT IS NULL
                INTO :OB_ID
            DO
                SUSPEND;
    END
END^


ALTER PROCEDURE NEW_SDELKAS_IN_ISSUE (
    IS_ID INTEGER)
RETURNS (
    AG_ID INTEGER,
    SD_ID INTEGER)
AS
DECLARE VARIABLE MINIS INTEGER;
DECLARE VARIABLE FMID INTEGER;
BEGIN
    FOR
        SELECT PD.AG_ID,PD.SD_ID
        FROM PODACHA PD
        WHERE PD.IS_ID=:IS_ID
        INTO :AG_ID,:SD_ID
    DO
    BEGIN
        SELECT MIN(PD.IS_ID)
        FROM PODACHA PD
        WHERE PD.AG_ID=:AG_ID AND
              PD.SD_ID=:SD_ID AND
              PD.IS_ID>1
        INTO :MINIS;
        IF (MINIS=:IS_ID) THEN
            SUSPEND;
    END
END^


ALTER PROCEDURE NEXT_AG_ID
RETURNS (
    NEXT_AG_ID INTEGER)
AS
 BEGIN
  NEXT_AG_ID=GEN_ID(G_AG_ID,1);
END^


ALTER PROCEDURE NEXT_CU_ID
RETURNS (
    NEXT_CU_ID INTEGER)
AS
 BEGIN
  NEXT_CU_ID=GEN_ID(G_CU_ID,1);
END^


ALTER PROCEDURE NEXT_CUQ_ID
RETURNS (
    NEXT_CUQ_ID INTEGER)
AS
BEGIN
  NEXT_CUQ_ID=GEN_ID(G_CUQ_ID,1);
END^


ALTER PROCEDURE NEXT_CURRENT_ISSUE (
    GZ_ID INTEGER)
AS
DECLARE VARIABLE NEWISID INTEGER;
DECLARE VARIABLE OLDISID INTEGER;
DECLARE VARIABLE OLDISDATE TIMESTAMP;
DECLARE VARIABLE OLDPDID INTEGER;
DECLARE VARIABLE NEWPDID INTEGER;
DECLARE VARIABLE PDISDONE INTEGER;
DECLARE VARIABLE AGID INTEGER;
DECLARE VARIABLE SDID INTEGER;
BEGIN
    EXECUTE PROCEDURE GET_CURRENT_ISSUE(GZ_ID)
    RETURNING_VALUES :OLDISID;

    SELECT ISS.IS_DATE
    FROM ISSUE ISS
    WHERE ISS.IS_ID=:OLDISID
    INTO :OLDISDATE;
    SELECT ISS.IS_ID FROM ISSUE ISS
    WHERE ISS.GZ_ID=:GZ_ID AND
          ISS.IS_DATE=(
                        SELECT MIN(ISS2.IS_DATE)
                        FROM ISSUE ISS2
                        WHERE ISS2.GZ_ID=:GZ_ID AND
                              ISS2.IS_DATE>:OLDISDATE
                      )
    INTO :NEWISID;
/* проставим как "вышедшие" все подачи в закрываемый номер */
    UPDATE PODACHA
    SET PD_IS_DONE = 1
    WHERE IS_ID = :OLDISID;

    IF (GZ_ID=1) THEN
        UPDATE PARAMS
        SET PM_CURRENT_ISSUE_PR=:NEWISID;
    ELSE IF (GZ_ID=2) THEN
        UPDATE PARAMS
        SET PM_CURRENT_ISSUE_NS=:NEWISID;
    ELSE IF (GZ_ID=3) THEN
        UPDATE PARAMS
        SET PM_CURRENT_ISSUE_SR=:NEWISID;
    ELSE IF (GZ_ID=4) THEN
        UPDATE PARAMS
        SET PM_CURRENT_ISSUE_RZ=:NEWISID;
    ELSE IF (GZ_ID=5) THEN
        UPDATE PARAMS
        SET PM_CURRENT_ISSUE_RK=:NEWISID;
END^


ALTER PROCEDURE NEXT_FM_ID
RETURNS (
    NEXT_FM_ID INTEGER)
AS
BEGIN
  NEXT_FM_ID=GEN_ID(G_FM_ID,1);
END^


ALTER PROCEDURE NEXT_GG_ID
RETURNS (
    NEXT_GG_ID INTEGER)
AS
BEGIN
  NEXT_GG_ID=GEN_ID(G_GG_ID,1);
END^


ALTER PROCEDURE NEXT_IS_ID
RETURNS (
    NEXT_IS_ID INTEGER)
AS
 BEGIN
  NEXT_IS_ID=GEN_ID(G_IS_ID,1);
END^


ALTER PROCEDURE NEXT_OB_ID
RETURNS (
    NEXT_OB_ID INTEGER)
AS
BEGIN
  NEXT_OB_ID=GEN_ID(G_OB_ID,1);
END^


ALTER PROCEDURE NEXT_RB_ID
RETURNS (
    NEXT_RB_ID INTEGER)
AS
BEGIN
  NEXT_RB_ID=GEN_ID(G_RB_ID,1);
END^


ALTER PROCEDURE NEXT_SD_ID (
    AG_ID INTEGER)
RETURNS (
    NEXT_SD_ID INTEGER)
AS
BEGIN
  NEXT_SD_ID = GEN_ID(G_SD_ID,1);
  WHILE (EXISTS(SELECT 1 FROM sdelka s WHERE s.ag_id = :AG_ID AND s.sd_id = :next_sd_id)) DO
  BEGIN
          NEXT_SD_ID = NEXT_SD_ID + 1;
  END
END^


ALTER PROCEDURE NEXT_US_ID
RETURNS (
    NEXT_US_ID INTEGER)
AS
 BEGIN
  NEXT_US_ID=GEN_ID(G_US_ID,1);
END^


ALTER PROCEDURE OB_STATE_LOG (
    OB_ID INTEGER,
    US_ID INTEGER,
    NEW_STATE INTEGER)
AS
begin
  /* Procedure Text */
  INSERT INTO OBJAVLENIE_LOG(OL_ID, OB_ID, US_ID, NEW_STATE, EDIT_TIME)
  VALUES(NULL,:OB_ID, :US_ID, :NEW_STATE, CURRENT_TIMESTAMP);
end^


ALTER PROCEDURE OBJAV_CONTENT_DELETE (
    BEGIN_DATE TIMESTAMP,
    END_DATE TIMESTAMP)
AS
declare variable CONT_ID integer;
declare variable CNT integer;
begin
 for
    select oc.content_id
    from objav_content oc
    where (oc.create_date between :BEGIN_DATE and :end_date)
    into
        :cont_id
 do
  begin

    select count(*)
    from
        OBJAVLENIE_DUPL od, OBJAVLENIE o, PODACHA p
    where
          o.objav_id = :cont_id
          and (o.OBJAV_ID = od.DUPL_OF_OBJAV_ID)
          and (p.PD_ID = o.PD_ID)
--          od.OBJAV_ID = old.OBJAV_ID
          and not exists (
              select 1
              from SDELKA_DUPLICATING d
              where d.AG_ID = p.AG_ID
                    and d.SD_ID = p.SD_ID
                    and d.CALL_COUNT > 0
          )
    into :cnt;

    if (cnt = 0) then
     begin
      --удаляем объявление с таблицы objav_content_site_objav
      delete from objav_content_site_objav ocso
             where ocso.content_id = :cont_id;

      --удаляем объявление с таблицы objavlenie, которые связанные с табл. objav_content
      delete from objavlenie ob
            where ob.content_id = :cont_id;

      delete from objav_content oc
            where oc.content_id = :cont_id;
     end

  end

 suspend;
end^


ALTER PROCEDURE OBJAV_DUPLICATE (
    P_DUPLICATE_AG_ID INTEGER,
    P_DUPLICATE_SD_ID INTEGER,
    P_SOURCE_OB_ID INTEGER)
AS
DECLARE VARIABLE DUPLICATE_OB_ID INTEGER;
DECLARE VARIABLE CNT INTEGER;
DECLARE VARIABLE SOURCE_AG_ID INTEGER;
DECLARE VARIABLE SOURCE_SD_ID INTEGER;
DECLARE VARIABLE RUB_FOUND INTEGER;
DECLARE VARIABLE DUPLICATE_GZ_ID INTEGER;
DECLARE VARIABLE SOURCE_OB_COMMENT VARCHAR(127);
DECLARE VARIABLE SOURCE_OB_FOR_INTERNET SMALLINT;
DECLARE VARIABLE SOURCE_OB_HAS_ATTENTION SMALLINT;
DECLARE VARIABLE SOURCE_OB_IS_ACTIVE SMALLINT;
DECLARE VARIABLE SOURCE_OB_STATE SMALLINT;
DECLARE VARIABLE SOURCE_OB_TEXT VARCHAR(2047);
DECLARE VARIABLE SOURCE_OB_VAC_COUNT SMALLINT;
DECLARE VARIABLE SOURCE_RB_ID INTEGER;
DECLARE VARIABLE SOURCE_RS_ID INTEGER;
DECLARE VARIABLE SOURCE_FM_ID INTEGER;
DECLARE VARIABLE SOURCE_OB_CHANGED TIMESTAMP;
DECLARE VARIABLE SOURCE_OB_IS_OPTIONAL SMALLINT;
DECLARE VARIABLE SOURCE_DISTRICT_ID INTEGER;
begin
    -- Определим, заведен ли уже дубль этого объявления
    select count(*)
    from OBJAV_DUPL odu
    where odu.AG_ID = :P_DUPLICATE_AG_ID
          and odu.SD_ID = :P_DUPLICATE_SD_ID
          and odu.DUPL_OF_OB_ID = :P_SOURCE_OB_ID
    into :cnt;

    select sdu.DUPL_OF_AG_ID, sdu.DUPL_OF_SD_ID, sdd.GZ_ID
    from SDELKA_DUPL sdu
    left join SDELKA sdd on (sdd.AG_ID = sdu.AG_ID and sdd.SD_ID = sdu.SD_ID)
    where sdu.AG_ID = :P_DUPLICATE_AG_ID
          and sdu.SD_ID = :P_DUPLICATE_SD_ID
    into :source_ag_id, :source_sd_id, :duplicate_gz_id;

    -- Установим признак, что объявление в данный момент дублируется
    execute procedure sdelka_duplicating_start(:source_ag_id, :source_sd_id);

    -- Не заведен - заведем
    if (cnt = 0) then
    begin
        -- Проверим, есть ли такая рубрика
        select count(*)
        from OBJAV o
        inner join RUBRIKA r_source on (r_source.RB_ID = o.RB_ID)
        inner join RUBRIKA r_duplicate on (r_duplicate.GZ_ID = :duplicate_gz_id and r_duplicate.RB_NAME_SHORT = r_source.RB_NAME_SHORT)
        where o.AG_ID = :source_ag_id
              and o.SD_ID = :source_sd_id
              and o.OB_ID = :P_SOURCE_OB_ID
        into :rub_found;

        if (rub_found = 1) then
        begin
            duplicate_ob_id = gen_id(G_OB_ID, 1);

            insert into OBJAV (
                AG_ID
                ,SD_ID
                ,OB_ID
                ,OB_STATE
                ,OB_IS_ACTIVE
                ,OB_PARENT
                ,FM_ID
                ,RB_ID
                ,OB_ORDER
                ,OB_COMMENT
                ,OB_TEXT
                ,OB_FOR_INTERNET
                ,OB_CHANGED
                ,RS_ID
                ,OB_VAC_COUNT
                ,OB_HAS_ATTENTION
                ,OB_IS_OPTIONAL
                ,DISTRICT_ID
            )
            select
                :P_DUPLICATE_AG_ID
                ,:P_DUPLICATE_SD_ID
                ,:duplicate_ob_id
                ,OB_STATE
                ,OB_IS_ACTIVE
                ,OB_PARENT
                ,FM_ID
                ,r_duplicate.RB_ID
                ,OB_ORDER
                ,OB_COMMENT
                ,OB_TEXT
                ,OB_FOR_INTERNET
                ,OB_CHANGED
                ,RS_ID
                ,OB_VAC_COUNT
                ,OB_HAS_ATTENTION
                ,OB_IS_OPTIONAL
                ,DISTRICT_ID
            from OBJAV o
            inner join RUBRIKA r_source on (r_source.RB_ID = o.RB_ID)
            inner join RUBRIKA r_duplicate on (r_duplicate.GZ_ID = :duplicate_gz_id and r_duplicate.RB_NAME_SHORT = r_source.RB_NAME_SHORT)
            where o.AG_ID = :source_ag_id
                  and o.SD_ID = :source_sd_id
                  and o.OB_ID = :P_SOURCE_OB_ID;

            insert into OBJAV_DUPL (
                AG_ID
                ,SD_ID
                ,OB_ID
                ,DUPL_OF_AG_ID
                ,DUPL_OF_SD_ID
                ,DUPL_OF_OB_ID
            )
            values (
                :P_DUPLICATE_AG_ID
                ,:P_DUPLICATE_SD_ID
                ,:duplicate_ob_id
                ,:source_ag_id
                ,:source_sd_id
                ,:P_SOURCE_OB_ID
            );
        end
    end
    -- Заведен - обновим
    else if (cnt = 1) then
    begin
        select odu.OB_ID
        from OBJAV_DUPL odu
        where odu.AG_ID = :P_DUPLICATE_AG_ID
              and odu.SD_ID = :P_DUPLICATE_SD_ID
              and odu.DUPL_OF_OB_ID = :P_SOURCE_OB_ID
        into :duplicate_ob_id;

        -- Проверим, есть ли такая рубрика
        select count(*)
        from OBJAV o
        inner join RUBRIKA r_source on (r_source.RB_ID = o.RB_ID)
        inner join RUBRIKA r_duplicate on (r_duplicate.GZ_ID = :duplicate_gz_id and r_duplicate.RB_NAME_SHORT = r_source.RB_NAME_SHORT)
        where o.AG_ID = :source_ag_id
              and o.SD_ID = :source_sd_id
              and o.OB_ID = :P_SOURCE_OB_ID
        into :rub_found;

        -- Если такой рубрики нет, но объявление сдублировано - удалим его
        if (rub_found = 0) then
        begin
            delete from OBJAV_DUPL odu
            where odu.AG_ID = :P_DUPLICATE_AG_ID
                  and odu.SD_ID = :P_DUPLICATE_SD_ID
                  and odu.DUPL_OF_OB_ID = :P_SOURCE_OB_ID;

            delete from OBJAV ob
            where ob.AG_ID = :P_DUPLICATE_AG_ID
                  and ob.SD_ID = :P_DUPLICATE_SD_ID
                  and ob.OB_ID = :duplicate_ob_id;
        end
        -- Если рубрика есть, и объявление сдублировано - обновим его
        else if (rub_found = 1) then
        begin
            select
                OB_STATE
                ,OB_IS_ACTIVE
                ,FM_ID
                ,r_duplicate.RB_ID
                ,OB_COMMENT
                ,OB_TEXT
                ,OB_FOR_INTERNET
                ,OB_CHANGED
                ,RS_ID
                ,OB_VAC_COUNT
                ,OB_HAS_ATTENTION
                ,OB_IS_OPTIONAL
                ,DISTRICT_ID
            from OBJAV o
            inner join RUBRIKA r_source on (r_source.RB_ID = o.RB_ID)
            inner join RUBRIKA r_duplicate on (r_duplicate.GZ_ID = :duplicate_gz_id and r_duplicate.RB_NAME_SHORT = r_source.RB_NAME_SHORT)
            where o.AG_ID = :source_ag_id
                  and o.SD_ID = :source_sd_id
                  and o.OB_ID = :P_SOURCE_OB_ID
            into
                :source_OB_STATE
                ,:source_OB_IS_ACTIVE
                ,:source_FM_ID
                ,:source_RB_ID
                ,:source_OB_COMMENT
                ,:source_OB_TEXT
                ,:source_OB_FOR_INTERNET
                ,:source_OB_CHANGED
                ,:source_RS_ID
                ,:source_OB_VAC_COUNT
                ,:source_OB_HAS_ATTENTION
                ,:source_OB_IS_OPTIONAL
                ,:source_DISTRICT_ID;

            update OBJAV ob
            set
                ob.OB_STATE = :source_OB_STATE
                ,ob.OB_IS_ACTIVE = :source_OB_IS_ACTIVE
                ,ob.FM_ID = :source_FM_ID
                ,ob.RB_ID = :source_RB_ID
                ,ob.OB_COMMENT = :source_OB_COMMENT
                ,ob.OB_TEXT = :source_OB_TEXT
                ,ob.OB_FOR_INTERNET = :source_OB_FOR_INTERNET
                ,ob.OB_CHANGED = :source_OB_CHANGED
                ,ob.RS_ID = :source_RS_ID
                ,ob.OB_VAC_COUNT = :source_OB_VAC_COUNT
                ,ob.OB_HAS_ATTENTION = :source_OB_HAS_ATTENTION
                ,ob.OB_IS_OPTIONAL = :source_OB_IS_OPTIONAL
                ,ob.DISTRICT_ID = :source_DISTRICT_ID
            where ob.AG_ID = :P_DUPLICATE_AG_ID
                  and ob.SD_ID = :P_DUPLICATE_SD_ID
                  and ob.OB_ID = :duplicate_ob_id;
        end
    end

    -- Снимем признак, что сделка в данный момент дублируется
    execute procedure sdelka_duplicating_end(:source_ag_id, :source_sd_id);
end^


ALTER PROCEDURE OBJAV_DUPLICATE_ALL (
    P_DUPLICATE_AG_ID INTEGER,
    P_DUPLICATE_SD_ID INTEGER)
AS
DECLARE VARIABLE SOURCE_AG_ID INTEGER;
DECLARE VARIABLE SOURCE_SD_ID INTEGER;
DECLARE VARIABLE DUPLICATE_GZ_ID INTEGER;
DECLARE VARIABLE SOURCE_OB_ID INTEGER;
begin
    -- Находим исходную сделку
    select sdu.DUPL_OF_AG_ID, sdu.DUPL_OF_SD_ID, sdd.GZ_ID
    from SDELKA_DUPL sdu
    left join SDELKA sdd on (sdd.AG_ID = sdu.AG_ID and sdd.SD_ID = sdu.SD_ID)
    where sdu.AG_ID = :P_DUPLICATE_AG_ID
          and sdu.SD_ID = :P_DUPLICATE_SD_ID
    into :source_ag_id, :source_sd_id, :duplicate_gz_id;

    -- Удаляем продублированные объявления.
    -- Из основной таблицы после удаления из развязки
    -- они удалятся триггером.

    -- Перед этим установим признак, что мы дублируем объявления
    execute procedure sdelka_duplicating_start(:source_ag_id, :source_sd_id);

    delete from OBJAV_DUPL o
    where o.AG_ID = :P_DUPLICATE_AG_ID
          and o.SD_ID = :P_DUPLICATE_SD_ID;

    -- Снимем признак, что мы дублируем объявления
    execute procedure sdelka_duplicating_end(:source_ag_id, :source_sd_id);

    -- Дублируем объявления
    for
        select o.OB_ID
        from OBJAV o
        where o.AG_ID = :source_ag_id
              and o.SD_ID = :source_sd_id
        into :source_ob_id
    do
        execute procedure objav_duplicate(:P_DUPLICATE_AG_ID, :P_DUPLICATE_SD_ID, :source_ob_id);
end^


ALTER PROCEDURE OBJAV_LIST_FOR_DESIGN (
    GZ_ID INTEGER)
RETURNS (
    AG_ID INTEGER,
    SD_ID INTEGER,
    OB_ID INTEGER)
AS
declare variable ISID integer;
BEGIN
    EXECUTE PROCEDURE GET_CURRENT_ISSUE(GZ_ID)
    RETURNING_VALUES :ISID;
    FOR
        SELECT
            PD.AG_ID AS AG_ID,
            PD.SD_ID AS SD_ID,
            OBJ.OBJAV_ID
        FROM
            PODACHA PD
            LEFT JOIN OBJAVLENIE OBJ
            ON (OBJ.PD_ID=PD.PD_ID)
            LEFT JOIN SDELKA SD
            ON  (SD.AG_ID=PD.AG_ID AND SD.SD_ID=PD.SD_ID)
            LEFT JOIN FORMAT FM
            ON (FM.FM_ID = OBJ.FM_ID)
            LEFT JOIN OBJAVLENIE_DUPL ODU
            ON (ODU.OBJAV_ID = OBJ.OBJAV_ID)
            LEFT JOIN OBJAV_CONTENT oc
            ON(oc.CONTENT_ID = obj.CONTENT_ID)
        WHERE
             PD.IS_ID=:ISID AND
             FM.FM_HAS_PICTURE=1 AND
             ODU.OBJAV_ID is null AND
             oc.CONTENT_PICTURE IS NULL AND
             SD_STATE > 2 AND
             AS_ID<>2 AND
             AS_ID<>1

UNION    -- Измененные модули
        SELECT
            PD.AG_ID AS AG_ID,
            PD.SD_ID AS SD_ID,
            OBJ.OBJAV_ID
        FROM
            PODACHA PD
            LEFT JOIN OBJAVLENIE OBJ
            ON (OBJ.PD_ID=PD.PD_ID)
            LEFT JOIN SDELKA SD
            ON  (SD.AG_ID=PD.AG_ID AND SD.SD_ID=PD.SD_ID)
            LEFT JOIN FORMAT FM
            ON (FM.FM_ID = OBJ.FM_ID)
            LEFT JOIN OBJAVLENIE_DUPL ODU
            ON (ODU.OBJAV_ID = OBJ.OBJAV_ID)
        WHERE
             PD.IS_ID=:ISID AND
             FM.FM_HAS_PICTURE=1 AND
             ODU.OBJAV_ID is null AND
             OBJ.OB_STATE = 3  AND
             SD_STATE > 2 AND
             AS_ID<>2 AND
             AS_ID<>1
        INTO
            :AG_ID,:SD_ID,:OB_ID
    DO
        SUSPEND;
END^


ALTER PROCEDURE OBJAV_LIST_FOR_INT_NABOR (
    GZ_ID INTEGER)
RETURNS (
    AG_ID INTEGER,
    SD_ID INTEGER,
    OB_ID INTEGER,
    RB_ID INTEGER,
    FM_ID INTEGER,
    OBJAV_HAS_ATTENTION INTEGER,
    CONTENT_ID INTEGER,
    K INTEGER)
AS
declare variable ISID integer;
begin
  /* Procedure Text */
    EXECUTE PROCEDURE GET_CURRENT_ISSUE(GZ_ID)
    RETURNING_VALUES :ISID;

    FOR
        SELECT
             m.AG_ID
            ,m.SD_ID
            ,m.OB_ID
            ,m.RB_ID
            ,m.FM_ID
            ,m.OBJAV_HAS_ATTENTION
            ,m.CONTENT_ID
            ,1
        FROM
            MODULI_V_NOMER_NOMER(:ISID) m
        LEFT JOIN OBJAVLENIE ob ON (ob.OBJAV_ID = m.OB_ID)
        WHERE ob.OB_STATE_TXT IS NULL

UNION

        SELECT
             p.AG_ID
            ,p.SD_ID
            ,ob.OBJAV_ID
            ,ob.RB_ID
            ,ob.FM_ID
            ,ob.OBJAV_HAS_ATTENTION
            ,ob.CONTENT_ID
            ,2
        FROM podacha p
        LEFT JOIN OBJAVLENIE ob ON (ob.PD_ID = p.PD_ID)
        WHERE
                p.IS_ID = :ISID
        AND     ob.OB_STATE_TXT IN (3, 4)
        INTO
             :AG_ID,
             :SD_ID,
             :OB_ID,
             :RB_ID,
             :FM_ID,
             :OBJAV_HAS_ATTENTION,
             :CONTENT_ID,
             :K
    DO
    BEGIN
        SUSPEND;
    END
end^


ALTER PROCEDURE OBJAV_LIST_FOR_INT_NABOR2 (
    GZ_ID INTEGER)
RETURNS (
    AG_ID INTEGER,
    SD_ID INTEGER,
    OB_ID INTEGER,
    RB_ID INTEGER,
    FM_ID INTEGER,
    OBJAV_HAS_ATTENTION INTEGER,
    CONTENT_ID INTEGER,
    K INTEGER)
AS
declare variable ISID integer;
begin
  /* Procedure Text */
    EXECUTE PROCEDURE GET_CURRENT_ISSUE(GZ_ID)
    RETURNING_VALUES :ISID;

    FOR
        SELECT
             m.AG_ID
            ,m.SD_ID
            ,m.OB_ID
            ,m.RB_ID
            ,m.FM_ID
            ,m.OBJAV_HAS_ATTENTION
            ,m.CONTENT_ID
            ,1
        FROM
            MODULI_V_NOMER_NOMER(:ISID) m
        LEFT JOIN OBJAVLENIE ob ON (ob.OBJAV_ID = m.OB_ID)
        LEFT JOIN OBJAV_CONTENT oc ON (oc.CONTENT_ID = m.CONTENT_ID)
        WHERE ob.OB_STATE_TXT IS NULL AND
              oc.CONTENT_PICTURE IS NOT NULL

UNION

        SELECT
             p.AG_ID
            ,p.SD_ID
            ,ob.OBJAV_ID
            ,ob.RB_ID
            ,ob.FM_ID
            ,ob.OBJAV_HAS_ATTENTION
            ,ob.CONTENT_ID
            ,2
        FROM podacha p
        LEFT JOIN OBJAVLENIE ob ON (ob.PD_ID = p.PD_ID)
        WHERE
                p.IS_ID = :ISID
        AND     ob.OB_STATE_TXT IN (3, 4)
        INTO
             :AG_ID,
             :SD_ID,
             :OB_ID,
             :RB_ID,
             :FM_ID,
             :OBJAV_HAS_ATTENTION,
             :CONTENT_ID,
             :K
    DO
    BEGIN
        SUSPEND;
    END
end^


ALTER PROCEDURE OBJAV_LIST_FOR_KORREKTURA (
    GZ_ID INTEGER)
RETURNS (
    AG_ID INTEGER,
    SD_ID INTEGER,
    OB_ID INTEGER,
    OB_TYPE INTEGER)
AS
declare variable ISID integer;
BEGIN
    EXECUTE PROCEDURE GET_CURRENT_ISSUE(GZ_ID)
    RETURNING_VALUES :ISID;

    FOR
        SELECT
              OBL.AG_ID,
              OBL.SD_ID,
              OBL.OB_ID,
              1
        FROM
            OBJAV_WORKING_LIST OBL
            LEFT JOIN SDELKA SD
            ON (OBL.AG_ID=SD.AG_ID AND OBL.SD_ID=SD.SD_ID)
            LEFT JOIN FORMAT FM
            ON (FM.FM_ID = OBL.FM_ID)
            LEFT JOIN OBJAV_DUPL ODU
            ON (ODU.AG_ID = OBL.AG_ID AND ODU.SD_ID = OBL.SD_ID AND ODU.OB_ID = OBL.OB_ID)
        WHERE
            GZ_ID=:GZ_ID AND
            OBL.OB_STATE=1 AND
            ODU.AG_ID IS NULL AND
            FM.FM_HAS_PICTURE=0 AND
            SD_STATE<>100 AND
            SD_STATE > 2 AND
            AS_ID<>2 AND
            AS_ID<>1
UNION       -- Изм. модуля
        SELECT
            PD.AG_ID AS AG_ID,
            PD.SD_ID AS SD_ID,
            OBJ.OBJAV_ID,
            2
        FROM
            PODACHA PD
            LEFT JOIN OBJAVLENIE OBJ
            ON (OBJ.PD_ID=PD.PD_ID)
            LEFT JOIN SDELKA SD
            ON  (SD.AG_ID=PD.AG_ID AND SD.SD_ID=PD.SD_ID)
            LEFT JOIN FORMAT FM
            ON (FM.FM_ID = OBJ.FM_ID)
            LEFT JOIN OBJAVLENIE_DUPL ODU
            ON (ODU.OBJAV_ID = OBJ.OBJAV_ID)
        WHERE
             PD.IS_ID=:ISID AND
             FM.FM_HAS_PICTURE = 1 AND
             obj.OB_STATE = 1  AND
             SD_STATE<>100 AND
             AS_ID<>2 AND
             AS_ID<>1
UNION    -- Изм. модуля через текст
        SELECT
            PD.AG_ID AS AG_ID,
            PD.SD_ID AS SD_ID,
            OBJ.OBJAV_ID,
            3
        FROM
            PODACHA PD
            LEFT JOIN OBJAVLENIE OBJ
            ON (OBJ.PD_ID=PD.PD_ID)
            LEFT JOIN SDELKA SD
            ON  (SD.AG_ID=PD.AG_ID AND SD.SD_ID=PD.SD_ID)
            LEFT JOIN FORMAT FM
            ON (FM.FM_ID = OBJ.FM_ID)
            LEFT JOIN OBJAV_CONTENT oc
            ON (oc.CONTENT_ID = OBJ.CONTENT_ID)
        WHERE
             PD.IS_ID=:ISID AND
             FM.FM_HAS_PICTURE = 1 AND
             obj.OB_STATE_TXT = 1  AND
             obj.OB_STATE IS NULL AND
             oc.CONTENT_PICTURE IS NOT NULL AND
             SD_STATE<>100 AND
             AS_ID<>2 AND
             AS_ID<>1
        INTO :AG_ID,:SD_ID,:OB_ID,:OB_TYPE
    DO
        SUSPEND;
END^


ALTER PROCEDURE OBJAV_LIST_FOR_NABOR (
    GZ_ID INTEGER)
RETURNS (
    AG_ID INTEGER,
    SD_ID INTEGER,
    OB_ID INTEGER,
    OB_TYPE INTEGER)
AS
declare variable ISID integer;
BEGIN
    EXECUTE PROCEDURE GET_CURRENT_ISSUE(GZ_ID)
    RETURNING_VALUES :ISID;
    FOR
        SELECT
            OBL.AG_ID,
            OBL.SD_ID,
            OBL.OB_ID,
            1
        FROM
            PODACHA PD
            RIGHT JOIN OBJAV_WORKING_LIST OBL
            ON (OBL.AG_ID=PD.AG_ID AND OBL.SD_ID=PD.SD_ID)
            LEFT JOIN SDELKA SD
            ON (SD.AG_ID=PD.AG_ID AND SD.SD_ID=PD.SD_ID)
            LEFT JOIN OBJAV_DUPL ODU
            ON (ODU.AG_ID = OBL.AG_ID AND ODU.SD_ID = OBL.SD_ID AND ODU.OB_ID = OBL.OB_ID)
        WHERE
             PD.IS_ID=:ISID AND
             OBL.OB_STATE IN (0, 2) AND
             ODU.AG_ID IS NULL AND
             SD_STATE<>100 AND
             SD_STATE >= 2 AND
             AS_ID<>2 AND
             AS_ID<>1
UNION
        SELECT
            PD.AG_ID AS AG_ID,
            PD.SD_ID AS SD_ID,
            OBJ.OBJAV_ID,
            2
        FROM
            PODACHA PD
            LEFT JOIN OBJAVLENIE OBJ
            ON (OBJ.PD_ID=PD.PD_ID)
            LEFT JOIN SDELKA SD
            ON  (SD.AG_ID=PD.AG_ID AND SD.SD_ID=PD.SD_ID)
            LEFT JOIN FORMAT FM
            ON (FM.FM_ID = OBJ.FM_ID)
            LEFT JOIN OBJAVLENIE_DUPL ODU
            ON (ODU.OBJAV_ID = OBJ.OBJAV_ID)
        WHERE
             PD.IS_ID=:ISID AND
             FM.FM_HAS_PICTURE = 1 AND
             obj.OB_STATE = 2  AND
             SD_STATE<>100 AND
            -- SD_STATE > 1 AND
             AS_ID<>2 AND
             AS_ID<>1
UNION
        SELECT
            PD.AG_ID AS AG_ID,
            PD.SD_ID AS SD_ID,
            OBJ.OBJAV_ID,
            3
        FROM
            PODACHA PD
            LEFT JOIN OBJAVLENIE OBJ
            ON (OBJ.PD_ID=PD.PD_ID)
            LEFT JOIN SDELKA SD
            ON  (SD.AG_ID=PD.AG_ID AND SD.SD_ID=PD.SD_ID)
            LEFT JOIN FORMAT FM
            ON (FM.FM_ID = OBJ.FM_ID)
            LEFT JOIN OBJAVLENIE_DUPL ODU
            ON (ODU.OBJAV_ID = OBJ.OBJAV_ID)
        WHERE
             PD.IS_ID=:ISID AND
             FM.FM_HAS_PICTURE = 1 AND
             obj.OB_STATE_TXT = 2  AND
             TRIM(obj.MDL_TEXT) <> '' AND
             obj.MDL_TEXT IS NOT NULL AND
             SD_STATE > 2 AND
             AS_ID <> 2 AND
             AS_ID <> 1
        INTO
            :AG_ID,:SD_ID,:OB_ID,:OB_TYPE
    DO
        SUSPEND;
END^


ALTER PROCEDURE OBJAV_LIST_KA
RETURNS (
    AG_ID INTEGER,
    SD_ID INTEGER,
    OB_ID INTEGER,
    RB_ID INTEGER,
    PD_ID INTEGER)
AS
declare variable ISID INTEGER;
BEGIN
    SELECT PM_CURRENT_ISSUE_PR
    FROM PARAMS
    INTO :ISID;

    FOR
        SELECT
            OBL.AG_ID,OBL.SD_ID,OBL.OB_ID,OBL.RB_ID,OBL.PD_ID
        FROM
            OBJAV_LIST_V_NOMER_ALL(:ISID) OBL
            LEFT JOIN OBJAV OB
            ON (OBL.AG_ID=OB.AG_ID AND
                OBL.SD_ID=OB.SD_ID AND
                OBL.OB_ID=OB.OB_ID)
        WHERE
            FM_ID=14
        INTO
            :AG_ID,:SD_ID,:OB_ID,:RB_ID,:PD_ID
    DO
        SUSPEND;
END^


ALTER PROCEDURE OBJAV_LIST_V_INTERNET (
    GZ_ID INTEGER)
RETURNS (
    OBJAV_TEXT VARCHAR(2047),
    OBJAV_ID INTEGER,
    RUBRIKA_ID INTEGER,
    RUBRIKA_NAME VARCHAR(128),
    ISS_NAME VARCHAR(10),
    SITE_VACANCY_NAME VARCHAR(128),
    SITE_EMAIL VARCHAR(128),
    SITE_TEL VARCHAR(128),
    SITE_CONTACT VARCHAR(255),
    SITE_DONT_UPLOAD SMALLINT,
    SITE_ZP INTEGER,
    GZ_RB_ID INTEGER,
    K INTEGER,
    SITE_EMPLOYER VARCHAR(255),
    C_NAME VARCHAR(128),
    ED_NAME VARCHAR(32),
    EX_NAME VARCHAR(32),
    CU_COMPANY_ID INTEGER,
    CU_ADDRESS VARCHAR(255),
    EXP_DATE TIMESTAMP,
    PT_ID INTEGER,
    PD_ID INTEGER)
AS
declare variable ISS_FOR_SELECT smallint;
declare variable I integer;
declare variable AG_ID integer;
declare variable SD_ID integer;
declare variable MAX_IS_ID integer;
declare variable CONTENT_ID integer;
declare variable OLD_CONTENT_ID integer;
begin
    i = 0;
   -- delete from internet i where i.OBJAV_ID > 0;
    FOR SELECT g.GZ_ID FROM gazeta g WHERE g.GZ_ID IN (1,3) INTO :GZ_ID DO
    WHILE (i < 2) DO
    BEGIN
           IF (i = 0) THEN
           BEGIN
                SELECT ci.IS_ID
                FROM GET_CURRENT_ISSUE(:gz_id) ci
                INTO :ISS_FOR_SELECT;
           END
           ELSE BEGIN
                SELECT MAX(i_prev.IS_ID)
                FROM issue i_prev
                WHERE i_prev.GZ_ID = :GZ_ID
                AND   i_prev.IS_ID < (SELECT ci.IS_ID FROM GET_CURRENT_ISSUE(:GZ_ID) ci)
                INTO :ISS_FOR_SELECT;
           END

           SELECT i.IS_NAME FROM issue i WHERE i.IS_ID = :ISS_FOR_SELECT INTO :ISS_NAME;

           FOR
               SELECT
                    o.RB_ID
                    ,CAST(so.SITE_OBJAV_TEXT AS VARCHAR(2047)) AS OB_TEXT
                    ,so.SITE_OBJAV_ID
                    ,o.RS_ID
                    ,rs.RS_NAME
                    ,so.SITE_VACANCY_NAME
                    ,so.SITE_EMAIL
                    ,so.SITE_TEL
                    ,so.SITE_CONTACT
                    ,so.SITE_DONT_UPLOAD
                    ,so.SITE_ZP
                    ,so.SITE_EMPLOYER
                    ,c.C_NAME
                    ,ed.ED_NAME
                    ,ex.EX_NAME
                    ,cus.CU_COMPANY_ID
                    ,so.CU_ADDRESS
                    ,p.AG_ID
                    ,p.SD_ID
                    ,s.PT_ID
                    ,p.PD_ID
                    ,CAST(NULL AS INTEGER) AS CONTENT_ID
                    ,1
                FROM
                    PODACHA p
                    LEFT JOIN OBJAV o ON (o.AG_ID = p.AG_ID AND o.SD_ID = p.SD_ID)
                    LEFT JOIN SITE_OBJAV so ON (so.OB_ID = o.OB_ID)
                    LEFT JOIN RUBRIKA_SITE rs ON (rs.RS_ID = so.RS_ID)
                    LEFT JOIN sdelka s ON (s.AG_ID = p.AG_ID AND s.SD_ID = p.SD_ID)
                    LEFT JOIN city c ON(c.C_ID = so.C_ID)
                    LEFT JOIN EDUCATION ed ON(ed.ED_ID = so.ED_ID)
                    LEFT JOIN EXPERIENCE ex ON (ex.EX_ID = so.EX_ID)
                    LEFT JOIN CUST cus ON (cus.AG_ID = s.AG_ID AND cus.CU_ID = s.CU_ID)
                WHERE
                    p.IS_ID = :iss_for_select
                AND so.SITE_OBJAV_TEXT <> ''
                AND s.GZ_ID = 1
              --  AND   so.SITE_OBJAV_ID in (326804, 329570)
                UNION
                SELECT
                    ob.RB_ID
                    ,CAST(so.SITE_OBJAV_TEXT AS VARCHAR(2047)) AS OB_TEXT
                    ,so.SITE_OBJAV_ID
                    ,so.RS_ID
                    ,rs.RS_NAME
                    ,so.SITE_VACANCY_NAME
                    ,so.SITE_EMAIL
                    ,so.SITE_TEL
                    ,so.SITE_CONTACT
                    ,so.SITE_DONT_UPLOAD
                    ,so.SITE_ZP
                    ,so.SITE_EMPLOYER
                    ,c.C_NAME
                    ,ed.ED_NAME
                    ,ex.EX_NAME
                    ,cus.CU_COMPANY_ID
                    ,so.CU_ADDRESS
                    ,p.AG_ID
                    ,p.SD_ID
                    ,s.PT_ID
                    ,p.PD_ID
                    ,so.CONTENT_ID
                    ,2
                FROM podacha p
                    LEFT JOIN OBJAVLENIE ob ON (ob.PD_ID = p.PD_ID)
                    LEFT JOIN SITE_OBJAV so ON(so.CONTENT_ID = ob.CONTENT_ID)
                    LEFT JOIN RUBRIKA_SITE rs ON(rs.RS_ID = so.RS_ID)
                    LEFT JOIN sdelka s ON (s.AG_ID = p.AG_ID AND s.SD_ID = p.SD_ID)
                    LEFT JOIN city c ON(c.C_ID = so.C_ID)
                    LEFT JOIN EDUCATION ed ON(ed.ED_ID = so.ED_ID)
                    LEFT JOIN EXPERIENCE ex ON (ex.EX_ID = so.EX_ID)
                    LEFT JOIN CUST cus ON (cus.AG_ID = s.AG_ID AND cus.CU_ID = s.CU_ID)
                WHERE p.IS_ID = :iss_for_select
                AND   s.PT_ID <> 3      /* В модулях если сделки кредитные
                                           агенты создают дубли и чтоб они не попадали
                                           в интернет игнорим кредитные напр. 203-687860, 203-687756
                                         */
                AND   s.GZ_ID = 1
                AND   so.SITE_OBJAV_TEXT <> ''
             --   AND   so.SITE_OBJAV_ID in (326804, 329570)
                INTO
                     :GZ_RB_ID
                    ,:OBJAV_TEXT
                    ,:OBJAV_ID
                    ,:RUBRIKA_ID
                    ,:RUBRIKA_NAME
                    ,:SITE_VACANCY_NAME
                    ,:SITE_EMAIL
                    ,:SITE_TEL
                    ,:SITE_CONTACT
                    ,:SITE_DONT_UPLOAD
                    ,:SITE_ZP
                    ,:SITE_EMPLOYER
                    ,:C_NAME
                    ,:ED_NAME
                    ,:EX_NAME
                    ,:CU_COMPANY_ID
                    ,:CU_ADDRESS
                    ,:AG_ID
                    ,:SD_ID
                    ,:PT_ID
                    ,:PD_ID
                    ,:CONTENT_ID
                    ,:K

                DO BEGIN
                     SELECT MAX(p.IS_ID) FROM podacha p WHERE p.AG_ID = :AG_ID AND p.SD_ID = :SD_ID INTO :MAX_IS_ID;
                     SELECT i.IS_DATE + 7 FROM issue i WHERE i.IS_ID = :MAX_IS_ID INTO :EXP_DATE;

                     SELECT oc.OLD_CONTENT_ID_LINK FROM OBJAV_CONTENT oc WHERE oc.CONTENT_ID = :CONTENT_ID INTO :OLD_CONTENT_ID;

                     IF(NOT EXISTS(SELECT 1 FROM internet i WHERE i.RS_ID = :RUBRIKA_ID AND i.TXT = :OBJAV_TEXT)) THEN
                     BEGIN
                          IF(NOT EXISTS(SELECT 1 FROM internet i WHERE i.CONTENT_ID = :CONTENT_ID AND i.CONTENT_ID IS NOT NULL)) THEN
                          BEGIN
                                INSERT INTO internet(OBJAV_ID, RS_ID, CONTENT_ID, TXT)
                                VALUES(:OBJAV_ID, :RUBRIKA_ID, :OLD_CONTENT_ID, :OBJAV_TEXT);
                                SUSPEND;
                          END
                     END
                END
            i = i + 1;
    END
end^


ALTER PROCEDURE OBJAV_LIST_V_NOMER (
    IS_ID INTEGER)
RETURNS (
    AG_ID INTEGER,
    SD_ID INTEGER,
    OB_ID INTEGER,
    RB_ID INTEGER,
    PD_ID INTEGER,
    OB_STATE INTEGER)
AS
DECLARE VARIABLE ISID INTEGER;
BEGIN
    FOR
        SELECT
            OB.AG_ID,OB.SD_ID,OB.OB_ID,OB.RB_ID,PD.PD_ID,OB.OB_STATE
        FROM
            PODACHA PD
            LEFT JOIN OBJAV OB
            ON (PD.AG_ID=OB.AG_ID AND PD.SD_ID=OB.SD_ID)
            LEFT JOIN SDELKA SD
            ON (OB.AG_ID=SD.AG_ID AND OB.SD_ID=SD.SD_ID)
            LEFT JOIN FORMAT FM
            ON (FM.FM_ID = OB.FM_ID)
        WHERE
            IS_ID=:IS_ID AND
            OB_IS_ACTIVE=1 AND
            FM_HAS_PICTURE=0 AND
/*            (
                OB.FM_ID=1 OR
                OB.FM_ID=17 OR
                OB.FM_ID=43
            ) AND
*/
            SD_STATE<>100 AND
            SD_STATE>=4 AND
            AS_ID<>2 AND
            AS_ID<>1
        INTO
            :AG_ID,:SD_ID,:OB_ID,:RB_ID,:PD_ID,:OB_STATE
    DO
            SUSPEND;

/*
    Если текущий ПР, то выведем также все объявления РкБ,
    которые идут в его текущий номер
*/
/*
    execute procedure get_current_issue(1)
    returning_values :isid;

    if (isid = :is_id) then
    begin
        execute procedure get_current_issue(2)
        returning_values :isid;

        for
            select
                ob.AG_ID, ob.SD_ID, ob.OB_ID, r_pr.RB_ID, ob.PD_ID, ob.OB_STATE
            from
                objav_list_v_nomer(:isid) ob
                left join RUBRIKA r_rkb on (r_rkb.RB_ID = ob.RB_ID)
                left join RUBRIKA r_pr on (r_pr.RB_NAME_SHORT = r_rkb.RB_NAME_SHORT and r_pr.GZ_ID = 1)
            where
                r_pr.RB_ID is not null
            into
                :AG_ID, :SD_ID, :OB_ID, :RB_ID, :PD_ID, :OB_STATE
        do
            suspend;
    end
*/
END^


ALTER PROCEDURE OBJAV_LIST_V_NOMER_ALL (
    IS_ID INTEGER)
RETURNS (
    AG_ID INTEGER,
    SD_ID INTEGER,
    OB_ID INTEGER,
    RB_ID INTEGER,
    PD_ID INTEGER,
    OB_STATE INTEGER)
AS
DECLARE VARIABLE ISID INTEGER;
BEGIN
  FOR
      SELECT
          OB.AG_ID,OB.SD_ID,OB.OB_ID,OB.RB_ID,PD.PD_ID,OB.OB_STATE
      FROM
          PODACHA PD

          LEFT JOIN OBJAV OB
          ON (PD.AG_ID=OB.AG_ID AND PD.SD_ID=OB.SD_ID)

          LEFT JOIN SDELKA SD
          ON (OB.AG_ID=SD.AG_ID AND OB.SD_ID=SD.SD_ID)
      WHERE
          IS_ID=:IS_ID AND
          OB_IS_ACTIVE=1 AND
          SD_STATE<>100 AND
          SD_STATE>=4 AND
          AS_ID<>2 AND
          AS_ID<>1
      INTO
          :AG_ID,:SD_ID,:OB_ID,:RB_ID,:PD_ID,:OB_STATE
  DO
  BEGIN
      SUSPEND;
  END

/*
    Если текущий ПР, то выведем также все объявления РкБ,
    которые идут в его текущий номер
*/
/*
    execute procedure get_current_issue(1)
    returning_values :isid;

    if (isid = :is_id) then
    begin
        execute procedure get_current_issue(2)
        returning_values :isid;

        for
            select
                ob.AG_ID, ob.SD_ID, ob.OB_ID, r_pr.RB_ID, ob.PD_ID, ob.OB_STATE
            from
                objav_list_v_nomer_all(:isid) ob
                left join RUBRIKA r_rkb on (r_rkb.RB_ID = ob.RB_ID)
                left join RUBRIKA r_pr on (r_pr.RB_NAME_SHORT = r_rkb.RB_NAME_SHORT and r_pr.GZ_ID = 1)
            where
                r_pr.RB_ID is not null
            into
                :AG_ID, :SD_ID, :OB_ID, :RB_ID, :PD_ID, :OB_STATE
        do
            suspend;
    end
*/
END^


ALTER PROCEDURE OBJAV_NAVCH_COURSE (
    IS_ID INTEGER)
RETURNS (
    AG_ID INTEGER,
    SD_ID INTEGER,
    OB_ID INTEGER,
    GZ_ID INTEGER,
    AG_NAME VARCHAR(128),
    RB_NAME VARCHAR(128),
    CU_INFO VARCHAR(512),
    OB_TEXT VARCHAR(2047))
AS
    declare variable curr_iss integer;
begin
    execute procedure get_current_issue(1)
    returning_values :curr_iss;

    for
        select
              ol.AG_ID
            , ob.SD_ID
            , ob.OB_ID
            , sd.GZ_ID
            , ag.AG_NAME
            , rb.RB_NAME
            , cu.CU_INFO
            , ob.OB_TEXT
        from
            OBJAV_LIST_V_NOMER_ALL(:curr_iss) ol

            left join OBJAV ob on (ob.AG_ID = ol.AG_ID and ob.OB_ID = ol.OB_ID)

            left join RUBRIKA rb on (rb.RB_ID = ol.RB_ID)

            left join SDELKA sd on (sd.AG_ID = ob.AG_ID and sd.SD_ID = ob.SD_ID)

            left join CUST cu on (cu.AG_ID = sd.AG_ID and cu.CU_ID = sd.CU_ID)

            left join AGENT ag on (ag.AG_ID = ob.AG_ID)
        where
            ob.FM_ID = 16
        into
            :AG_ID, :SD_ID, :OB_ID, :GZ_ID, :AG_NAME, :RB_NAME, :CU_INFO, :OB_TEXT
    do
        suspend;
end^


ALTER PROCEDURE OBJAV_PHONES (
    AG_ID INTEGER,
    SD_ID INTEGER)
RETURNS (
    PH_NUMBER CHAR(16))
AS
DECLARE VARIABLE SDTYPE INTEGER;
DECLARE VARIABLE SDPARENT INTEGER;
DECLARE VARIABLE SDID INTEGER;
BEGIN
    FOR
        SELECT PH_NUMBER FROM SDELKA_PHONES(:AG_ID,:SD_ID)
        INTO :PH_NUMBER
    DO
        SUSPEND;
END^


ALTER PROCEDURE OBJAV_SVERSTANA (
    AG_ID INTEGER,
    SD_ID INTEGER,
    OB_ID INTEGER,
    PD_ID INTEGER,
    RB_ID INTEGER,
    DIAGNOZ INTEGER)
AS
DECLARE VARIABLE CNT INTEGER;
DECLARE VARIABLE DUPL_SRC_AG_ID INTEGER;
DECLARE VARIABLE DUPL_SRC_SD_ID INTEGER;
BEGIN
    IF (DIAGNOZ=1 OR DIAGNOZ=3) THEN
    BEGIN
        -- Установим признак, что сделка в данный момент дублируется
        -- (на случай, если передается сделка-дубликат)
        dupl_src_ag_id = null;
        dupl_src_sd_id = null;
        if (exists (
            select 1
            from SDELKA_DUPL sd
            where sd.AG_ID = :AG_ID
                and sd.SD_ID = :SD_ID
        )) then
        begin
            select sd.DUPL_OF_AG_ID, sd.DUPL_OF_SD_ID
            from SDELKA_DUPL sd
            where sd.AG_ID = :AG_ID
                and sd.SD_ID = :SD_ID
            into :dupl_src_ag_id, :dupl_src_sd_id;

            execute procedure sdelka_duplicating_start(:dupl_src_ag_id, :dupl_src_sd_id);
        end

        UPDATE
              OBJAV OB
        SET
              OB.OB_STATE=5
        WHERE
              OB.AG_ID=:AG_ID AND
              OB.SD_ID=:SD_ID AND
              OB.OB_ID=:OB_ID;

        -- Снимем признак, что сделка в данный момент дублируется
        if (:dupl_src_ag_id is not null) then
            execute procedure sdelka_duplicating_end(:dupl_src_ag_id, :dupl_src_sd_id);

        
        SELECT
              COUNT(*) FROM OBJAV_SVERSTANO SS
        WHERE
              SS.AG_ID=:AG_ID AND
              SS.SD_ID=:SD_ID AND
              SS.OB_ID=:OB_ID AND
              SS.PD_ID=:PD_ID AND
              SS.RB_ID=:RB_ID
        INTO
              :CNT;
              
        IF (CNT=0) THEN
            INSERT INTO OBJAV_SVERSTANO(AG_ID,SD_ID,OB_ID,PD_ID,RB_ID)
            VALUES (:AG_ID,:SD_ID,:OB_ID,:PD_ID,:RB_ID);
    END
    
    IF (DIAGNOZ=2) THEN
        DELETE FROM
               OBJAV_SVERSTANO SS
        WHERE
               SS.AG_ID=:AG_ID AND
               SS.SD_ID=:SD_ID AND
               SS.SD_ID=:SD_ID AND
               SS.PD_ID=:PD_ID AND
               SS.RB_ID=:RB_ID;
END^


ALTER PROCEDURE OBJAV_VERSTKA_DIFFERENCE (
    IS_ID INTEGER)
RETURNS (
    AG_ID INTEGER,
    SD_ID INTEGER,
    OB_ID INTEGER,
    PD_ID INTEGER,
    RB_ID INTEGER,
    DIAGNOZ SMALLINT)
AS
DECLARE VARIABLE AGID INTEGER;
DECLARE VARIABLE SDID INTEGER;
DECLARE VARIABLE RBID INTEGER;
DECLARE VARIABLE CNT INTEGER;
DECLARE VARIABLE SDPUBLSTATE INTEGER;
BEGIN
    DELETE FROM OBJAV_LIST_V_NOMER_TEMP;
    
    INSERT
        INTO
            OBJAV_LIST_V_NOMER_TEMP(AG_ID,SD_ID,OB_ID,PD_ID,RB_ID,OB_STATE)
        SELECT
            OLN.AG_ID,OLN.SD_ID,OLN.OB_ID,OLN.PD_ID,OLN.RB_ID,OLN.OB_STATE
        FROM
            OBJAV_LIST_V_NOMER(:IS_ID) OLN
    ;

/* новое */
    DIAGNOZ=1;
    FOR
        SELECT
            OLTEMP.AG_ID,
            OLTEMP.SD_ID,
            OLTEMP.OB_ID,
            OLTEMP.PD_ID,
            OLTEMP.RB_ID
        FROM
            OBJAV_LIST_V_NOMER_TEMP OLTEMP
            LEFT JOIN OBJAV_SVERSTANO OBSVERST
            ON (OLTEMP.AG_ID=OBSVERST.AG_ID AND
                OLTEMP.SD_ID=OBSVERST.SD_ID AND
                OLTEMP.OB_ID=OBSVERST.OB_ID AND
                OLTEMP.PD_ID=OBSVERST.PD_ID AND
                OLTEMP.RB_ID=OBSVERST.RB_ID)
        WHERE
             OLTEMP.OB_STATE IN (4,5) AND
             OBSVERST.OB_ID IS NULL
        INTO :AG_ID,:SD_ID,:OB_ID,:PD_ID,:RB_ID
    DO
        SUSPEND;
        
/* удаленное */
    DIAGNOZ=2;
    FOR
        SELECT
            OBSVERST.AG_ID,
            OBSVERST.SD_ID,
            OBSVERST.OB_ID,
            OBSVERST.PD_ID,
            OBSVERST.RB_ID
        FROM
            OBJAV_SVERSTANO OBSVERST
            LEFT JOIN OBJAV_LIST_V_NOMER_TEMP OLTEMP
            ON (OLTEMP.AG_ID=OBSVERST.AG_ID AND
                OLTEMP.SD_ID=OBSVERST.SD_ID AND
                OLTEMP.OB_ID=OBSVERST.OB_ID AND
                OLTEMP.PD_ID=OBSVERST.PD_ID AND
                OLTEMP.RB_ID=OBSVERST.RB_ID)
        WHERE
            OB_STATE IS NULL
        INTO
            :AG_ID,:SD_ID,:OB_ID,:PD_ID,:RB_ID
    DO
        SUSPEND;

/* измененное */
    DIAGNOZ=3;
    FOR
        SELECT
            OBSVERST.AG_ID,
            OBSVERST.SD_ID,
            OBSVERST.OB_ID,
            OBSVERST.PD_ID,
            OBSVERST.RB_ID
        FROM
            OBJAV_SVERSTANO OBSVERST
            LEFT JOIN OBJAV_LIST_V_NOMER_TEMP OLTEMP
            ON (OLTEMP.AG_ID=OBSVERST.AG_ID AND
                OLTEMP.SD_ID=OBSVERST.SD_ID AND
                OLTEMP.OB_ID=OBSVERST.OB_ID AND
                OLTEMP.PD_ID=OBSVERST.PD_ID AND
                OLTEMP.RB_ID=OBSVERST.RB_ID)
        WHERE
            OB_STATE=4
        INTO
            :AG_ID,:SD_ID,:OB_ID,:PD_ID,:RB_ID
    DO
        SUSPEND;
END^


ALTER PROCEDURE OBJAV_VERSTKA_SVERSTANO
RETURNS (
    AG_ID INTEGER,
    SD_ID INTEGER,
    OB_ID INTEGER,
    PD_ID INTEGER,
    RB_ID INTEGER,
    SD_ID_COMPOUND VARCHAR(50),
    OB_COMMENT VARCHAR(255),
    FM_ID INTEGER,
    SD_SHOW_CUST_ID SMALLINT,
    CU_ID_COMPOUND VARCHAR(50),
    CU_INFO VARCHAR(512),
    GZ_ID SMALLINT,
    RB_NAME_SHORT VARCHAR(50),
    OBJAV_TEXT VARCHAR(2047),
    OB_ORDER FLOAT,
    OB_IS_OPTIONAL SMALLINT,
    DISTRICT_NAME VARCHAR(100))
AS
BEGIN

for
SELECT
  OBSVERST.AG_ID,
  OBSVERST.SD_ID,
  OBSVERST.OB_ID,
  OBSVERST.PD_ID,
  OBSVERST.RB_ID,

  OBSVERST.AG_ID||'-'||OBSVERST.SD_ID AS SD_ID_COMPOUND,

  OB.OB_COMMENT,
  OB.FM_ID,
  SD.SD_SHOW_CUST_ID,
  CU.AG_ID||'-'||SD.CU_ID AS CU_ID_COMPOUND,
  cast(CU.CU_INFO as varchar(512)) as CU_INFO,

  SD.GZ_ID,

  RB.RB_NAME_SHORT,

  cast(OBJ.OB_TEXT as varchar(2047)) AS OBJAV_TEXT,
  
  OB.OB_ORDER,
  OB.OB_IS_OPTIONAL,
  DT.DT_NAME as DISTRICT_NAME
FROM
  OBJAV_SVERSTANO OBSVERST

  LEFT JOIN SDELKA SD
  ON (OBSVERST.AG_ID=SD.AG_ID AND OBSVERST.SD_ID=SD.SD_ID)

  LEFT JOIN CUST CU
  ON (OBSVERST.AG_ID=CU.AG_ID AND SD.CU_ID=CU.CU_ID)

  LEFT JOIN OBJAV OB
  ON (OBSVERST.AG_ID=OB.AG_ID AND
    OBSVERST.SD_ID=OB.SD_ID AND
    OBSVERST.OB_ID=OB.OB_ID)

  LEFT JOIN RUBRIKA RB
  ON (OBSVERST.RB_ID=RB.RB_ID)

  LEFT JOIN GET_OBJAV_TEXT(OBSVERST.AG_ID,OBSVERST.SD_ID,OBSVERST.OB_ID) OBJ
  ON (OBSVERST.SD_ID=OBSVERST.SD_ID)

  LEFT JOIN DISTRICT DT
  ON (DT.DT_ID=OB.DISTRICT_ID)

union

select
  0 as AG_ID,
  0 as SD_ID,
  0 as OB_ID,
  0 as PD_ID,
  oi.RB_ID,

  0 || '-' || 0 AS SD_ID_COMPOUND,

  cast('' as varchar(127)) as OB_COMMENT,
  cast(1 as SMALLINT) as FM_ID,
  cast(0 as SMALLINT) as SD_SHOW_CUST_ID,
  0 || '-' || 0 AS CU_ID_COMPOUND,
  cast('' as varchar(512)) as CU_INFO,

  cast(3 as SMALLINT) as GZ_ID,

  ri.RB_NAME_SHORT,

  cast(oi.OB_TEXT as varchar(2047)) as OBJAV_TEXT,
  
  cast(null as float) as OB_ORDER,
  cast(1 as smallint) as OB_IS_OPTIONAL,
  cast('' as varchar(100)) as DISTRICT_NAME
from
    OBJAV_INET_IMPORT oi

    left join RUBRIKA ri on (ri.RB_ID = oi.RB_ID)
    
into
    :AG_ID,
    :SD_ID,
    :OB_ID,
    :PD_ID,
    :RB_ID,
    :SD_ID_COMPOUND,
    :OB_COMMENT,
    :FM_ID,
    :SD_SHOW_CUST_ID,
    :CU_ID_COMPOUND,
    :CU_INFO,
    :GZ_ID,
    :RB_NAME_SHORT,
    :OBJAV_TEXT,
    :OB_ORDER,
    :OB_IS_OPTIONAL,
    :DISTRICT_NAME
    
do
begin

/*ORDER BY
  OB_ORDER DESC,OB_TEXT*/

  SUSPEND;
end
END^


ALTER PROCEDURE OBJAVLENIE_DELETE (
    OBJAV_ID INTEGER)
AS
    DECLARE VARIABLE AGID INTEGER;
    DECLARE VARIABLE SDID INTEGER;
    DECLARE VARIABLE PDID INTEGER;
    DECLARE VARIABLE OTHERPDID INTEGER;
    DECLARE VARIABLE ISCURRENT INTEGER;
    DECLARE VARIABLE SAMECODE INTEGER;
    DECLARE VARIABLE CONTENTID INTEGER;
BEGIN
/* проверим, работаем ли мы с текущей подачей */
    SELECT PD_ID,SAME_CODE FROM OBJAVLENIE
    WHERE OBJAV_ID = :OBJAV_ID
    INTO :PDID,:SAMECODE;
    SELECT AG_ID,SD_ID FROM PODACHA
    WHERE PD_ID = :PDID
    INTO :AGID,:SDID;
    EXECUTE PROCEDURE PODACHA_IS_CURRENT_AND_EDITABLE (:PDID)
    RETURNING_VALUES :ISCURRENT;
/* удалим все такие объявления у всех ещё не вышедших
   подач нашей сделки */
    IF (ISCURRENT = 1) THEN
    BEGIN
        FOR
            SELECT PD.PD_ID
            FROM PODACHA PD
            WHERE PD.AG_ID = :AGID
                  AND PD.SD_ID = :SDID
                  AND PD.PD_IS_DONE = 0
            INTO :OTHERPDID
        DO
        BEGIN
            SELECT OB.CONTENT_ID
            FROM OBJAVLENIE OB
            WHERE OB.PD_ID = :OTHERPDID
                  AND OB.SAME_CODE = :SAMECODE
            INTO :CONTENTID;

            DELETE FROM OBJAVLENIE OB
            WHERE OB.PD_ID = :OTHERPDID
                  AND OB.SAME_CODE = :SAMECODE;

            -- Удалим контент, если он больше не используется
            DELETE FROM OBJAV_CONTENT C
            WHERE C.CONTENT_ID = :CONTENTID
                  AND NOT EXISTS (
                      SELECT 1
                      FROM OBJAVLENIE OB
                      WHERE OB.CONTENT_ID = :CONTENTID
                  );
        END
    END
    ELSE
        EXCEPTION E_CAN_EDIT_CURRENT_PODACHA_ONLY;
END^


ALTER PROCEDURE OBJAVLENIE_DUPLICATE (
    P_DUPLICATE_AG_ID INTEGER,
    P_DUPLICATE_SD_ID INTEGER,
    P_SOURCE_OB_ID INTEGER)
AS
declare variable SOURCE_AG_ID integer;
declare variable SOURCE_SD_ID integer;
declare variable DUPLICATE_GZ_ID integer;
declare variable DUPLICATED_OB_ID integer;
declare variable DUPLICATED_PD_ID integer;
declare variable SOURCE_CURR_PD_ID integer;
declare variable SOURCE_CURR_IS_ID integer;
declare variable SOURCE_CURR_PD_IS_DONE integer;
declare variable DUPLICATE_CURR_PD_ID integer;
declare variable DUPLICATE_CURR_IS_ID integer;
declare variable DUPLICATE_CURR_PD_IS_DONE integer;
declare variable RUB_ID integer;
declare variable RUB_DB_ID integer;
declare variable CNT integer;
declare variable OLD_CONTENT_ID integer;
declare variable OLD_FM_ID integer;
declare variable OLD_VAC_COUNT smallint;
declare variable OLD_OBJAV_COMMENT varchar(255);
declare variable OLD_OBJAV_HAS_ATTENTION smallint;
declare variable OLD_PICTURE_TO_INET smallint;
declare variable OLD_DISTRICT_ID smallint;
declare variable SAME_CODE integer;
declare variable SOURCE_CONTENT_ID integer;
declare variable SOURCE_DISTRICT_ID integer;
declare variable SOURCE_FM_ID integer;
declare variable SOURCE_OBJAV_COMMENT varchar(255);
declare variable SOURCE_OBJAV_HAS_ATTENTION smallint;
declare variable SOURCE_PICTURE_TO_INET smallint;
declare variable SOURCE_VAC_COUNT smallint;
declare variable SRC_OB_ID integer;
declare variable PODACHA_ORDER_NO integer;
declare variable PODACHA_TO_COPY_TO integer;
declare variable PODACHA_TO_COPY_FROM integer;
declare variable OBJAV_TO_COPY_FROM integer;
declare variable OBJAV_TO_COPY_TO integer;
declare variable SAME_CODE_TO_COPY_FROM integer;
declare variable ISCURRENT smallint;
declare variable SOURCE_MDL_TEXT D_MEMO;
begin
    -- Находим исходную сделку
    select sdu.DUPL_OF_AG_ID, sdu.DUPL_OF_SD_ID, sdd.GZ_ID
    from SDELKA_DUPL sdu
    left join SDELKA sdd on (sdd.AG_ID = sdu.AG_ID and sdd.SD_ID = sdu.SD_ID)
    where sdu.AG_ID = :P_DUPLICATE_AG_ID
          and sdu.SD_ID = :P_DUPLICATE_SD_ID
    into :source_ag_id, :source_sd_id, :duplicate_gz_id;

    -- Найдем текущую подачу сделки, откуда дублируем
    execute procedure GET_CURRENT_PODACHA(:source_ag_id, :source_sd_id)
    returning_values :source_curr_pd_id, :source_curr_is_id, :source_curr_pd_is_done;

    -- Найдем текущую подачу сделки, куда дублируем
    execute procedure GET_CURRENT_PODACHA(:P_DUPLICATE_AG_ID, :P_DUPLICATE_SD_ID)
    returning_values :duplicate_curr_pd_id, :duplicate_curr_is_id, :duplicate_curr_pd_is_done;

    -- Определим, заведен ли уже дубль этого объявления
    select count(*)
    from OBJAVLENIE_DUPL odu
    where odu.DUPL_OF_OBJAV_ID = :p_source_ob_id
    into :cnt;

    -- Определим рубрики исходного объявления
    select ob.RB_ID, ob.DOUBLE_RB_ID
    from OBJAVLENIE ob
    where ob.OBJAV_ID = :P_SOURCE_OB_ID
    into :RUB_ID, :RUB_DB_ID;

    -- Установим признак, что объявление в данный момент дублируется
    execute procedure sdelka_duplicating_start(:source_ag_id, :source_sd_id);

    -- Не заведен - заведем
    if (cnt = 0) then
    begin
        -- Вычислим новые рубрики
        execute procedure OBJAVLENIE_GET_DUPL_RUBRIKA(:DUPLICATE_GZ_ID, :RUB_ID, :RUB_DB_ID)
        returning_values :RUB_ID, :RUB_DB_ID;

        if (rub_id is not null) then
        begin
            -- Создаем объявление-копию
            select
                ob.CONTENT_ID
                ,ob.FM_ID
                ,ob.VAC_COUNT
                ,ob.OBJAV_COMMENT
                ,ob.OBJAV_HAS_ATTENTION
                ,ob.PICTURE_TO_INET
                ,ob.DISTRICT_ID
                ,ob.MDL_TEXT
            from OBJAVLENIE ob
            where ob.OBJAV_ID = :P_SOURCE_OB_ID
            into
                :OLD_CONTENT_ID
                ,:OLD_FM_ID
                ,:OLD_VAC_COUNT
                ,:OLD_OBJAV_COMMENT
                ,:OLD_OBJAV_HAS_ATTENTION
                ,:OLD_PICTURE_TO_INET
                ,:OLD_DISTRICT_ID
                ,:SOURCE_MDL_TEXT;

            execute procedure OBJAVLENIE_INSERT_INTERNAL(
                :DUPLICATE_CURR_PD_ID
                ,:OLD_CONTENT_ID
                ,:rub_id
                ,:OLD_FM_ID
                ,:OLD_VAC_COUNT
                ,:rub_db_id
                ,:OLD_OBJAV_COMMENT
                ,:OLD_OBJAV_HAS_ATTENTION
                ,:OLD_PICTURE_TO_INET
                ,:OLD_DISTRICT_ID
                ,:SOURCE_MDL_TEXT)
            returning_values :SAME_CODE;

            -- Создаем развязки
            PODACHA_ORDER_NO = 0;

            -- Для каждого скопированного объявления найдем соотв. по порядку
            -- подачу в оригинальной сделке и сделаем развязку
            for
                select o.OBJAV_ID, p.PD_ID
                from OBJAVLENIE o
                left join PODACHA p on (p.PD_ID = o.PD_ID)
                left join ISSUE i on (p.IS_ID = i.IS_ID)
                where o.SAME_CODE = :SAME_CODE
                order by i.IS_DATE
                into :OBJAV_TO_COPY_TO, :PODACHA_TO_COPY_TO
            do
            begin
                PODACHA_ORDER_NO = PODACHA_ORDER_NO + 1;

                -- Соответствующая подача в оригинальной сделке
                execute procedure podacha_get_by_order_no(:source_ag_id, :source_sd_id, :PODACHA_ORDER_NO)
                returning_values :PODACHA_TO_COPY_FROM;

                if (PODACHA_TO_COPY_FROM > 0) then
                begin
                    -- Определяем SAME_CODE исходного объявления
                    select o.SAME_CODE
                    from OBJAVLENIE o
                    where o.OBJAV_ID = :P_SOURCE_OB_ID
                    into :SAME_CODE_TO_COPY_FROM;

                    -- Ищем объявление с таким SAME_CODE, выходящее в нужной нам подаче
                    select o.OBJAV_ID
                    from OBJAVLENIE o
                    where o.SAME_CODE = :SAME_CODE_TO_COPY_FROM
                          and o.PD_ID = :PODACHA_TO_COPY_FROM
                    into :OBJAV_TO_COPY_FROM;

                    if (OBJAV_TO_COPY_FROM > 0) then
                        insert into OBJAVLENIE_DUPL(OBJAV_ID, DUPL_OF_OBJAV_ID)
                        values (:OBJAV_TO_COPY_TO, :OBJAV_TO_COPY_FROM);
                end
            end
        end
    end
    -- Заведен - обновим
    else if (cnt = 1) then
    begin
        -- Найдем идентификатор и подачу объявления-копии
        select odu.OBJAV_ID, o.PD_ID
        from OBJAVLENIE_DUPL odu
        left join OBJAVLENIE o on (o.OBJAV_ID = odu.OBJAV_ID)
        where odu.DUPL_OF_OBJAV_ID = :P_SOURCE_OB_ID
        into :DUPLICATED_OB_ID, :DUPLICATED_PD_ID;

        -- Определим, к текущей ли подаче относится копия
        execute procedure PODACHA_IS_CURRENT_AND_EDITABLE (:DUPLICATED_PD_ID)
        RETURNING_VALUES :ISCURRENT;

        if (ISCURRENT = 1) then
        begin
            -- Вычислим новые рубрики
            execute procedure OBJAVLENIE_GET_DUPL_RUBRIKA(:DUPLICATE_GZ_ID, :RUB_ID, :RUB_DB_ID)
            returning_values :RUB_ID, :RUB_DB_ID;

            -- Если такой рубрики нет, но объявление сдублировано - удалим его
            if (rub_id is null) then
            begin
                delete from OBJAVLENIE_DUPL odu
                where odu.DUPL_OF_OBJAV_ID = :P_SOURCE_OB_ID;
            end
            -- Иначе продолжаем обновление
            else if (rub_id is not null) then
            begin
                select
                    ob.CONTENT_ID
                    ,ob.DISTRICT_ID
                    ,ob.FM_ID
                    ,ob.objav_comment
                    ,ob.objav_has_attention
                    ,ob.picture_to_inet
                    ,ob.vac_count
                    ,ob.MDL_TEXT
                from
                    OBJAVLENIE ob
                where
                    ob.OBJAV_ID = :P_SOURCE_OB_ID
                into    
                    :source_content_id
                    ,:source_district_id
                    ,:source_fm_id
                    ,:source_objav_comment
                    ,:source_objav_has_attention
                    ,:source_picture_to_inet
                    ,:source_vac_count
                    ,:SOURCE_MDL_TEXT;
                
                execute procedure OBJAVLENIE_UPDATE(
                    :DUPLICATED_OB_ID
                    ,:source_content_id
                    ,:RUB_ID
                    ,:source_fm_id
                    ,:source_vac_count
                    ,:RUB_DB_ID
                    ,:source_objav_comment
                    ,:source_objav_has_attention
                    ,:source_picture_to_inet
                    ,:source_district_id
                    ,:SOURCE_MDL_TEXT
                    /*,null*/);
            end
        end
    end

    -- Снимем признак, что объявление в данный момент дублируется
    execute procedure sdelka_duplicating_end(:source_ag_id, :source_sd_id);
end^


ALTER PROCEDURE OBJAVLENIE_DUPLICATE_ALL (
    P_DUPLICATE_AG_ID INTEGER,
    P_DUPLICATE_SD_ID INTEGER)
AS
DECLARE VARIABLE SOURCE_AG_ID INTEGER;
DECLARE VARIABLE SOURCE_SD_ID INTEGER;
DECLARE VARIABLE DUPLICATE_GZ_ID INTEGER;
DECLARE VARIABLE SOURCE_OB_ID INTEGER;
DECLARE VARIABLE DUPLICATED_OB_ID INTEGER;
DECLARE VARIABLE SOURCE_CURR_PD_ID INTEGER;
DECLARE VARIABLE SOURCE_CURR_IS_ID INTEGER;
DECLARE VARIABLE SOURCE_CURR_PD_IS_DONE INTEGER;
DECLARE VARIABLE DUPLICATE_CURR_PD_ID INTEGER;
DECLARE VARIABLE DUPLICATE_CURR_IS_ID INTEGER;
DECLARE VARIABLE DUPLICATE_CURR_PD_IS_DONE INTEGER;
begin
    -- Находим исходную сделку
    select sdu.DUPL_OF_AG_ID, sdu.DUPL_OF_SD_ID, sdd.GZ_ID
    from SDELKA_DUPL sdu
    left join SDELKA sdd on (sdd.AG_ID = sdu.AG_ID and sdd.SD_ID = sdu.SD_ID)
    where sdu.AG_ID = :P_DUPLICATE_AG_ID
          and sdu.SD_ID = :P_DUPLICATE_SD_ID
    into :source_ag_id, :source_sd_id, :duplicate_gz_id;

    -- Найдем текущую подачу сделки, откуда дублируем
    execute procedure GET_CURRENT_PODACHA(:source_ag_id, :source_sd_id)
    returning_values :source_curr_pd_id, :source_curr_is_id, :source_curr_pd_is_done;

    -- Найдем текущую подачу сделки, куда дублируем
    execute procedure GET_CURRENT_PODACHA(:P_DUPLICATE_AG_ID, :P_DUPLICATE_SD_ID)
    returning_values :duplicate_curr_pd_id, :duplicate_curr_is_id, :duplicate_curr_pd_is_done;

    -- Сделка уже закончилась, ничего не дублируем
    if (duplicate_curr_pd_is_done = 1) then
        exit;

    -- Удалим все продублированные объявления

    -- Перед этим установим признак, что мы дублируем объявления
    execute procedure sdelka_duplicating_start(:source_ag_id, :source_sd_id);

    for
        select o.OBJAV_ID
        from OBJAVLENIE o
        inner join OBJAVLENIE_DUPL od on (od.OBJAV_ID = o.OBJAV_ID)
        where o.PD_ID = :DUPLICATE_CURR_PD_ID
        into :DUPLICATED_OB_ID
    do
        execute procedure OBJAVLENIE_DELETE(:DUPLICATED_OB_ID);

    -- Снимем признак, что мы дублируем объявления
    execute procedure sdelka_duplicating_end(:source_ag_id, :source_sd_id);

    -- Дублируем объявления
    for
        select o.OBJAV_ID
        from OBJAVLENIE o
        left join PODACHA p on (p.PD_ID = o.PD_ID)
        where p.AG_ID = :source_ag_id
              and p.SD_ID = :source_sd_id
              and p.PD_ID = :source_curr_pd_id
        into :source_ob_id
    do
        execute procedure OBJAVLENIE_DUPLICATE(:P_DUPLICATE_AG_ID, :P_DUPLICATE_SD_ID, :source_ob_id);
end^


ALTER PROCEDURE OBJAVLENIE_GET_DUPL_RUBRIKA (
    P_DST_GZ_ID INTEGER,
    P_SRC_RB_ID INTEGER,
    P_SRC_DOUBLE_RB_ID INTEGER)
RETURNS (
    P_DST_RB_ID INTEGER,
    P_DST_DOUBLE_RB_ID INTEGER)
AS
begin
    -- Проверим, есть ли такая рубрика
    select count(*)
    from
    RUBRIKA r_source
    inner join RUBRIKA r_duplicate on (r_duplicate.GZ_ID = :p_dst_gz_id and r_duplicate.RB_NAME_SHORT = r_source.RB_NAME_SHORT)
    where r_source.RB_ID = :P_SRC_RB_ID
    into :P_DST_RB_ID;

    -- Если нашлась - вытащим ее идентификатор
    if (P_DST_RB_ID = 1) then
        select r_duplicate.RB_ID
        from
        RUBRIKA r_source
        inner join RUBRIKA r_duplicate on (r_duplicate.GZ_ID = :p_dst_gz_id and r_duplicate.RB_NAME_SHORT = r_source.RB_NAME_SHORT)
        where r_source.RB_ID = :P_SRC_RB_ID
        into :P_DST_RB_ID;
    else
        P_DST_RB_ID = null;

    -- Проверим, есть ли рубрика для дублирования
    select count(*)
    from
    RUBRIKA r_source
    inner join RUBRIKA r_duplicate on (r_duplicate.GZ_ID = :p_dst_gz_id and r_duplicate.RB_NAME_SHORT = r_source.RB_NAME_SHORT)
    where r_source.RB_ID = :P_SRC_DOUBLE_RB_ID
    into :P_DST_DOUBLE_RB_ID;

    -- Если нашлась - вытащим ее идентификатор
    if (P_DST_DOUBLE_RB_ID = 1) then
        select r_duplicate.RB_ID
        from
        RUBRIKA r_source
        inner join RUBRIKA r_duplicate on (r_duplicate.GZ_ID = :p_dst_gz_id and r_duplicate.RB_NAME_SHORT = r_source.RB_NAME_SHORT)
        where r_source.RB_ID = :P_SRC_DOUBLE_RB_ID
        into :P_DST_DOUBLE_RB_ID;
    else
        P_DST_DOUBLE_RB_ID = null;

    -- Если нашлась только рубрика дубля, то сделаем ее основной
    if (P_DST_RB_ID is null and P_DST_DOUBLE_RB_ID is not null) then
        P_DST_RB_ID = :P_DST_DOUBLE_RB_ID;

    suspend;
end^


ALTER PROCEDURE OBJAVLENIE_INSERT (
    PD_ID INTEGER,
    CONTENT_ID INTEGER,
    RB_ID INTEGER,
    FM_ID INTEGER,
    VAC_COUNT SMALLINT,
    DOUBLE_RB_ID INTEGER,
    OBJAV_COMMENT VARCHAR(255),
    OBJAV_HAS_ATTENTION SMALLINT,
    PICTURE_TO_INET SMALLINT,
    DISTRICT_ID INTEGER,
    MDL_TEXT D_MEMO)
RETURNS (
    SAME_CODE INTEGER)
AS
BEGIN
    execute procedure OBJAVLENIE_INSERT_INTERNAL(
        :PD_ID
        , :CONTENT_ID
        , :RB_ID
        , :FM_ID
        , :VAC_COUNT
        , :DOUBLE_RB_ID
        , :OBJAV_COMMENT
        , :OBJAV_HAS_ATTENTION
        , :PICTURE_TO_INET
        , :DISTRICT_ID
        , :MDL_TEXT
        /*, null*/)
    returning_values :SAME_CODE;
    suspend;
END^


ALTER PROCEDURE OBJAVLENIE_INSERT_INTERNAL (
    PD_ID INTEGER,
    CONTENT_ID INTEGER,
    RB_ID INTEGER,
    FM_ID INTEGER,
    VAC_COUNT SMALLINT,
    DOUBLE_RB_ID INTEGER,
    OBJAV_COMMENT VARCHAR(255),
    OBJAV_HAS_ATTENTION SMALLINT,
    PICTURE_TO_INET SMALLINT,
    DISTRICT_ID INTEGER,
    MDL_TEXT D_MEMO)
RETURNS (
    SAME_CODE INTEGER)
AS
declare variable AGID integer;
declare variable SDID integer;
declare variable PDID integer;
declare variable CONTENTID integer;
declare variable OTHERPDID integer;
declare variable ISCURRENT integer;
declare variable SAMECODE integer;
declare variable NEW_OBJAV_ID integer;
BEGIN
/* проверим, работаем ли мы с текущей подачей */
    CONTENTID = :CONTENT_ID;
    PDID = :PD_ID;
    SELECT AG_ID,SD_ID FROM PODACHA
    WHERE PD_ID = :PDID
    INTO :AGID,:SDID;
    EXECUTE PROCEDURE PODACHA_IS_CURRENT_AND_EDITABLE (:PDID)
    RETURNING_VALUES :ISCURRENT;
/* вставим такое объявление во все ещё не вышедшие
   подачи нашей сделки */
    IF (ISCURRENT = 1) THEN
    BEGIN
        SAMECODE = GEN_ID(G_OBJAV_SAME_CODE,1);
        FOR
            SELECT PD.PD_ID
            FROM PODACHA PD
            WHERE PD.AG_ID = :AGID
                  AND PD.SD_ID = :SDID
                  AND PD.PD_IS_DONE = 0
            INTO :OTHERPDID
        DO
        BEGIN
            NEW_OBJAV_ID = gen_id(G_OBJAV_ID, 1);

            insert into OBJAVLENIE (
                  OBJAV_ID
                , PD_ID
                , CONTENT_ID
                , RB_ID
                , FM_ID
                , VAC_COUNT
                , DOUBLE_RB_ID
                , SAME_CODE
                , OBJAV_COMMENT
                , OBJAV_HAS_ATTENTION
                , PICTURE_TO_INET
                , DISTRICT_ID
                , MDL_TEXT
            )
            values (
                  :NEW_OBJAV_ID
                , :OTHERPDID
                , :CONTENT_ID
                , :RB_ID
                , :FM_ID
                , :VAC_COUNT
                , :DOUBLE_RB_ID
                , :SAMECODE
                , :OBJAV_COMMENT
                , :OBJAV_HAS_ATTENTION
                , :PICTURE_TO_INET
                , :DISTRICT_ID
                , :MDL_TEXT
            );

        END

        SAME_CODE = :SAMECODE;
        SUSPEND;
    END
    ELSE
        EXCEPTION E_CAN_EDIT_CURRENT_PODACHA_ONLY;
END^


ALTER PROCEDURE OBJAVLENIE_UPDATE (
    OBJAV_ID INTEGER,
    CONTENT_ID INTEGER,
    RB_ID INTEGER,
    FM_ID INTEGER,
    VAC_COUNT INTEGER,
    DOUBLE_RB_ID INTEGER,
    OBJAV_COMMENT VARCHAR(255),
    OBJAV_HAS_ATTENTION SMALLINT,
    PICTURE_TO_INET SMALLINT,
    DISTRICT_ID INTEGER,
    MDL_TEXT D_MEMO)
AS
declare variable AGID integer;
declare variable SDID integer;
declare variable PDID integer;
declare variable OTHERPDID integer;
declare variable ISCURRENT integer;
declare variable NEWCONTENT_ISNULL integer;
declare variable OLD_RBID integer;
declare variable OLD_FMID integer;
declare variable OLD_DBRBID integer;
declare variable OLD_CONTENTID integer;
declare variable OLD_SAMECODE integer;
declare variable NEW_SAMECODE integer;
BEGIN
/* проверим, работаем ли мы с текущей подачей */
    SELECT PD_ID,SAME_CODE FROM OBJAVLENIE
    WHERE OBJAV_ID = :OBJAV_ID
    INTO :PDID,:OLD_SAMECODE;
 
    SELECT AG_ID,SD_ID FROM PODACHA
    WHERE PD_ID = :PDID
    INTO :AGID,:SDID;
    EXECUTE PROCEDURE PODACHA_IS_CURRENT_AND_EDITABLE (:PDID)
    RETURNING_VALUES :ISCURRENT;
   
/* обновим все такие объявления у всех ещё не вышедших
   подач нашей сделки */
    IF (ISCURRENT = 1) THEN
    BEGIN
        NEW_SAMECODE = GEN_ID(G_OBJAV_SAME_CODE,1);

        FOR
            SELECT PD.PD_ID
            FROM PODACHA PD
            WHERE     PD.AG_ID      = :AGID
                  AND PD.SD_ID      = :SDID
                  AND PD.PD_IS_DONE = 0
            INTO :OTHERPDID
        DO
        BEGIN
            update OBJAVLENIE ob
            set
                  ob.CONTENT_ID          = :CONTENT_ID
                , ob.RB_ID               = :RB_ID
                , ob.FM_ID               = :FM_ID
                , ob.VAC_COUNT           = :VAC_COUNT
                , ob.DOUBLE_RB_ID        = :DOUBLE_RB_ID
                , ob.SAME_CODE           = :NEW_SAMECODE
                , ob.OBJAV_COMMENT       = :OBJAV_COMMENT
                , ob.OBJAV_HAS_ATTENTION = :OBJAV_HAS_ATTENTION
                , ob.PICTURE_TO_INET     = :PICTURE_TO_INET
                , ob.DISTRICT_ID         = :DISTRICT_ID
               -- , ob.MDL_TEXT            = :MDL_TEXT
            where     ob.PD_ID = :OTHERPDID
                  and ob.SAME_CODE = :OLD_SAMECODE;
        END
    END
    ELSE
        EXCEPTION E_CAN_EDIT_CURRENT_PODACHA_ONLY;
END^


ALTER PROCEDURE ONE_C (
    DATE_FROM TIMESTAMP,
    DATE_TO TIMESTAMP)
RETURNS (
    NUMBER_OF_RECORDS INTEGER,
    OCOUNT INTEGER)
AS
declare variable P_CUST_OKPO char(10);
declare variable P_PAID float;
declare variable P_COST float;
declare variable P_DESCRIPT varchar(255);
declare variable P_SERV_ID smallint;
declare variable P_FACT_DATE timestamp;
declare variable P_IS_PAID smallint;
declare variable P_COMPANY_OKPO varchar(10);
declare variable P_CUST_NAME varchar(128);
declare variable P_FACT_NUM integer;
declare variable AMOUNT integer;
declare variable AG_ID integer;
begin

amount = 0;
OCOUNT = 0;

    FOR
       select ts.sd_fact_num,
              ts.sd_fact_date,
              ts.serv_id,
              ts.podacha_nums_inside1,
              ts.cu_okpo,
              ts.cu_name,
              ts.company_okpo,
              ts.ispaid,
              ts.ag_id,
              sum(ts.sd_sum),
              sum(ts.sd_sum_payed)

       from transfe_sdelka (:date_from, :date_to) ts
       group by 1,2,3,4,5,6,7,8,9
       INTO
           :p_fact_num,
           :p_fact_date,
           :p_serv_id,
           :p_descript,
           :p_cust_okpo,
           :p_cust_name,
           :p_company_okpo,
           :p_is_paid,
           :ag_id,
           :p_cost,
           :p_paid
    DO
    BEGIN
       if ((:p_cust_okpo = '') or (:p_cust_okpo is null) ) then p_cust_okpo = '.';

       if((:P_DESCRIPT IS NULL) or (:P_DESCRIPT = '')) then p_descript = '0 (2000-01-01)';

       if((:P_COMPANY_OKPO IS NULL) or (:P_COMPANY_OKPO = '')) then P_COMPANY_OKPO = '33302178';

       if (:p_serv_id = 5) then p_descript = '0 (2000-01-01)';

       if ((:p_descript IS NOT NULL) AND (not exists ( select 1
                        from paid_services pst
                        where
                                ((pst.fact_num is null) or (pst.fact_num = :p_fact_num))
                            and ((pst.fact_date is null) or (pst.fact_date = :p_fact_date))
                            and ((pst.serv_id is null) or (pst.serv_id = :p_serv_id))
                          --  and (pst.descript = :p_descript)
                            and ((pst.cost is null) or (pst.cost = :p_cost))
                          --  and ((pst.paid is null) or (pst.paid = :p_paid))
                          --  and ((pst.cust_okpo is null) or (pst.cust_okpo = :p_cust_okpo))
                          --  and ((pst.cust_name is null) or (pst.cust_name = :p_cust_name))
                           -- and ((pst.company_okpo is null) or (pst.company_okpo = :p_company_okpo))
                          --  and ((pst.is_paid is null) or (pst.is_paid = :p_is_paid))
--                            and (pst.loaded )
                      ))) then
         begin
    /* нужна проверка на выгрузку (Loaded) */

    
         INSERT INTO PAID_SERVICES (FACT_NUM, FACT_DATE, SERV_ID, DESCRIPT, COST, PAID, CUST_OKPO, CUST_NAME, COMPANY_OKPO, IS_PAID, LOADED, EDIT_TIME, ID, AG_ID, SD_ID, CREATE_DATE)
         VALUES (:p_fact_num, :p_fact_date, :p_serv_id, :p_descript, :p_cost, :p_paid, :p_cust_okpo, :p_cust_name, :p_company_okpo, :p_is_paid, 0, current_timestamp, null, :AG_ID, null, null);

          amount = amount + 1;
         end
         p_cust_okpo = null;
    END

    number_of_records = amount;
    suspend;
end^


ALTER PROCEDURE PAY_FOR_SDELKA (
    AG_ID INTEGER,
    SD_ID INTEGER,
    SUM_PAYED FLOAT,
    ALL_PAYED INTEGER)
AS
DECLARE VARIABLE COPY_SDID INTEGER;
BEGIN
    EXECUTE PROCEDURE FIND_COPY(AG_ID,SD_ID)
    RETURNING_VALUES :COPY_SDID;
    
    UPDATE SDELKA SD
        SET SD.SD_SUM_PAYED=:SUM_PAYED,
            SD.SD_ALL_PAYED=:ALL_PAYED
        WHERE SD.AG_ID=:AG_ID AND
              (
                SD.SD_ID=:SD_ID
                OR
                SD.SD_ID=:COPY_SDID
              )
    ;
END^


ALTER PROCEDURE PAY_SDELKAS (
    FACT_NUM INTEGER,
    PAY_SUM FLOAT)
RETURNS (
    CU_NAME VARCHAR(128))
AS
DECLARE VARIABLE SUM_DB FLOAT;
DECLARE VARIABLE MAX_CU INTEGER;
DECLARE VARIABLE MIN_CU INTEGER;
DECLARE VARIABLE MAX_AG INTEGER;
DECLARE VARIABLE MIN_AG INTEGER;
DECLARE VARIABLE AGID INTEGER;
DECLARE VARIABLE SDID INTEGER;
DECLARE VARIABLE SDSUM FLOAT;
BEGIN

    CU_NAME='Требуется оплата вручную.';
    
    SELECT
        SUM(SDR.SD_SUM),MAX(SDR.CU_ID),MIN(SDR.CU_ID),MAX(SDR.AG_ID),MIN(SDR.AG_ID)
    FROM SDELKA_REAL SDR
    WHERE
        (
            SDR.SD_FACT_NUM=:FACT_NUM
            AND
            ((SDR.SD_ALL_PAYED IS NULL) OR (SDR.SD_ALL_PAYED=0))
            AND
            ((SDR.SD_SUM_PAYED IS NULL) OR (SDR.SD_SUM_PAYED=0))
        )
    INTO :SUM_DB,:MAX_CU,:MIN_CU,:MAX_AG,:MIN_AG;
    
    IF ((SUM_DB=PAY_SUM)AND(MAX_CU=MIN_CU)AND(MAX_AG=MIN_AG)) THEN
    BEGIN

        FOR
            SELECT
                SDR.AG_ID,
                SDR.SD_ID,
                SDR.SD_SUM
            FROM SDELKA_REAL SDR
            WHERE
                (
                    SDR.SD_FACT_NUM=:FACT_NUM
                    AND
                    ((SDR.SD_ALL_PAYED IS NULL) OR (SDR.SD_ALL_PAYED=0))
                    AND
                    ((SDR.SD_SUM_PAYED IS NULL) OR (SDR.SD_SUM_PAYED=0))
                )
            INTO :AGID,:SDID,:SDSUM
        DO
            EXECUTE PROCEDURE PAY_FOR_SDELKA(AGID,SDID,SDSUM,1);

        SELECT CU_NAME FROM CUST
        WHERE AG_ID=:MAX_AG AND CU_ID=:MAX_CU
        INTO :CU_NAME;
        
        CU_NAME='Оплачены сделки клиента '||:CU_NAME;
    END
    
    
    SUSPEND;
END^


ALTER PROCEDURE PODACHA_DUPLICATE (
    P_DUPLICATE_AG_ID INTEGER,
    P_DUPLICATE_SD_ID INTEGER,
    P_SOURCE_PD_ID INTEGER,
    P_DUPLICATE_IS_ID INTEGER)
AS
DECLARE VARIABLE CNT INTEGER;
DECLARE VARIABLE DUPLICATE_PD_ID INTEGER;
begin

/*
    select count(*)
    from PODACHA_DUPL pdu
    where pdu.DUPL_OF_PD_ID = :P_SOURCE_PD_ID
    into :cnt;


    -- Если дубля нет, то создаем его
    if (cnt = 0) then
    begin
        duplicate_pd_id = gen_id(G_PD_ID, 1);

        -- Вставляем дубль подачи
        insert into PODACHA (
            GZ_ID
            ,IS_ID
            ,AG_ID
            ,SD_ID
            ,PD_FREE_OF_CHARGE
            ,PD_ID
            ,PD_ADDDATE
            ,PD_IS_DONE
        )
        select
            s.GZ_ID
            ,:P_DUPLICATE_IS_ID
            ,s.AG_ID
            ,s.SD_ID
            ,p.PD_FREE_OF_CHARGE
            ,:duplicate_pd_id
            ,CURRENT_TIMESTAMP
            ,p.PD_IS_DONE
        from PODACHA p
        left join SDELKA s on (s.AG_ID = :P_DUPLICATE_AG_ID
                               and s.SD_ID = :P_DUPLICATE_SD_ID)
        where p.PD_ID = :P_SOURCE_PD_ID;

        -- Вставляем развязку на дубль подачи
        insert into PODACHA_DUPL (
            PD_ID
            ,DUPL_OF_PD_ID
        )
        values (
            :duplicate_pd_id
            ,:P_SOURCE_PD_ID
        );
    end
*/
/* Тут должно быть реализовано копирование признака "бесплатности"
   на подачу-копию, а также установку подачи в запас/восстановление
   из него
    -- Заведен - обновим
    else if (cnt = 1) then
    begin

        select odu.OB_ID
        from OBJAV_DUPL odu
        where odu.AG_ID = :P_DUPLICATE_AG_ID
              and odu.SD_ID = :P_DUPLICATE_SD_ID
              and odu.DUPL_OF_OB_ID = :P_SOURCE_OB_ID
        into :duplicate_ob_id;

        update PODACHA p
        set p.PD_FREE_OF_CHARGE = (
            select p_s.PD_FREE_OF_CHARGE
            from PODACHA p_s
            left join PODACHA_DUPL p_d on (p_d.DUPL_OF_PD_ID = p_s.PD_ID)
            where p_s.PD_ID = :P_SOURCE_PD_ID
        )
        where p.PD_ID = (
            select p_d.PD_ID
            from PODACHA_DUPL p_d
            where p_d.DUPL_OF_PD_ID = :P_SOURCE_PD_ID;
        )
    end
*/
end^


ALTER PROCEDURE PODACHA_FILL_OBJAVS (
    PD_ID INTEGER)
AS
DECLARE VARIABLE AGID INTEGER;
DECLARE VARIABLE SDID INTEGER;
DECLARE VARIABLE PDID INTEGER;
DECLARE VARIABLE DUMB INTEGER;
BEGIN
    SELECT AG_ID, SD_ID FROM PODACHA
    WHERE PD_ID = :PD_ID INTO :AGID, :SDID;
    EXECUTE PROCEDURE GET_CURRENT_PODACHA(:AGID, :SDID)
    RETURNING_VALUES :PDID, :DUMB, :DUMB;
/*    IF (PDID) */
END^


ALTER PROCEDURE PODACHA_GET_BY_ORDER_NO (
    P_AG_ID INTEGER,
    P_SD_ID INTEGER,
    P_ORDER_NO INTEGER)
RETURNS (
    P_PD_ID INTEGER)
AS
declare variable cnt integer;
begin
    -- Находит в сделке подачу с указанным порядковым номером
    -- (порядок подач определяется по дате выхода)
    cnt = 0;
    P_PD_ID = null;

    for
        select p.PD_ID
        from PODACHA p
        left join ISSUE i on (i.IS_ID = p.IS_ID)
        where p.AG_ID = :P_AG_ID
              and p.SD_ID = :P_SD_ID
        order by i.IS_DATE
        into :P_PD_ID
    do
    begin
        cnt = cnt + 1;
        if (cnt = :P_ORDER_NO) then
            break;
    end

    if (cnt <> :P_ORDER_NO) then
        P_PD_ID = null;

    suspend;
end^


ALTER PROCEDURE PODACHA_INSERT (
    AG_ID INTEGER,
    SD_ID INTEGER,
    GZ_ID INTEGER,
    IS_ID INTEGER,
    PD_FREE_OF_CHARGE INTEGER)
AS
DECLARE VARIABLE OLD_PDID INTEGER;
DECLARE VARIABLE DUMB INTEGER;
DECLARE VARIABLE NEW_PDID INTEGER;
DECLARE VARIABLE OBJAVID INTEGER;
DECLARE VARIABLE CONTENTID INTEGER;
DECLARE VARIABLE RBID INTEGER;
DECLARE VARIABLE FMID INTEGER;
DECLARE VARIABLE VACCOUNT INTEGER;
DECLARE VARIABLE DOUBLERBID INTEGER;
DECLARE VARIABLE SAMECODE INTEGER;
DECLARE VARIABLE OBJAVCOMMENT VARCHAR(255);
DECLARE VARIABLE OBJAVHASATTENTION SMALLINT;
DECLARE VARIABLE PICTURETOINET SMALLINT;
BEGIN
/* вставим подачу, после чего скопируем в Объявления к ней все
   Объявления из текущей подачи сделки */
    EXECUTE PROCEDURE GET_CURRENT_PODACHA(:AG_ID, :SD_ID)
    RETURNING_VALUES :OLD_PDID, :DUMB, :DUMB;
    NEW_PDID = GEN_ID(G_PD_ID,1);
    INSERT INTO PODACHA (AG_ID, SD_ID, PD_ID, GZ_ID, IS_ID, PD_FREE_OF_CHARGE)
    VALUES (:AG_ID, :SD_ID, :NEW_PDID, :GZ_ID, :IS_ID, :PD_FREE_OF_CHARGE);
    FOR
        SELECT
            O.OBJAV_ID
        FROM
            OBJAVLENIE O
        WHERE
            O.PD_ID = :OLD_PDID
        INTO
            :OBJAVID
    DO
    BEGIN
        SELECT CONTENT_ID, RB_ID, FM_ID, VAC_COUNT, DOUBLE_RB_ID, SAME_CODE, OBJAV_COMMENT, OBJAV_HAS_ATTENTION, PICTURE_TO_INET
        FROM OBJAVLENIE
        WHERE OBJAV_ID = :OBJAVID
        INTO :CONTENTID, :RBID, :FMID, :VACCOUNT, :DOUBLERBID, :SAMECODE, :OBJAVCOMMENT, :OBJAVHASATTENTION, :PICTURETOINET;
        INSERT INTO OBJAVLENIE (OBJAV_ID, PD_ID, RB_ID, FM_ID, VAC_COUNT, DOUBLE_RB_ID, CONTENT_ID, SAME_CODE, OBJAV_COMMENT, OBJAV_HAS_ATTENTION, PICTURE_TO_INET)
        VALUES (GEN_ID(G_OBJAV_ID,1), :NEW_PDID, :RBID, :FMID, :VACCOUNT, :DOUBLERBID, :CONTENTID, :SAMECODE, :OBJAVCOMMENT, :OBJAVHASATTENTION, :PICTURETOINET);
    END
END^


ALTER PROCEDURE PODACHA_IS_CURRENT_AND_EDITABLE (
    PD_ID INTEGER)
RETURNS (
    RESULT INTEGER)
AS
DECLARE VARIABLE AGID INTEGER;
DECLARE VARIABLE SDID INTEGER;
DECLARE VARIABLE PDID INTEGER;
DECLARE VARIABLE ISID INTEGER;
DECLARE VARIABLE ISCLOSED INTEGER;
BEGIN
  SELECT AG_ID,SD_ID FROM PODACHA
  WHERE PD_ID = :PD_ID
  INTO :AGID,:SDID;
  EXECUTE PROCEDURE GET_CURRENT_PODACHA (:AGID,:SDID)
  RETURNING_VALUES :PDID,:ISID,:ISCLOSED;
  IF ((PDID > 0) AND (PDID = :PD_ID) AND (ISCLOSED = 0)) THEN
    RESULT = 1;
  ELSE
    RESULT = 0;
  SUSPEND;
END^


ALTER PROCEDURE REFRESH_OTKAZNIK (
    LAST_ISSUE_PR INTEGER,
    LAST_ISSUE_NS INTEGER,
    LAST_ISSUE_SR INTEGER,
    LAST_ISSUE_RZ INTEGER,
    LAST_ISSUE_RK INTEGER)
AS
declare variable AGID integer;
declare variable SDID integer;
declare variable CUID integer;
declare variable NUMB char(16);
declare variable GZID integer;
declare variable SDTYPE integer;
declare variable LASTISS integer;
declare variable LASTISSDATE date;
declare variable SDDATE date;
BEGIN
    DELETE FROM OTKAZNIK WHERE OT_IS_STATIC<>1;
    SELECT p.PM_FIRST_OTKAZNIK_ISSUE_PR FROM PARAMS p INTO :LAST_ISSUE_PR;
    SELECT p.PM_FIRST_OTKAZNIK_ISSUE_SR FROM PARAMS p INTO :LAST_ISSUE_SR;

    SELECT MIN(ISS.IS_DATE) FROM ISSUE ISS
    WHERE
        ISS.IS_ID=:LAST_ISSUE_PR
        OR ISS.IS_ID=:LAST_ISSUE_NS
        OR ISS.IS_ID=:LAST_ISSUE_SR
        OR ISS.IS_ID=:LAST_ISSUE_RZ
        OR ISS.IS_ID=:LAST_ISSUE_RK
    INTO :lastissDate;
    FOR
        SELECT AG_ID,SD_ID,CU_ID,GZ_ID,SD_TYPE,SD_DATE FROM SDELKA SD
            WHERE
                SD.SD_TYPE IN (1,3,4,5,6)
                AND
                SD.SD_STATE>=4
                AND
                SD.SD_STATE<>100
                AND
                SD.AS_ID in (0,1)
                AND
                SD.SD_DATE >= CURRENT_TIMESTAMP - 365 * 2
            INTO
                :agid,:sdid,:cuid,:gzid,:sdtype,sddate
    DO
    BEGIN
        SELECT MAX(IS_ID) FROM PODACHA PD
            WHERE
                PD.AG_ID=:agid
                AND
                PD.SD_ID=:sdid
            INTO
                :lastiss;
        IF (   (gzid=1 AND lastiss>=LAST_ISSUE_PR)
            OR (gzid=2 AND lastiss>=LAST_ISSUE_NS)
            OR (gzid=3 AND lastiss>=LAST_ISSUE_SR)
            OR (gzid=4 AND lastiss>=LAST_ISSUE_RZ)
            OR (gzid=5 AND lastiss>=LAST_ISSUE_RK)
            OR (sdtype in (3,4,5,6) AND sddate>=lastissDate))
        THEN
        BEGIN
            FOR
                SELECT CP_NUMBER FROM CUST_PHONE CP
                    WHERE
                        CP.AG_ID=:agid
                        AND
                        CP.CU_ID=:cuid
                        AND
                        NOT EXISTS (SELECT * FROM OTKAZNIK WHERE OT_NUMBER=CP.CP_NUMBER)
                    INTO
                        :numb
            DO
                IF (numb IS NOT NULL) THEN
                    INSERT INTO OTKAZNIK (OT_NUMBER,AG_ID,OT_IS_STATIC)
                    VALUES (:numb,:agid,0)
            ;
        END
    END
END^


ALTER PROCEDURE REFRESH_OTKAZNIK_NEW
AS
declare variable AGID integer;
declare variable CUID integer;
declare variable GZID integer;
declare variable LASTISS integer;
BEGIN
DELETE FROM OTKAZNIK WHERE OT_IS_STATIC<>1;
FOR SELECT g.GZ_ID FROM gazeta g INTO :GZID DO
BEGIN
      LASTISS = NULL;
      IF (GZID = 1) THEN SELECT p.PM_FIRST_OTKAZNIK_ISSUE_PR FROM PARAMS p INTO :LASTISS;

      ELSE IF (GZID = 3) THEN SELECT p.PM_FIRST_OTKAZNIK_ISSUE_SR FROM PARAMS p INTO :LASTISS;

      IF (LASTISS IS NOT NULL) THEN
      BEGIN
           FOR SELECT s.AG_ID, s.CU_ID
               FROM PODACHA p
               LEFT JOIN sdelka s ON (s.AG_ID = p.AG_ID AND s.SD_ID = p.SD_ID)
               WHERE p.IS_ID >= :LASTISS
               AND   s.GZ_ID = :GZID
               AND   s.SD_TYPE IN (1,3,4,5,6)
               AND   s.SD_STATE >= 4
               AND   s.SD_STATE <> 100
               AND   s.AS_ID IN (0,1)
               INTO :AGID, :CUID DO
           BEGIN
                 INSERT INTO OTKAZNIK
                 SELECT  CP_NUMBER, cp.AG_ID, 0, NULL, CURRENT_TIMESTAMP
                 FROM CUST_PHONE CP
                 WHERE cp.AG_ID = :agid
                 AND   cp.CU_ID = :cuid
                 AND   NOT EXISTS (SELECT * FROM OTKAZNIK WHERE OT_NUMBER=CP.CP_NUMBER);
           END
      END
END

END^


ALTER PROCEDURE REP_ASSISTANTS (
    P_DATE_FROM TIMESTAMP,
    P_DATE_TO TIMESTAMP)
RETURNS (
    US_NAME VARCHAR(128),
    SDELKA_COUNT INTEGER)
AS
begin
    for
        select
            u.US_NAME
            ,count(1)
        from
            SDELKA sd
            
            left join USR u on (u.US_ID = sd.REGISTERED_BY_ID)
        where
            sd.SD_DATE >= :p_date_from
            and sd.SD_DATE < :p_date_to + 1
            and sd.SD_STATE <> 100
            and sd.SD_STATE >= 4
        group by sd.REGISTERED_BY_ID, u.US_NAME
        into
            :US_NAME, :SDELKA_COUNT
    do
    begin
        suspend;
    end
end^


ALTER PROCEDURE REP_BARTER_ITOG (
    P_GZ_ID INTEGER,
    P_IS_ID INTEGER)
RETURNS (
    AG_ID INTEGER,
    SDELKA_COUNT INTEGER,
    TOTAL_SPACE FLOAT,
    TOTAL_SUM FLOAT)
AS
begin
    for
        select
            sd.AG_ID
            ,count(distinct sd.SD_ID)
            ,sum(fm.FM_SPACE)
            ,sum(sd.SD_SUM)
        from
            SDELKA sd
            
            left join PODACHA pd on (pd.AG_ID = sd.AG_ID and pd.SD_ID = sd.SD_ID)

            left join GET_MAX_FORMAT_AND_RUBRIKA(sd.AG_ID, sd.SD_ID) mfr on (1 = 1)

            left join FORMAT fm on (fm.FM_ID = mfr.FM_ID)
        where
            sd.GZ_ID = :P_GZ_ID
            and pd.IS_ID = :P_IS_ID
            and sd.PT_ID = 4
            and sd.SD_STATE <> 100
            and sd.AS_ID <> 2
        group by sd.AG_ID
        into
            :AG_ID, :SDELKA_COUNT, :TOTAL_SPACE, :TOTAL_SUM
    do
    begin
        suspend;
    end
end^


ALTER PROCEDURE REP_CUST_VIP (
    AG_ID_INPUT INTEGER,
    DATE_FROM TIMESTAMP,
    DATE_TO TIMESTAMP)
RETURNS (
    CU_ID INTEGER,
    KA_COUNT INTEGER,
    INET_COUNT INTEGER,
    TOTAL_COUNT INTEGER,
    KA_SUM FLOAT,
    INET_SUM FLOAT,
    TOTAL_SUM FLOAT,
    AG_ID INTEGER)
AS
declare variable FM_VIP integer;
declare variable TMP_SD integer;
declare variable TMP_SUM integer;
BEGIN
    AG_ID = :AG_ID_INPUT;
    FM_VIP = 15;
    
    TOTAL_SUM   = 0;
    TOTAL_COUNT = 0;
    KA_SUM      = 0;
    KA_COUNT    = 0;
    INET_SUM    = 0;
    INET_COUNT  = 0;
    
    /* Идём по всем клиентам, для каждого смотрим, какие ВИПы он давал */
    for
        select
              distinct sd.CU_ID
        from
            SDELKA sd

            left join PODACHA pd
            on (pd.AG_ID = sd.AG_ID and pd.SD_ID = sd.SD_ID)

            left join OBJAVLENIE ob
            on (ob.PD_ID = pd.PD_ID)
        where
         sd.AG_ID = :AG_ID
         and sd.SD_STATE <> 100
         and sd.SD_STATE >= 4
            and sd.AS_ID <> 2
            and cast (sd.SD_APPROVED_DATE as date) >= :DATE_FROM
            and cast (sd.SD_APPROVED_DATE as date) <= :DATE_TO
            and ob.FM_ID = :FM_VIP
        into :CU_ID
    do
    begin
        /* Всего */
        for
            select distinct sd.SD_ID, sd.SD_SUM
            from
                SDELKA sd
            
                left join PODACHA pd
                on (pd.AG_ID = sd.AG_ID and pd.SD_ID = sd.SD_ID)

                left join OBJAVLENIE ob
                on (ob.PD_ID = pd.PD_ID)
            where
             sd.AG_ID = :AG_ID
             and sd.CU_ID = :CU_ID
             and sd.SD_STATE <> 100
             and sd.SD_STATE >= 4
                and sd.AS_ID <> 2
                and cast (sd.SD_APPROVED_DATE as date) >= :DATE_FROM
                and cast (sd.SD_APPROVED_DATE as date) <= :DATE_TO
                and ob.FM_ID = :FM_VIP
            into :TMP_SD, :TMP_SUM
        do
        begin
            TOTAL_SUM = TOTAL_SUM + TMP_SUM;
            TOTAL_COUNT = TOTAL_COUNT + 1;
        end
         
        /* Сделок в КА */
        for
            select distinct sd.SD_ID, sd.SD_SUM
            from
                SDELKA sd

                left join PODACHA pd
                on (pd.AG_ID = sd.AG_ID and pd.SD_ID = sd.SD_ID)

                left join OBJAVLENIE ob
                on (ob.PD_ID = pd.PD_ID)
            where
             sd.AG_ID = :AG_ID
             and sd.CU_ID = :CU_ID
             and sd.SD_TYPE = 3 
             and sd.SD_STATE <> 100
             and sd.SD_STATE >= 4
                and sd.AS_ID <> 2
                and cast (sd.SD_APPROVED_DATE as date) >= :DATE_FROM
                and cast (sd.SD_APPROVED_DATE as date) <= :DATE_TO
                and ob.FM_ID = :FM_VIP
            into :TMP_SD, :TMP_SUM
        do
        begin
            KA_SUM = KA_SUM + TMP_SUM;
            KA_COUNT = KA_COUNT + 1;
        end
         
        /* С копией в Интернет */
        for
            select distinct sd.SD_ID, sd.SD_SUM
            from
                SDELKA sd

                left join PODACHA pd
                on (pd.AG_ID = sd.AG_ID and pd.SD_ID = sd.SD_ID)

                left join OBJAVLENIE ob
                on (ob.PD_ID = pd.PD_ID)
            where
             sd.AG_ID = :AG_ID
             and sd.CU_ID = :CU_ID
             and sd.SD_TYPE = 1
             and sd.SD_STATE <> 100
             and sd.SD_STATE >= 4
                and sd.AS_ID <> 2
                and cast (sd.SD_APPROVED_DATE as date) >= :DATE_FROM
                and cast (sd.SD_APPROVED_DATE as date) <= :DATE_TO
                and ob.FM_ID = :FM_VIP
                and OB.PICTURE_TO_INET = 1
            into :TMP_SD, :TMP_SUM
        do
        begin
            INET_SUM = INET_SUM + TMP_SUM;
            INET_COUNT = INET_COUNT + 1;
        end

        suspend;
    end
end^


ALTER PROCEDURE REP_MODULI_BY_DESIGNER (
    P_DATE_FROM TIMESTAMP,
    P_DATE_TO TIMESTAMP)
RETURNS (
    US_ID INTEGER,
    US_NAME VARCHAR(200),
    CONTENT_COUNT INTEGER)
AS
begin
    for
        select
             ll.US_ID
            ,us.US_NAME
            ,count(1)
        from
            OBJAV_CONTENT_LOAD_LOG ll
    
            left join USR us on (us.US_ID = ll.US_ID)
        where
            ll.LL_DATE >= :p_date_from
            and ll.LL_DATE < :p_date_to + 1
        group by
            ll.US_ID, us.US_NAME
        order by
            us.US_NAME
        into
             :US_ID
            ,:US_NAME
            ,:CONTENT_COUNT
    do
    begin
        suspend;
    end
end^


ALTER PROCEDURE REP_PHONES_EXIT_FROM_OTKAZNIK (
    AG_ID_INPUT INTEGER,
    LAST_ISSUE_PR INTEGER,
    LAST_ISSUE_NS INTEGER,
    LAST_ISSUE_SR INTEGER,
    LAST_ISSUE_RZ INTEGER,
    LAST_ISSUE_RK INTEGER)
RETURNS (
    PH_NUMBER VARCHAR(16))
AS
declare variable LASTISSDATE timestamp;
declare variable WILLBE smallint;
Begin
  --  exception e_district_nn;
    select
        min(iss.IS_DATE)
    from
        ISSUE iss
    where
        iss.IS_ID = :LAST_ISSUE_PR
        or iss.IS_ID = :LAST_ISSUE_NS
        or iss.IS_ID = :LAST_ISSUE_SR
        or iss.IS_ID = :LAST_ISSUE_RZ
        or iss.IS_ID = :LAST_ISSUE_RK
    into :lastissDate;

    for
        select OT_NUMBER
        from OTKAZNIK
        where AG_ID = :AG_ID_INPUT
        into :PH_NUMBER
    do
    begin
        execute procedure
        CHECK_PHONE_WILL_BE_IN_OTKAZNIK(
            :AG_ID_INPUT
            ,:PH_NUMBER
            ,:LAST_ISSUE_PR
            ,:LAST_ISSUE_NS
            ,:LAST_ISSUE_SR
            ,:LAST_ISSUE_RZ
            ,:LAST_ISSUE_RK
            ,:lastissDate)
        returning_values :willBe;

        if (:willBe=0) then
            suspend;
    end
END^


ALTER PROCEDURE REP_SDELKA_BY_OFFICE (
    OFFICE_ID INTEGER,
    RQ_ID INTEGER,
    PT_ID INTEGER,
    DATE_FROM TIMESTAMP,
    DATE_TO TIMESTAMP)
RETURNS (
    SD_ID_COMPOUND VARCHAR(200),
    SD_DATE TIMESTAMP,
    SD_FACT_NUM INTEGER,
    AG_NAME VARCHAR(200),
    CU_NAME VARCHAR(200),
    CU_PHONES VARCHAR(200),
    SD_TYPE_DESC VARCHAR(200),
    FM_NAME VARCHAR(200),
    PODACHA_NUMS VARCHAR(200),
    SD_SUM FLOAT,
    US_NAME VARCHAR(200),
    RQ_NAME VARCHAR(32),
    GZ_ID INTEGER)
AS
begin
    for
        select
            sd.SD_ID_COMPOUND
            ,sd.SD_DATE
            ,sd.SD_FACT_NUM
            ,ag.AG_NAME
            ,cu.CU_NAME
            ,left(cp.CU_PHONES, 200) as CU_PHONES
            ,sdt.SD_TYPE_DESC
            ,fm.FM_NAME
            ,left(spn.PODACHA_NUMS, 200) as PODACHA_NUMS
            ,sd.SD_SUM
            ,us.US_NAME
            ,sd.GZ_ID
        from
            SDELKA sd
    
            left join AGENT ag on (sd.AG_ID = ag.AG_ID)

            left join CUST cu on (cu.AG_ID = sd.AG_ID and cu.CU_ID = sd.CU_ID)

            left join GET_CUST_PHONES(sd.AG_ID, sd.CU_ID) cp on (1 = 1)

            left join SDELKA_TYPE_DESC sdt on (sdt.SD_TYPE = sd.SD_TYPE and sdt.GZ_ID = sd.GZ_ID)

            left join GET_MAX_FORMAT_AND_RUBRIKA(sd.AG_ID, sd.SD_ID) mfr on (1 = 1)

            left join FORMAT fm on (fm.FM_ID = mfr.FM_ID)

            left join SDELKA_PODACHA_NUMS(sd.AG_ID, sd.SD_ID) spn on (1 = 1)

            left join USR us on (us.US_ID = sd.REGISTERED_BY_ID)
        where
            us.OF_ID = :office_id
            and sd.RQ_ID = :rq_id
            --and sd.PT_ID = :pt_id
            and sd.PT_ID in (6)
            and sd.SD_DATE >= :date_from
            and sd.SD_DATE < :date_to + 1
            and sd.SD_STATE <> 100
            and sd.SD_STATE >= 4
            and sd.AS_ID <> 2
        order by
            SD_DATE
        into
            :SD_ID_COMPOUND
            ,:SD_DATE
            ,:SD_FACT_NUM
            ,:AG_NAME
            ,:CU_NAME
            ,:CU_PHONES
            ,:SD_TYPE_DESC
            ,:FM_NAME
            ,:PODACHA_NUMS
            ,:SD_SUM
            ,:US_NAME
            ,:GZ_ID
    do
    begin
        suspend;
    end
end^


ALTER PROCEDURE REP_SDELKA_CROSSING_MONTH (
    DATE_FROM TIMESTAMP,
    DATE_TO TIMESTAMP)
RETURNS (
    AG_NAME VARCHAR(128),
    CU_NAME VARCHAR(128),
    CU_OKPO CHAR(10),
    PT_NAME VARCHAR(64),
    SD_FACT_NUM INTEGER,
    SD_FACT_DATE TIMESTAMP,
    GZ_NAME_SHORT VARCHAR(64),
    PODACHA_NUMS_INSIDE VARCHAR(255),
    SD_SUM FLOAT,
    SD_SUM_PAYED FLOAT,
    SD_SUM_PART FLOAT,
    SUM_TOTAL_OUT FLOAT,
    SUM_PART_OUT FLOAT,
    SUM_PAYED_OUT FLOAT)
AS
declare variable CNT_TOTAL integer;
declare variable AGID integer;
declare variable SDID integer;
declare variable CNT_INSIDE integer;
declare variable SUM_TOTAL_V float;
declare variable SUM_PART_V float;
declare variable SUM_PAYED_V float;
begin

sum_total_v = 0;
sum_part_v  = 0;
sum_payed_v = 0;

    for
        select
            pd.AG_ID, pd.SD_ID, count(*)
        from
            ISSUE iss
            inner join PODACHA pd on (pd.IS_ID = iss.IS_ID)
            inner join sdelka s on (s.ag_id = pd.ag_id and s.sd_id = pd.sd_id)
        where
            iss.IS_DATE >= :DATE_FROM
            and iss.IS_DATE <= :DATE_TO

            --команда Коваленко ТОВ "Успіх Плюс"
            and ((pd.ag_id in (34,304,94,309,42,308,4,307,22,305)) or (s.RQ_ID = 2))

            --все кроме команды Ковалеко
           -- and ((pd.ag_id not in (34,304,94,309,42,308,4,307,22,305)) and s.rq_id <> 3)

            -- Только инвестиция
          -- and (s.rq_id = 3)

        group by
            pd.AG_ID, pd.SD_ID
        order by
            pd.AG_ID, pd.SD_ID
        into
            :AGID, :SDID, :CNT_INSIDE
    do
    begin
        select
            count(*)
        from
            PODACHA p
            inner join ISSUE i on (i.IS_ID = p.IS_ID)
        where
            p.AG_ID = :AGID
            and p.SD_ID = :SDID
        into
            :CNT_TOTAL;


        if (CNT_TOTAL >= CNT_INSIDE) then
        begin

            select
                a.AG_NAME
                ,c.CU_NAME
                ,c.CU_OKPO
                ,pt.PT_NAME
                ,s.SD_FACT_NUM
                ,s.SD_FACT_DATE
                ,g.GZ_NAME_SHORT
                ,s.SD_SUM
                ,s.SD_SUM_PAYED
                ,s.SD_SUM * :CNT_INSIDE/:CNT_TOTAL
            from
                SDELKA s
                inner join AGENT a on (a.AG_ID = s.AG_ID)
                inner join CUST c on (c.AG_ID = s.AG_ID and c.CU_ID = s.CU_ID)
                inner join GAZETA g on (g.GZ_ID = s.GZ_ID)
                inner join PAY_TYPE pt on (pt.PT_ID = s.PT_ID)
            where
                s.AG_ID = :AGID
                and s.SD_ID = :SDID
                -- not payed:
                and s.SD_STATE <> 100
                and s.SD_STATE > 4
                --and pt.pt_id <> 3 --без оплаты по кредиту
               and pt.pt_id in (2) --оплата по безналу

                and (s.SD_ALL_PAYED = 0 or s.SD_ALL_PAYED is null)
                and s.AS_ID <> 2
            into
                :AG_NAME
                ,:CU_NAME
                ,:CU_OKPO
                ,:PT_NAME
                ,:SD_FACT_NUM
                ,:SD_FACT_DATE
                ,:GZ_NAME_SHORT
                ,:SD_SUM
                ,:SD_SUM_PAYED
                ,:SD_SUM_PART;

            if (AG_NAME is not null) then
            begin
                select spd.PODACHA_NUMS
                from SDELKA_PODACHA_NUMS_DATES(:AGID, :SDID, :DATE_FROM, :DATE_TO) spd
                into :PODACHA_NUMS_INSIDE;

                if (sd_sum is not null) then
                 begin
                   sum_total_v = sum_total_v + sd_sum;
                   sum_total_out = sum_total_v;
                 end

                if (sd_sum_part is not null) then
                 begin
                   sum_part_v = sum_part_v  + sd_sum_part;
                   sum_part_out = sum_part_v;
                 end

                if (sd_sum_payed is not null) then
                  begin
                   sum_payed_v = sum_payed_v + sd_sum_payed;
                   sum_payed_out = sum_payed_v;
                  end

                suspend;
            end
            AG_NAME = null;
        end
    end
end^


ALTER PROCEDURE REP_SDELKA_CROSSING_MONTH2 (
    DATE_FROM TIMESTAMP,
    DATE_TO TIMESTAMP)
RETURNS (
    AG_NAME VARCHAR(128),
    CU_NAME VARCHAR(128),
    CU_OKPO CHAR(10),
    PT_NAME VARCHAR(64),
    SD_FACT_NUM INTEGER,
    SD_FACT_DATE TIMESTAMP,
    GZ_NAME_SHORT VARCHAR(64),
    PODACHA_NUMS_INSIDE VARCHAR(255),
    SD_SUM FLOAT,
    SD_SUM_PAYED FLOAT,
    SD_SUM_PART FLOAT,
    SUM_TOTAL_OUT FLOAT,
    SUM_PART_OUT FLOAT,
    SUM_PAYED_OUT FLOAT)
AS
declare variable CNT_TOTAL integer;
declare variable AGID integer;
declare variable SDID integer;
declare variable CNT_INSIDE integer;
declare variable SUM_TOTAL_V float;
declare variable SUM_PART_V float;
declare variable SUM_PAYED_V float;
begin

sum_total_v = 0;
sum_part_v  = 0;
sum_payed_v = 0;

    for
        select
            pd.AG_ID, pd.SD_ID, count(*)
        from
            ISSUE iss
            inner join PODACHA pd on (pd.IS_ID = iss.IS_ID)
            inner join sdelka s on (s.ag_id = pd.ag_id and s.sd_id = pd.sd_id)
        where
            iss.IS_DATE >= :DATE_FROM
            and iss.IS_DATE <= :DATE_TO

            --команда Коваленко ТОВ "Успіх Плюс"
          --  and ((pd.ag_id in (34,304,94,309,42,308,4,307,22,305)) or (s.RQ_ID = 2))

            --все кроме команды Ковалеко
            and ((pd.ag_id not in (34,304,94,309,42,308,4,307,22,305)) and s.rq_id <> 3)

            -- Только инвестиция
          -- and (s.rq_id = 3)

        group by
            pd.AG_ID, pd.SD_ID
        order by
            pd.AG_ID, pd.SD_ID
        into
            :AGID, :SDID, :CNT_INSIDE
    do
    begin
        select
            count(*)
        from
            PODACHA p
            inner join ISSUE i on (i.IS_ID = p.IS_ID)
        where
            p.AG_ID = :AGID
            and p.SD_ID = :SDID
        into
            :CNT_TOTAL;


        if (CNT_TOTAL >= CNT_INSIDE) then
        begin

            select
                a.AG_NAME
                ,c.CU_NAME
                ,c.CU_OKPO
                ,pt.PT_NAME
                ,s.SD_FACT_NUM
                ,s.SD_FACT_DATE
                ,g.GZ_NAME_SHORT
                ,s.SD_SUM
                ,s.SD_SUM_PAYED
                ,s.SD_SUM * :CNT_INSIDE/:CNT_TOTAL
            from
                SDELKA s
                inner join AGENT a on (a.AG_ID = s.AG_ID)
                inner join CUST c on (c.AG_ID = s.AG_ID and c.CU_ID = s.CU_ID)
                inner join GAZETA g on (g.GZ_ID = s.GZ_ID)
                inner join PAY_TYPE pt on (pt.PT_ID = s.PT_ID)
            where
                s.AG_ID = :AGID
                and s.SD_ID = :SDID
                -- not payed:
                and s.SD_STATE <> 100
                and s.SD_STATE > 4
                --and pt.pt_id <> 3 --без оплаты по кредиту
               and pt.pt_id in (2)
 --               and s.pt_id = 2 --оплата по безналу
                and (s.SD_ALL_PAYED = 0 or s.SD_ALL_PAYED is null)
                and s.AS_ID <> 2
            into
                :AG_NAME
                ,:CU_NAME
                ,:CU_OKPO
                ,:PT_NAME
                ,:SD_FACT_NUM
                ,:SD_FACT_DATE
                ,:GZ_NAME_SHORT
                ,:SD_SUM
                ,:SD_SUM_PAYED
                ,:SD_SUM_PART;

            if (AG_NAME is not null) then
            begin
                select spd.PODACHA_NUMS
                from SDELKA_PODACHA_NUMS_DATES(:AGID, :SDID, :DATE_FROM, :DATE_TO) spd
                into :PODACHA_NUMS_INSIDE;

                if (sd_sum is not null) then
                 begin
                   sum_total_v = sum_total_v + sd_sum;
                   sum_total_out = sum_total_v;
                 end

                if (sd_sum_part is not null) then
                 begin
                   sum_part_v = sum_part_v  + sd_sum_part;
                   sum_part_out = sum_part_v;
                 end

                if (sd_sum_payed is not null) then
                  begin
                   sum_payed_v = sum_payed_v + sd_sum_payed;
                   sum_payed_out = sum_payed_v;
                  end

                suspend;
            end
            AG_NAME = null;
        end
    end
end^


ALTER PROCEDURE REP_SDELKA_CROSSING_MONTH3 (
    DATE_FROM TIMESTAMP,
    DATE_TO TIMESTAMP)
RETURNS (
    AG_NAME VARCHAR(128),
    CU_NAME VARCHAR(128),
    CU_OKPO CHAR(10),
    PT_NAME VARCHAR(64),
    SD_FACT_NUM INTEGER,
    SD_FACT_DATE TIMESTAMP,
    GZ_NAME_SHORT VARCHAR(64),
    PODACHA_NUMS_INSIDE VARCHAR(255),
    SD_SUM FLOAT,
    SD_SUM_PAYED FLOAT,
    SD_SUM_PART FLOAT,
    SUM_TOTAL_OUT FLOAT,
    SUM_PART_OUT FLOAT,
    SUM_PAYED_OUT FLOAT)
AS
declare variable CNT_TOTAL integer;
declare variable AGID integer;
declare variable SDID integer;
declare variable CNT_INSIDE integer;
declare variable SUM_TOTAL_V float;
declare variable SUM_PART_V float;
declare variable SUM_PAYED_V float;
begin

sum_total_v = 0;
sum_part_v  = 0;
sum_payed_v = 0;

    for
        select
            pd.AG_ID, pd.SD_ID, count(*)
        from
            ISSUE iss
            inner join PODACHA pd on (pd.IS_ID = iss.IS_ID)
            inner join sdelka s on (s.ag_id = pd.ag_id and s.sd_id = pd.sd_id)
        where
            iss.IS_DATE >= :DATE_FROM
            and iss.IS_DATE <= :DATE_TO

            --команда Коваленко ТОВ "Успіх Плюс"
          --  and ((pd.ag_id in (34,304,94,309,42,308,4,307,22,305)) or (s.RQ_ID = 2))

            --все кроме команды Ковалеко
           -- and ((pd.ag_id not in (34,304,94,309,42,308,4,307,22,305)) and s.rq_id <> 3)

            -- Только инвестиция
           and (s.rq_id = 3)

        group by
            pd.AG_ID, pd.SD_ID
        order by
            pd.AG_ID, pd.SD_ID
        into
            :AGID, :SDID, :CNT_INSIDE
    do
    begin
        select
            count(*)
        from
            PODACHA p
            inner join ISSUE i on (i.IS_ID = p.IS_ID)
        where
            p.AG_ID = :AGID
            and p.SD_ID = :SDID
        into
            :CNT_TOTAL;


        if (CNT_TOTAL >= CNT_INSIDE) then
        begin

            select
                a.AG_NAME
                ,c.CU_NAME
                ,c.CU_OKPO
                ,pt.PT_NAME
                ,s.SD_FACT_NUM
                ,s.SD_FACT_DATE
                ,g.GZ_NAME_SHORT
                ,s.SD_SUM
                ,s.SD_SUM_PAYED
                ,s.SD_SUM * :CNT_INSIDE/:CNT_TOTAL
            from
                SDELKA s
                inner join AGENT a on (a.AG_ID = s.AG_ID)
                inner join CUST c on (c.AG_ID = s.AG_ID and c.CU_ID = s.CU_ID)
                inner join GAZETA g on (g.GZ_ID = s.GZ_ID)
                inner join PAY_TYPE pt on (pt.PT_ID = s.PT_ID)
            where
                s.AG_ID = :AGID
                and s.SD_ID = :SDID
                -- not payed:
                and s.SD_STATE <> 100
                and s.SD_STATE > 4
                --and pt.pt_id <> 3 --без оплаты по кредиту
               and pt.pt_id in (2)
                and (s.SD_ALL_PAYED = 0 or s.SD_ALL_PAYED is null)
                and s.AS_ID <> 2
            into
                :AG_NAME
                ,:CU_NAME
                ,:CU_OKPO
                ,:PT_NAME
                ,:SD_FACT_NUM
                ,:SD_FACT_DATE
                ,:GZ_NAME_SHORT
                ,:SD_SUM
                ,:SD_SUM_PAYED
                ,:SD_SUM_PART;

            if (AG_NAME is not null) then
            begin
                select spd.PODACHA_NUMS
                from SDELKA_PODACHA_NUMS_DATES(:AGID, :SDID, :DATE_FROM, :DATE_TO) spd
                into :PODACHA_NUMS_INSIDE;

                if (sd_sum is not null) then
                 begin
                   sum_total_v = sum_total_v + sd_sum;
                   sum_total_out = sum_total_v;
                 end

                if (sd_sum_part is not null) then
                 begin
                   sum_part_v = sum_part_v  + sd_sum_part;
                   sum_part_out = sum_part_v;
                 end

                if (sd_sum_payed is not null) then
                  begin
                   sum_payed_v = sum_payed_v + sd_sum_payed;
                   sum_payed_out = sum_payed_v;
                  end

                suspend;
            end
            AG_NAME = null;
        end
    end
end^


ALTER PROCEDURE REPORT_RESUME_WEEK_BY_CLIENT (
    INPUT_US_ID INTEGER,
    DATE_BEGIN TIMESTAMP,
    DATE_END TIMESTAMP)
RETURNS (
    OUT_NAME VARCHAR(128),
    OUT_CUST_NEW INTEGER,
    OUT_CUST_OLD INTEGER,
    OUT_CUST_NEW_SDELKA_COUNT INTEGER,
    OUT_CUST_NEW_SDELKA_SUM FLOAT,
    OUT_CUST_OLD_SDELKA_COUNT INTEGER,
    OUT_CUST_OLD_SDELKA_SUM FLOAT)
AS
declare variable SUM_BY_OUT_CUST_NEW integer;
declare variable P_AG_ID integer;
begin
  
  sum_by_out_cust_new = 0;

  --  for
    /*
    select ur.ag_id
    from usr_rights ur left join usr u on (ur.us_id = u.us_id)
    where u.us_type = 2     --(менеджер)
        and (usr.us_id = :input_ag_id)
    order by ur.ag_id
    into
        :p_ag_id*/
  --  do
  --  begin

  for
    select
        ag.ag_name as "Агент",
        cb.CUST_NEW as "Новых клиентов",
        cb.CUST_OLD as "Старых клиентов",
        cb.CUST_NEW_SDELKA_COUNT as "Сделок с новыми к-ми",
        cb.CUST_NEW_SDELKA_SUM as "Сумма по новым",
        cb.CUST_OLD_SDELKA_COUNT as "Сделок со старыми к-ми",
        cb.CUST_OLD_SDELKA_SUM as "Сумма по старым"
    from cust_by_date(:input_us_id, :date_begin, :date_end) cb left join agent ag on (cb.ag_id = ag.ag_id)

 --   order by ag.ag_id

    into
        :out_name,
        :out_cust_new ,
        :out_cust_old ,
        :out_cust_new_sdelka_count ,
        :out_cust_new_sdelka_sum ,
        :out_cust_old_sdelka_count ,
        :out_cust_old_sdelka_sum
   do
    begin

        sum_by_out_cust_new = sum_by_out_cust_new + out_cust_new;

    suspend;
   end
 --  out_sum_by_out_cust_new = sum_by_out_cust_new;

/*created by Sandy*/
end^


ALTER PROCEDURE SD_IS_CURRENT_ISSUE (
    AG_ID INTEGER,
    SD_ID INTEGER)
RETURNS (
    RESULT INTEGER)
AS
declare variable IS_ID integer;
declare variable GZ_ID integer;
begin
  /* Procedure Text */
  SELECT s.gz_id FROM sdelka s WHERE s.ag_id = :ag_id AND s.sd_id = :sd_id INTO :gz_id;

  IF(gz_id = 1) THEN
          select pm.pm_current_issue_pr from PARAMS pm INTO :is_id;
  ELSE IF(gz_id = 2) THEN
          select pm.pm_current_issue_ns from PARAMS pm INTO :is_id;
  ELSE IF(gz_id = 3) THEN
         select pm.pm_current_issue_sr from PARAMS pm INTO :is_id;
  ELSE IF(gz_id = 4) THEN
        select pm.pm_current_issue_rz from PARAMS pm INTO :is_id;
  ELSE IF (gz_id = 5) THEN
        select pm.pm_current_issue_rk from PARAMS pm INTO :is_id;
  ELSE EXIT;

  SELECT COUNT(*)
  FROM podacha p
  WHERE p.ag_id = :ag_id AND
        p.sd_id = :sd_id AND
        p.is_id = :is_id
  INTO :result;

  suspend;
end^


ALTER PROCEDURE SDELKA_COUNT_DUPLICATE_SUM (
    P_AG_ID INTEGER,
    P_SD_ID INTEGER,
    P_GZ_ID_SOURCE INTEGER,
    P_GZ_ID_DUPLICATE INTEGER)
RETURNS (
    SUM_DUPLICATE FLOAT)
AS
DECLARE VARIABLE CNT INTEGER;
begin
    select max(s.SUM_DUPLICATE)
    from SDELKA_DUPLICATE_SUM s
    where s.GZ_ID_SOURCE = :P_GZ_ID_SOURCE
          and s.GZ_ID_DUPLICATE = :P_GZ_ID_DUPLICATE
          and s.SUM_SOURCE = (
              select sd.SD_SUM
              from SDELKA sd
              where sd.AG_ID = :P_AG_ID
                    and sd.SD_ID = :P_SD_ID
          )
    into :SUM_DUPLICATE;

    if (SUM_DUPLICATE is null)  then
        SUM_DUPLICATE = 0;

    suspend;
end^


ALTER PROCEDURE SDELKA_COUNT_SUMMARY (
    DATE_FROM TIMESTAMP,
    DATE_TO TIMESTAMP,
    US_ID INTEGER,
    REP_MODE INTEGER)
RETURNS (
    AG_ID INTEGER,
    SD_COUNT INTEGER,
    NAL_SUM FLOAT,
    BEZNAL_SUM FLOAT,
    KREDIT_SUM FLOAT,
    KASA_SUM FLOAT,
    BARTER_COUNT INTEGER,
    KA_COUNT INTEGER,
    KA_SUM FLOAT,
    INET_COUNT INTEGER,
    INET_SUM FLOAT,
    OTHER_CITY_COUNT INTEGER,
    OTHER_CITY_SUM FLOAT,
    NEW_CUST_COUNT INTEGER,
    PAYED_BEZNAL FLOAT,
    PAYED_CREDIT FLOAT,
    PAYED_OTHER_CITY_COUNT INTEGER,
    PAYED_OTHER_CITY_SUM FLOAT,
    PAYED_BEZNAL_V_NAL FLOAT,
    PAYED_KASA FLOAT,
    BEZNAL_V_NAL_SUM FLOAT,
    OBJAV_TEXT_COUNT INTEGER,
    OBJAV_MODULE_COUNT INTEGER,
    OBJAV_VIP_COUNT INTEGER,
    AVG_SDELKA_COST FLOAT,
    AVG_PODACHA_COST FLOAT,
    AVG_VAC_COST FLOAT,
    TTL_VAC_COUNT INTEGER,
    TTL_OBJAV_COST FLOAT,
    INET_PAYED_SUM FLOAT,
    REG_COUNT INTEGER,
    REG_SUM FLOAT,
    REG_PAYED_SUM FLOAT)
AS
declare variable PTID integer;
declare variable SDSUM float;
declare variable SDTYPE integer;
declare variable NEWCUST integer;
declare variable MAXFMID integer;
declare variable HASPICTURE integer;
declare variable PDCOUNT integer;
declare variable SDID integer;
declare variable ALLPAYED integer;
declare variable SUMPAYED float;
declare variable SD_VACCOUNT integer;
BEGIN
    FOR
        select ag.AG_ID
        from AGENT ag
        where ag.AG_ID in (
            select ur.AG_ID
            from USR_RIGHTS ur
            where ur.US_ID = :US_ID
        )
        INTO :AG_ID
    DO
    BEGIN
        SD_COUNT           = 0;
        NAL_SUM            = 0;
        BEZNAL_SUM         = 0;
        KREDIT_SUM         = 0;
        KASA_SUM           = 0;
        BEZNAL_V_NAL_SUM   = 0;
        BARTER_COUNT       = 0;
        KA_COUNT           = 0;
        KA_SUM             = 0;
        INET_COUNT         = 0;
        INET_SUM           = 0;
        OTHER_CITY_COUNT   = 0;
        OTHER_CITY_SUM     = 0;
        NEW_CUST_COUNT     = 0;
        OBJAV_TEXT_COUNT   = 0;
        OBJAV_MODULE_COUNT = 0;
        OBJAV_VIP_COUNT    = 0;
        AVG_SDELKA_COST    = 0;
        AVG_PODACHA_COST   = 0;
        AVG_VAC_COST       = 0;
        TTL_VAC_COUNT      = 0;
        TTL_OBJAV_COST     = 0;
        REG_COUNT          = 0;
        REG_SUM            = 0;
        FOR
            SELECT
                  SDR.SD_ID
                , SDR.PT_ID
                , SDR.SD_SUM
                , SDR.SD_TYPE
                , SDR.SD_NEW_CUST
                , MF.FM_ID
                , FM.FM_HAS_PICTURE
            FROM
                SDELKA_REAL SDR
                LEFT JOIN GET_MAX_FORMAT_AND_RUBRIKA(SDR.AG_ID, SDR.SD_ID) MF ON (1=1)
                LEFT JOIN FORMAT FM ON (FM.FM_ID = MF.FM_ID)
            WHERE     SDR.AG_ID=:AG_ID
                  AND SDR.SD_APPROVED_DATE >= :DATE_FROM
                  AND SDR.SD_APPROVED_DATE < :DATE_TO + 1
                  AND (
                      (:REP_MODE = 0)
                      OR (
                          :REP_MODE = 1
        AND SDR.GZ_ID <> 3
          )
       OR (
           :REP_MODE = 2
        AND SDR.GZ_ID = 3
          )
       OR (
           :REP_MODE = 3
        AND SDR.SD_TYPE <> 5
       )
       OR (
           :REP_MODE = 5
        AND SDR.SD_TYPE = 6
       )
       OR (
           :REP_MODE = 6
        AND SDR.SD_TYPE in (4,6)
       )
       OR (
           :REP_MODE = 7
        AND SDR.SD_TYPE <> 4
       )
       OR (
           :REP_MODE = 8
        AND SDR.GZ_ID = 4
       )
       OR (
           :REP_MODE = 9
        AND SDR.GZ_ID <> 4
       )
       OR (
           :REP_MODE = 10
        AND SDR.SD_TYPE = 1
        AND SDR.GZ_ID = 1
       )
       --only RDG + RVK (listovki)
       OR (
           :REP_MODE = 11
        AND (
             SDR.GZ_ID = 4
          OR SDR.GZ_ID = 5
            )
       )
       --only RvK
       OR (
           :REP_MODE = 12
        AND SDR.GZ_ID = 5
       )
       --all of newspapers with the exception of RvK
       OR (
           :REP_MODE = 13
        AND SDR.GZ_ID <> 5
       )
       -- PR + ST
       OR (
           :REP_MODE = 14
        AND (
             SDR.GZ_ID = 1
          OR SDR.GZ_ID = 3
        )
       )
       OR (
           :REP_MODE = 15
        AND SDR.GZ_ID = 5
          -- all exception special offer 
        and FM.FM_ID not in (82,83,84,85,86,87,88,89,90,91,92,93)
       )
       --only NS = RvK -- for special offer
       OR (
           :REP_MODE = 16
        AND SDR.GZ_ID = 5
       and (FM.FM_ID in (82,83,84,85,86,87,88,89,90,91,92,93) or FM.FM_ID is null)
       )
       --only POptp
       OR (
           :REP_MODE = 17
        AND SDR.GZ_ID = 2
       )
       --all of newspapers with the exception of RvK & POptp
       OR (
           :REP_MODE = 18
        AND SDR.GZ_ID <> 5
        AND SDR.GZ_ID <> 2
       )
      )
            INTO :SDID, :PTID, :SDSUM, :SDTYPE, :NEWCUST, :MAXFMID, :HASPICTURE
        DO
        BEGIN
            SD_COUNT = SD_COUNT + 1;
            SELECT COUNT(1)
            FROM PODACHA P
            WHERE     P.AG_ID = :AG_ID
                  AND P.SD_ID = :SDID
            INTO :PDCOUNT;
            IF (PTID = 1) THEN
                NAL_SUM = NAL_SUM + SDSUM;
            IF (PTID = 2) THEN
               BEZNAL_SUM = BEZNAL_SUM + SDSUM;
            IF (PTID = 3) THEN
               KREDIT_SUM = KREDIT_SUM + SDSUM;
            IF (PTID = 4) THEN
               BARTER_COUNT = BARTER_COUNT + 1;
            IF (PTID = 5) THEN
               BEZNAL_V_NAL_SUM = BEZNAL_V_NAL_SUM + SDSUM;
            IF (PTID = 6) THEN
               KASA_SUM = KASA_SUM + SDSUM;
            IF (SDTYPE = 3) THEN
            BEGIN
                KA_COUNT = KA_COUNT + 1;
                KA_SUM = KA_SUM + SDSUM;
            END
            IF (SDTYPE = 4) THEN
            BEGIN
                INET_COUNT = INET_COUNT + 1;
                INET_SUM = INET_SUM + SDSUM;
            END
            IF (SDTYPE = 5) THEN
            BEGIN
                OTHER_CITY_COUNT = OTHER_CITY_COUNT + 1;
                OTHER_CITY_SUM = OTHER_CITY_SUM + SDSUM;
            END
            IF (SDTYPE = 6) THEN
            BEGIN
                REG_COUNT = REG_COUNT + 1;
                REG_SUM = REG_SUM + SDSUM;
            END
            /* ????????? ?????? ?? ? ?? ??? ????????, ?????
               ????? ???????????? ??? ?????? ??? ????????
               "??????? ????????? ????????" */
            IF (NOT SDTYPE IN (3, 4, 5)) THEN
                TTL_OBJAV_COST = TTL_OBJAV_COST + SDSUM;
            IF (NEWCUST = 1) THEN
                NEW_CUST_COUNT = NEW_CUST_COUNT + 1;
            IF (HASPICTURE = 0) THEN
                OBJAV_TEXT_COUNT = OBJAV_TEXT_COUNT + 1;
            ELSE IF (HASPICTURE = 1) THEN
                OBJAV_MODULE_COUNT = OBJAV_MODULE_COUNT + 1;
            IF (MAXFMID = 15) THEN
                OBJAV_VIP_COUNT = OBJAV_VIP_COUNT + 1;
            IF (PDCOUNT = 0) THEN
                PDCOUNT = 1;
            AVG_SDELKA_COST = AVG_SDELKA_COST + SDSUM;
            AVG_PODACHA_COST = AVG_PODACHA_COST + SDSUM / PDCOUNT;

            SELECT SUM(OB_VAC_COUNT)
            FROM OBJAV O
            WHERE     O.AG_ID = :AG_ID
                  AND O.SD_ID = :SDID
                  AND O.OB_IS_ACTIVE = 1
                  AND O.OB_PARENT IS NULL
            INTO :SD_VACCOUNT;

            IF (SD_VACCOUNT IS NULL) THEN
                SD_VACCOUNT = 0;
            TTL_VAC_COUNT = TTL_VAC_COUNT + SD_VACCOUNT * PDCOUNT;
            SELECT SUM(C.VAC_COUNT)
            FROM
                GET_CURRENT_PODACHA(:AG_ID, :SDID) P
                LEFT JOIN OBJAVLENIE O ON (O.PD_ID = P.PD_ID)
                LEFT JOIN OBJAV_CONTENT C ON (C.CONTENT_ID = O.CONTENT_ID)
            INTO :SD_VACCOUNT;
            IF (SD_VACCOUNT IS NOT NULL) THEN
                TTL_VAC_COUNT = TTL_VAC_COUNT + SD_VACCOUNT * PDCOUNT;
        END
        IF (SD_COUNT > 0) THEN
        BEGIN
            AVG_SDELKA_COST = AVG_SDELKA_COST / SD_COUNT;
            AVG_PODACHA_COST = AVG_PODACHA_COST / SD_COUNT;
        END
        ELSE
        BEGIN
            AVG_SDELKA_COST = 0;
            AVG_PODACHA_COST = 0;
            AVG_VAC_COST = 0;
        END
        IF (TTL_VAC_COUNT > 0) THEN
            AVG_VAC_COST = TTL_OBJAV_COST / TTL_VAC_COUNT;
        ELSE
            AVG_VAC_COST = 0;

        PAYED_BEZNAL           = 0;
        PAYED_CREDIT           = 0;
        PAYED_KASA             = 0;
        PAYED_BEZNAL_V_NAL     = 0;
        PAYED_OTHER_CITY_COUNT = 0;
        PAYED_OTHER_CITY_SUM   = 0;
        INET_PAYED_SUM         = 0;
        REG_PAYED_SUM          = 0;

        FOR
            SELECT
                  SDR.PT_ID
                , SDR.SD_ALL_PAYED
                , SDR.SD_SUM_PAYED
                , SDR.SD_TYPE
            FROM
                SDELKA_REAL SDR
                LEFT JOIN GET_MAX_FORMAT_AND_RUBRIKA(SDR.AG_ID, SDR.SD_ID) MF ON (1=1)
                LEFT JOIN FORMAT FM ON (FM.FM_ID = MF.FM_ID)
            WHERE
                SDR.AG_ID=:AG_ID AND
                SDR.SD_PAY_DATE >= :DATE_FROM AND
                SDR.SD_PAY_DATE < :DATE_TO + 1
                  AND (
                      (:REP_MODE = 0)
                      OR (
                          :REP_MODE = 1
        AND SDR.GZ_ID <> 3
          )
       OR (
           :REP_MODE = 2
        AND SDR.GZ_ID = 3
          )
       OR (
           :REP_MODE = 3
        AND SDR.SD_TYPE <> 5
       )

       OR (
           :REP_MODE = 4
        AND SDR.SD_TYPE = 5
       )
       OR (
           :REP_MODE = 5
        AND SDR.SD_TYPE = 6
       )
       OR (
           :REP_MODE = 6
        AND SDR.SD_TYPE in (4,6)
       )
       OR (
           :REP_MODE = 7
        AND SDR.SD_TYPE <> 4
       )
       OR (
           :REP_MODE = 8
        AND SDR.GZ_ID = 4
       )
       OR (
           :REP_MODE = 9
        AND SDR.GZ_ID <> 4
       )
       OR (
           :REP_MODE = 10
        AND SDR.SD_TYPE = 1
        AND SDR.GZ_ID = 1
       )
       --only RDG + RVK (listovki)
       OR (
           :REP_MODE = 11
        AND (
             SDR.GZ_ID = 4
          OR SDR.GZ_ID = 5
            )
       )
       --only RvK
       OR (
           :REP_MODE = 12
        AND SDR.GZ_ID = 5
       )
       OR (
           :REP_MODE = 13
        AND SDR.GZ_ID <> 5
       )
       OR (
           :REP_MODE = 14
        AND (
             SDR.GZ_ID = 1
          OR SDR.GZ_ID = 3
        )
       )

       OR (
           :REP_MODE = 15
        AND SDR.GZ_ID = 5
          -- all exception special offer 
        and FM.FM_ID not in (82,83,84,85,86,87,88,89,90,91,92,93)
       )
       --only NS = RvK -- for special offer
       OR (
           :REP_MODE = 16
        AND SDR.GZ_ID = 5
        and (FM.FM_ID in (82,83,84,85,86,87,88,89,90,91,92,93) or FM.FM_ID is null)
       )
       OR (
           :REP_MODE = 17
        AND SDR.GZ_ID = 2
       )
       OR (
           :REP_MODE = 18
        AND SDR.GZ_ID <> 5
        AND SDR.GZ_ID <> 2
       )
      )
            INTO
                :PTID, :ALLPAYED, :SUMPAYED, :SDTYPE
        DO
        BEGIN
            IF (SUMPAYED IS NULL) THEN SUMPAYED = 0;

            IF (PTID = 2 AND ALLPAYED = 1) THEN
                PAYED_BEZNAL = PAYED_BEZNAL + SUMPAYED;
            IF (PTID = 3 AND ALLPAYED = 1) THEN
                PAYED_CREDIT = PAYED_CREDIT + SUMPAYED;
            IF (PTID = 5) THEN
                PAYED_BEZNAL_V_NAL = PAYED_BEZNAL_V_NAL + SUMPAYED;
            IF (PTID = 6) THEN
                PAYED_KASA = PAYED_KASA + SUMPAYED;
            IF (SDTYPE = 5) THEN
            BEGIN
                PAYED_OTHER_CITY_COUNT = PAYED_OTHER_CITY_COUNT + 1;
                PAYED_OTHER_CITY_SUM = PAYED_OTHER_CITY_SUM + SUMPAYED;
            END

            IF (SDTYPE in (4,6)) THEN
            BEGIN
                INET_PAYED_SUM = INET_PAYED_SUM + SUMPAYED;
                if(sdtype = 6) then REG_PAYED_SUM = REG_PAYED_SUM + SUMPAYED;
            END
        END

        IF(SD_COUNT IS NULL)THEN SD_COUNT = 0;
        IF (NAL_SUM IS NULL)THEN NAL_SUM = 0;
        IF (BEZNAL_SUM IS NULL) THEN  BEZNAL_SUM = 0;
        IF (KREDIT_SUM IS NULL) THEN KREDIT_SUM = 0;
        IF (KASA_SUM IS NULL) THEN KASA_SUM = 0;
        IF (BARTER_COUNT IS NULL) THEN BARTER_COUNT = 0;
        IF (KA_COUNT IS NULL) THEN KA_COUNT = 0;
        IF (KA_SUM IS NULL) THEN KA_SUM = 0;
        IF (INET_COUNT IS NULL) THEN INET_COUNT = 0;
        IF (INET_SUM IS NULL) THEN INET_SUM = 0;
        IF (OTHER_CITY_COUNT IS NULL) THEN OTHER_CITY_COUNT = 0;
        IF (OTHER_CITY_SUM IS NULL) THEN OTHER_CITY_SUM = 0;
        IF (NEW_CUST_COUNT IS NULL) THEN NEW_CUST_COUNT = 0;
        IF (PAYED_BEZNAL IS NULL) THEN PAYED_BEZNAL = 0;
        IF (PAYED_CREDIT IS NULL) THEN PAYED_CREDIT = 0;
        IF (PAYED_OTHER_CITY_COUNT IS NULL) THEN PAYED_OTHER_CITY_COUNT = 0;
        IF (PAYED_OTHER_CITY_SUM IS NULL) THEN PAYED_OTHER_CITY_SUM = 0;
        IF (PAYED_BEZNAL_V_NAL IS NULL) THEN PAYED_BEZNAL_V_NAL = 0;
        IF (PAYED_KASA IS NULL) THEN PAYED_KASA = 0;
        IF (BEZNAL_V_NAL_SUM IS NULL) THEN BEZNAL_V_NAL_SUM = 0;
        IF (OBJAV_TEXT_COUNT IS NULL) THEN OBJAV_TEXT_COUNT = 0;
        IF (OBJAV_MODULE_COUNT IS NULL) THEN OBJAV_MODULE_COUNT = 0;
        IF (OBJAV_VIP_COUNT IS NULL) THEN OBJAV_VIP_COUNT = 0;
        IF (AVG_SDELKA_COST IS NULL) THEN AVG_SDELKA_COST = 0;
        IF (AVG_PODACHA_COST IS NULL) THEN AVG_PODACHA_COST = 0;
        IF (AVG_VAC_COST IS NULL) THEN AVG_VAC_COST = 0;
        IF (TTL_VAC_COUNT IS NULL) THEN TTL_VAC_COUNT = 0;
        IF (TTL_OBJAV_COST IS NULL) THEN TTL_OBJAV_COST = 0;
        IF (REG_COUNT IS NULL) THEN REG_COUNT = 0;
        IF (REG_SUM IS NULL) THEN REG_SUM = 0;

       -- INET_COUNT = INET_COUNT +  REG_COUNT;
       -- INET_SUM = INET_SUM + REG_SUM;
        SUSPEND;
    END
END^


ALTER PROCEDURE SDELKA_DOLJNIKA (
    AG_ID_INPUT INTEGER,
    SD_ID_INPUT INTEGER)
RETURNS (
    AG_ID INTEGER,
    SD_ID INTEGER)
AS
DECLARE VARIABLE CUID INTEGER;
DECLARE VARIABLE PHNUMBER CHAR(16);
DECLARE VARIABLE ALLPAYED SMALLINT;
DECLARE VARIABLE SDSTATE INTEGER;
DECLARE VARIABLE INTV INTEGER;
DECLARE VARIABLE CHR128 VARCHAR(128);
DECLARE VARIABLE CHR12 CHAR(12);
DECLARE VARIABLE CHR64 CHAR(64);
DECLARE VARIABLE CHR10 CHAR(10);
BEGIN
    SELECT SD.CU_ID
    FROM SDELKA SD
    WHERE SD.AG_ID=:AG_ID_INPUT AND SD.SD_ID=:SD_ID_INPUT
    INTO :CUID;

    FOR
        SELECT CP.CP_NUMBER
        FROM CUST_PHONE CP
        WHERE CP.AG_ID=:AG_ID_INPUT AND CP.CU_ID=:CUID
        INTO :PHNUMBER
    DO
    BEGIN
        FOR
            SELECT FSP.AG_ID,FSP.SD_ID
            FROM FIND_SDELKA_BY_PHONE_SIMPLE(:PHNUMBER) FSP
            LEFT JOIN SDELKA SD
            ON (FSP.AG_ID=SD.AG_ID AND FSP.SD_ID=SD.SD_ID)
            WHERE SD.SD_STATE>4 AND (SD.SD_ALL_PAYED=0 OR SD.SD_ALL_PAYED IS NULL)
            INTO :AG_ID,:SD_ID
        DO
        BEGIN
            SUSPEND;
        END
    END

    FOR
        SELECT PH.PH_NUMBER
        FROM PHONE PH
        WHERE PH.AG_ID=:AG_ID AND PH.SD_ID=:SD_ID
        INTO :PHNUMBER
    DO
    BEGIN
        FOR
            SELECT FSP.AG_ID,FSP.SD_ID
            FROM FIND_SDELKA_BY_PHONE_SIMPLE(:PHNUMBER) FSP
            LEFT JOIN SDELKA SD
            ON (FSP.AG_ID=SD.AG_ID AND FSP.SD_ID=SD.SD_ID)
            WHERE SD.SD_STATE>4 AND (SD.SD_ALL_PAYED=0 OR SD.SD_ALL_PAYED IS NULL)
            INTO :AG_ID,:SD_ID
        DO
        BEGIN
            SUSPEND;
        END
    END

END^


ALTER PROCEDURE SDELKA_DUPLICATE (
    P_AG_ID INTEGER,
    P_SD_ID INTEGER,
    P_DUPLICATE_GZ_ID INTEGER)
AS
declare variable DUPLICATE_SD_ID integer;
declare variable DUPLICATE_SD_SUM float;
declare variable SOURCE_GZ_ID integer;
declare variable CNT integer;
declare variable DUPLICATE_AG_ID integer;
declare variable SOURCE_RQ_ID integer;
declare variable SOURCE_CU_ID integer;
declare variable SOURCE_PT_ID integer;
declare variable SOURCE_SD_FACT_NUM integer;
declare variable SOURCE_SD_FACT_DATE date;
declare variable SOURCE_SD_SHOW_CUST_ID smallint;
declare variable CURR_ISSUE integer;
declare variable ISSUES_ADDED integer;
declare variable ISS_COUNT_0 integer;
declare variable ISS_COUNT_NORMAL integer;
declare variable ISS_ID integer;
declare variable ISSUE_0_ID integer;
declare variable CNT_SD integer;
begin
    -- Определяем газету, из которой делаем дубль
    select s.GZ_ID
    from SDELKA s
    where s.AG_ID = :P_AG_ID and s.SD_ID = :P_SD_ID
    into :source_gz_id;

    -- Вычисляем стоимость новой сделки
    execute procedure SDELKA_COUNT_DUPLICATE_SUM(:P_AG_ID, :P_SD_ID, :source_gz_id, :P_DUPLICATE_GZ_ID)
    returning_values :duplicate_sd_sum;

    -- Определяем, есть ли уже дубль для этой сделки
    select count(*)
    from SDELKA_DUPL sdu
    left join SDELKA sd on (sd.AG_ID = sdu.AG_ID and sd.SD_ID = sdu.SD_ID)
    where sdu.DUPL_OF_AG_ID = :P_AG_ID and sdu.DUPL_OF_SD_ID = :P_SD_ID and sd.GZ_ID = :P_DUPLICATE_GZ_ID
    into :cnt;

    -- Установим признак, что сделка в данный момент дублируется
    execute procedure sdelka_duplicating_start(:P_AG_ID, :P_SD_ID);

    -- Если дубля нет, то создаем его
    if (cnt = 0) then
    begin
        duplicate_ag_id = :P_AG_ID;

        -- Сделке-копии дадим номер на 1 больше оригинала
        duplicate_sd_id = P_SD_ID + 1;

        -- Проверим, нету ли уже такой сделки
        select count(*)
        from SDELKA s
        where s.AG_ID = :P_AG_ID and s.SD_ID = :duplicate_sd_id
        into :cnt_sd;

        if (cnt_sd > 0) then
            duplicate_sd_id = gen_id(G_SD_ID, 1);

        insert into SDELKA (
            AG_ID
            ,SD_ID
            ,SD_TYPE
            ,SD_STATE
            ,RQ_ID
            ,CU_ID
            ,AS_ID
            ,SD_COMMENT
            ,SD_SUM
            ,SD_PERCENT
            ,SD_SUM_DEFAULT
            ,SD_PERCENT_DEFAULT
            ,SD_SKIDKA
            ,PT_ID
            ,SD_SETTING_SUM_AND_PERCENT
            ,GZ_ID
            ,SD_SUM_PAYED
            ,SD_ALL_PAYED
            ,SD_COMMENT_SHORT
            ,SD_IS_CHANGED_COPY_OF_SD_ID
            ,SD_PAY_NOW
            ,SD_FACT_NUM
            ,SD_KA_START_DATE
            ,SD_KA_END_DATE
            ,SD_FACT_DATE
            ,SD_DATE
            ,SD_PERCENT_GIVEN
            ,SD_TO_GIVE_PERCENT
            ,SD_APPROVED_DATE
            ,SD_IS_BEZNAL_V_NAL
            ,SD_PAY_DATE
            ,SD_NEW_CUST
            ,SD_SHOW_CUST_ID
            ,SD_IS_IMPORTANT_FOR_SITE
            ,REGISTERED_BY_ID
            ,SD_NUM
        )
        select
            :duplicate_ag_id
            ,:duplicate_sd_id
            ,SD_TYPE
            ,1
            ,RQ_ID
            ,CU_ID
            ,0
            ,'Дубль ' || :P_AG_ID || '-' || :P_SD_ID || '.'
            ,:duplicate_sd_sum
            ,SD_PERCENT
            ,:duplicate_sd_sum
            ,SD_PERCENT_DEFAULT
            ,SD_SKIDKA
            ,PT_ID
            ,1
            ,:P_DUPLICATE_GZ_ID
            ,0
            ,0
            ,SD_COMMENT_SHORT
            ,null
            ,SD_PAY_NOW
            ,SD_FACT_NUM
            ,SD_KA_START_DATE
            ,SD_KA_END_DATE
            ,SD_FACT_DATE
            ,SD_DATE
            ,SD_PERCENT_GIVEN
            ,SD_TO_GIVE_PERCENT
            ,null
            ,SD_IS_BEZNAL_V_NAL
            ,SD_PAY_DATE
            ,SD_NEW_CUST
            ,SD_SHOW_CUST_ID
            ,SD_IS_IMPORTANT_FOR_SITE
            ,REGISTERED_BY_ID
            ,:duplicate_ag_id || '-' || :duplicate_sd_id
        from SDELKA s
        where s.AG_ID = :P_AG_ID and s.SD_ID = :P_SD_ID;

        insert into SDELKA_DUPL (
            AG_ID
            ,SD_ID
            ,DUPL_OF_AG_ID
            ,DUPL_OF_SD_ID
        )
        values (
            :duplicate_ag_id
            ,:duplicate_sd_id
            ,:P_AG_ID
            ,:P_SD_ID
        );
    end
    -- Если дубль есть, то обновляем его
    else if (cnt = 1) then
    begin
        select
            sdd.AG_ID
            ,sdd.SD_ID
            ,sds.RQ_ID
            ,sds.CU_ID
            ,sds.PT_ID
            ,sds.SD_FACT_NUM
            ,sds.SD_FACT_DATE
            ,sds.SD_SHOW_CUST_ID
        from SDELKA_DUPL sdu
        left join SDELKA sdd on (sdd.AG_ID = sdu.AG_ID and sdd.SD_ID = sdu.SD_ID)
        left join SDELKA sds on (sds.AG_ID = sdu.DUPL_OF_AG_ID and sds.SD_ID = sdu.DUPL_OF_SD_ID)
        where sdu.DUPL_OF_AG_ID = :P_AG_ID
              and sdu.DUPL_OF_SD_ID = :P_SD_ID
              and sdd.GZ_ID = :P_DUPLICATE_GZ_ID
        into
            :duplicate_ag_id
            ,:duplicate_sd_id
            ,:source_rq_id
            ,:source_cu_id
            ,:source_pt_id
            ,:source_sd_fact_num
            ,:source_sd_fact_date
            ,:source_sd_show_cust_id;

        update SDELKA s
        set
            s.RQ_ID             = :source_rq_id
            ,s.CU_ID            = :source_cu_id
            ,s.SD_SUM           = :duplicate_sd_sum
            ,s.SD_SUM_DEFAULT   = :duplicate_sd_sum
            ,s.PT_ID            = :source_pt_id
            ,s.SD_FACT_NUM      = :source_sd_fact_num
            ,s.SD_FACT_DATE     = :source_sd_fact_date
            ,s.SD_SHOW_CUST_ID  = :source_sd_show_cust_id
        where
            s.AG_ID = :duplicate_ag_id
            and s.SD_ID = :duplicate_sd_id;

        -- Продублируем подачи

        -- Удалим все подачи, которые есть
        delete from PODACHA p
        where p.AG_ID = :duplicate_ag_id
              and p.SD_ID = :duplicate_sd_id;

        -- Подсчитаем, сколько должно быть не-запасных подач
        select count(*)
        from PODACHA p
        left join ISSUE i on (i.IS_ID = p.IS_ID)
        where p.AG_ID = :P_AG_ID
              and p.SD_ID = :P_SD_ID
              and i.IS_NAME <> '0'
        into
            :iss_count_normal;

        -- Подсчитаем, сколько должно быть "запасных" подач
        select count(*)
        from PODACHA p
        left join ISSUE i on (i.IS_ID = p.IS_ID)
        where p.AG_ID = :P_AG_ID
              and p.SD_ID = :P_SD_ID
              and i.IS_NAME = '0'
        into
            :iss_count_0;

        -- Найдем текущий номер - будем добавлять подачи, начиная с него
        execute procedure GET_CURRENT_ISSUE(:P_DUPLICATE_GZ_ID)
        returning_values :curr_issue;

        -- Добавим не-запасные подачи
        issues_added = 0;
        for
            select i.IS_ID
            from ISSUE i
            where i.GZ_ID = :P_DUPLICATE_GZ_ID
                  and i.IS_ID >= :curr_issue
            order by i.IS_DATE
            into
                :iss_id
        do
        begin
            if (:issues_added >= :iss_count_normal) then
                break;
            else
                insert into PODACHA (
                    GZ_ID
                    ,IS_ID
                    ,AG_ID
                    ,SD_ID
                    ,PD_FREE_OF_CHARGE
                    ,PD_ID
                    ,PD_ADDDATE
                    ,PD_IS_DONE
                )
                values (
                    :P_DUPLICATE_GZ_ID
                    ,:iss_id
                    ,:duplicate_ag_id
                    ,:duplicate_sd_id
                    ,0
                    ,gen_id(G_PD_ID, 1)
                    ,current_timestamp
                    ,0
                );

            issues_added = issues_added + 1;
        end

        -- Добавим "запасные" подачи

        -- Определим идентификатор "запасного" номера
        select i.IS_ID
        from ISSUE i
        where i.GZ_ID = :P_DUPLICATE_GZ_ID and i.IS_NAME = '0'
        into :issue_0_id;

        issues_added = 0;
        while (issues_added < iss_count_0)
        do
        begin
            insert into PODACHA (
                GZ_ID
                ,IS_ID
                ,AG_ID
                ,SD_ID
                ,PD_FREE_OF_CHARGE
                ,PD_ID
                ,PD_ADDDATE
                ,PD_IS_DONE
            )
            values (
                :P_DUPLICATE_GZ_ID
                ,:issue_0_id
                ,:duplicate_ag_id
                ,:duplicate_sd_id
                ,0
                ,gen_id(G_PD_ID, 1)
                ,current_timestamp
                ,0
            );

            issues_added = issues_added + 1;
        end
    end

    -- Продублируем объявления
    execute procedure OBJAV_DUPLICATE_ALL(:duplicate_ag_id, :duplicate_sd_id);
    execute procedure OBJAVLENIE_DUPLICATE_ALL(:duplicate_ag_id, :duplicate_sd_id);

    -- Снимем признак, что сделка в данный момент дублируется
    execute procedure sdelka_duplicating_end(:P_AG_ID, :P_SD_ID);
end^


ALTER PROCEDURE SDELKA_DUPLICATING_END (
    P_SOURCE_AG_ID INTEGER,
    P_SOURCE_SD_ID INTEGER)
AS
begin
    update SDELKA_DUPLICATING s
    set s.CALL_COUNT = s.CALL_COUNT - 1
    where s.AG_ID = :p_source_ag_id
          and s.SD_ID = :p_source_sd_id;

    delete from SDELKA_DUPLICATING s
    where s.AG_ID = :p_source_ag_id
          and s.SD_ID = :p_source_sd_id
          and s.CALL_COUNT = 0;
end^


ALTER PROCEDURE SDELKA_DUPLICATING_START (
    P_SOURCE_AG_ID INTEGER,
    P_SOURCE_SD_ID INTEGER)
AS
begin
    if (not exists (
        select 1 from SDELKA_DUPLICATING s
        where s.AG_ID = :p_source_ag_id
              and s.SD_ID = :p_source_sd_id)
    ) then
        insert into SDELKA_DUPLICATING (AG_ID, SD_ID, CALL_COUNT)
        values (:p_source_ag_id, :p_source_sd_id, 1);
    else
        update SDELKA_DUPLICATING s
        set s.CALL_COUNT = s.CALL_COUNT + 1
        where s.AG_ID = :p_source_ag_id
              and s.SD_ID = :p_source_sd_id;
end^


ALTER PROCEDURE SDELKA_FOR_ZARPLATA (
    AG_ID_INPUT INTEGER,
    DATE_FROM TIMESTAMP,
    DATE_TO TIMESTAMP)
RETURNS (
    AG_ID INTEGER,
    SD_ID INTEGER,
    SDZ_SD_PERCENT_SUM FLOAT,
    SD_PERCENT_SUM_TO_GIVE FLOAT,
    PT_ID INTEGER)
AS
BEGIN
    AG_ID=AG_ID_INPUT;
    FOR
        SELECT SDR.SD_ID,SDR.SD_PERCENT_SUM,SD_PERCENT_SUM_TO_GIVE,SDR.PT_ID FROM SDELKA_REAL SDR
        WHERE
            SDR.AG_ID=:AG_ID_INPUT
            AND
            (
                (
                    SDR.PT_ID IN (1,4)
                    AND
                    SDR.SD_STATE>=4
                    AND
                    CAST(SDR.SD_APPROVED_DATE AS DATE)>=:DATE_FROM
                    AND
                    CAST(SDR.SD_APPROVED_DATE AS DATE)<=:DATE_TO
                )
                OR
                (
                    SDR.PT_ID IN (2,3,5)
                    AND
                    SDR.SD_STATE>=4
                    AND
                    SDR.SD_ALL_PAYED=1
                    AND
                    CAST(SDR.SD_PAY_DATE AS DATE)>=:DATE_FROM
                    AND
                    CAST(SDR.SD_PAY_DATE AS DATE)<=:DATE_TO
                )
            )
        INTO :SD_ID,:SDZ_SD_PERCENT_SUM,:SD_PERCENT_SUM_TO_GIVE,:PT_ID
    DO
        SUSPEND;
END^


ALTER PROCEDURE SDELKA_IS_DOLJNIKA (
    AG_ID_INPUT INTEGER,
    SD_ID_INPUT INTEGER)
RETURNS (
    RESULT INTEGER)
AS
DECLARE VARIABLE CNT INTEGER;
begin

    RESULT = 0;

    for
        select
            1
        from
            SDELKA sd

            left join CUST_PHONE cp on (cp.AG_ID = sd.AG_ID and cp.CU_ID = sd.CU_ID)

            left join PHONE ph on (ph.AG_ID = sd.AG_ID and ph.SD_ID = sd.SD_ID)

            left join CUST_PHONE cp2 on (cp2.CP_NUMBER = cp.CP_NUMBER or cp2.CP_NUMBER = ph.PH_NUMBER)

            left join PHONE ph2 on (ph2.PH_NUMBER = cp.CP_NUMBER or (ph2.PH_NUMBER = ph.PH_NUMBER and not (ph2.AG_ID = sd.AG_ID and ph2.SD_ID = ph.SD_ID)))

            left join NOT_PAYED_SDELKA np on ((np.AG_ID = cp2.AG_ID and np.CU_ID = cp2.CU_ID) or (np.AG_ID = ph2.AG_ID and np.SD_ID = ph2.SD_ID))
        where
            sd.AG_ID = :AG_ID_INPUT
            and sd.SD_ID = :SD_ID_INPUT
            and np.AG_ID is not null
        into
            :CNT
    do
    begin
        RESULT = 1;

        suspend;

        exit;
    end

    suspend;
end^


ALTER PROCEDURE SDELKA_PHONES (
    AG_ID INTEGER,
    SD_ID INTEGER)
RETURNS (
    PH_NUMBER CHAR(16))
AS
DECLARE VARIABLE CUID INTEGER;
BEGIN
    SELECT SD.CU_ID
    FROM SDELKA SD
    WHERE SD.AG_ID=:AG_ID AND SD.SD_ID=:SD_ID
    INTO :CUID;
    
    FOR
        SELECT PH.PH_NUMBER
        FROM PHONE PH
        WHERE PH.AG_ID=:AG_ID AND PH.SD_ID=:SD_ID
            UNION
        SELECT CP.CP_NUMBER
        FROM
        CUST_PHONE CP
        WHERE CP.AG_ID=:AG_ID AND CP.CU_ID=:CUID
        INTO :PH_NUMBER
    DO
        SUSPEND;
END^


ALTER PROCEDURE SDELKA_PODACHA_NUMS (
    AG_ID_INPUT INTEGER,
    SD_ID_INPUT INTEGER)
RETURNS (
    SD_ID INTEGER,
    PODACHA_NUMS VARCHAR(128))
AS
declare variable ISFREE integer;
declare variable ISNAME varchar(10);
declare variable ISDATE timestamp;
declare variable PODACHA_CNT integer;
declare variable PODACHA_NUMS_LONG varchar(250);
BEGIN
    SD_ID = SD_ID_INPUT;
 
    PODACHA_NUMS_LONG = '';

    PODACHA_CNT = 0;
 
    FOR
/*$$IBEC$$         SELECT PD.PD_FREE_OF_CHARGE, ISS.IS_NAME, ISS.IS_DATE
        FROM PODACHA PD
        LEFT JOIN ISSUE ISS
        ON (PD.IS_ID=ISS.IS_ID AND PD.GZ_ID=ISS.GZ_ID)
        WHERE PD.AG_ID=:AG_ID_INPUT AND PD.SD_ID=:SD_ID_INPUT
        ORDER BY PD.IS_ID $$IBEC$$*/

        SELECT p.PD_FREE_OF_CHARGE, i.IS_NAME, i.IS_DATE
        FROM issue i
        JOIN podacha p ON (p.IS_ID = i.IS_ID)
        WHERE p.AG_ID = :AG_ID_INPUT AND p.SD_ID = :SD_ID_INPUT
        ORDER BY i.IS_ID
        INTO :ISFREE, :ISNAME, :ISDATE
    DO
    BEGIN
        if (PODACHA_CNT <= 16) then
        begin
          if (PODACHA_CNT > 0) then
              PODACHA_NUMS_LONG = PODACHA_NUMS_LONG || ', ';
          if (ISFREE = 1) then
              PODACHA_NUMS_LONG = PODACHA_NUMS_LONG || '(' || ISNAME || ')';
          else
              PODACHA_NUMS_LONG = PODACHA_NUMS_LONG || ISNAME;
        end
 
        PODACHA_CNT = PODACHA_CNT + 1;
    END
 

    if (PODACHA_CNT > 16) then
    begin
            PODACHA_NUMS_LONG = '(' || PODACHA_CNT || ' подач) ' || PODACHA_NUMS_LONG || '...,' || ISNAME;
    end
 
    if (PODACHA_CNT > 0) then
       PODACHA_NUMS_LONG = PODACHA_NUMS_LONG || '/' || EXTRACT(YEAR FROM ISDATE);

    PODACHA_NUMS = LEFT(PODACHA_NUMS_LONG, 128);
 
  SUSPEND;
END^


ALTER PROCEDURE SDELKA_PODACHA_NUMS_DATES (
    AG_ID INTEGER,
    SD_ID INTEGER,
    DATE_FROM TIMESTAMP,
    DATE_TO TIMESTAMP)
RETURNS (
    PODACHA_NUMS VARCHAR(255))
AS
declare variable PODACHA_CNT integer;
declare variable ISFREE integer;
declare variable ISNAME varchar(10);
declare variable ISDATE timestamp;
declare variable STARTHIGHLIGHT varchar(10);
declare variable ENDHIGHLIGHT varchar(10);
BEGIN
    PODACHA_NUMS = '';

    PODACHA_CNT = 0;

--    isPrevInDates = 0;
 
    FOR
        SELECT PD.PD_FREE_OF_CHARGE, ISS.IS_NAME, ISS.IS_DATE
        FROM PODACHA PD
        LEFT JOIN ISSUE ISS
        ON (PD.IS_ID=ISS.IS_ID AND PD.GZ_ID=ISS.GZ_ID)
        WHERE PD.AG_ID=:AG_ID AND PD.SD_ID=:SD_ID
        ORDER BY PD.IS_ID
        INTO :ISFREE, :ISNAME, :ISDATE
    DO
    BEGIN
        if (char_length(PODACHA_NUMS) <= 210) then
        begin
          if (ISDATE >= :DATE_FROM AND ISDATE <= :DATE_TO) then
          begin
            startHighlight = '<b><u>';
            endHighlight = '</u></b>';
          end
          else
          begin
            startHighlight = '';
            endHighlight = '';
          end

          if (PODACHA_CNT > 0) then
              PODACHA_NUMS = PODACHA_NUMS || ', ';
          if (ISFREE = 1) then
              PODACHA_NUMS = PODACHA_NUMS || '(' || startHighlight || ISNAME || endHighlight || ')';
          else
              PODACHA_NUMS = PODACHA_NUMS || startHighlight || ISNAME || endHighlight;
        end
 
        PODACHA_CNT = PODACHA_CNT + 1;
    END
 

    if (char_length(PODACHA_NUMS) > 210) then
    begin
            PODACHA_NUMS = '(' || PODACHA_CNT || ' подач) ' || PODACHA_NUMS || '...,' || ISNAME;
    end
 
  SUSPEND;
END^


ALTER PROCEDURE SDELKA_PODACHA_NUMS_DATES_1C (
    AG_ID INTEGER,
    SD_ID INTEGER,
    DATE_FROM TIMESTAMP,
    DATE_TO TIMESTAMP)
RETURNS (
    PODACHA_NUMS VARCHAR(255))
AS
declare variable PODACHA_CNT integer;
declare variable ISFREE integer;
declare variable ISNAME varchar(10);
declare variable ISDATE date;
declare variable STARTHIGHLIGHT varchar(10);
declare variable ENDHIGHLIGHT varchar(10);
BEGIN
    PODACHA_NUMS = '';
    PODACHA_CNT = 0;

    FOR
        SELECT PD.PD_FREE_OF_CHARGE, ISS.IS_NAME, cast(ISS.IS_DATE as date)
        FROM PODACHA PD
        LEFT JOIN ISSUE ISS
        ON (PD.IS_ID=ISS.IS_ID AND PD.GZ_ID=ISS.GZ_ID)
        WHERE PD.AG_ID=:AG_ID AND PD.SD_ID=:SD_ID
        ORDER BY PD.IS_ID
        INTO :ISFREE, :ISNAME, :ISDATE
    DO
    BEGIN
        if (CHAR_LENGTH(PODACHA_NUMS) <= 210) then
        begin
        --  if (ISDATE >= :DATE_FROM AND ISDATE <= :DATE_TO) then
         --  begin
             if (PODACHA_CNT > 0) then
               PODACHA_NUMS = PODACHA_NUMS || ', '|| ISNAME || ' (' || ISDATE || ')';
             else
              begin
                PODACHA_NUMS = PODACHA_NUMS || ISNAME || ' (' || ISDATE || ')';
                PODACHA_CNT = PODACHA_CNT + 1;
              end
          -- end
         end
 

    END
 
  IF ((PODACHA_NUMS IS NULL) OR (PODACHA_NUMS = '')) THEN PODACHA_NUMS = '0 (2000-01-01)';
  SUSPEND;
END^


ALTER PROCEDURE SDELKA_WAS_DELETED_LOG (
    P_US_ID INTEGER,
    P_AG_ID INTEGER,
    P_SD_ID INTEGER,
    P_IP CHAR(15))
AS
BEGIN

    INSERT INTO sdelka_was_deleted
        SELECT s.*,
               CURRENT_TIMESTAMP as SD_DELETE_DATE,
               :p_us_id,
               :p_AG_ID,
               :p_sd_id,
               :p_ip
        FROM SDELKA s
        WHERE s.ag_id=:p_AG_ID AND s.sd_id=:p_SD_ID;

END^


ALTER PROCEDURE SET_RESET_SUM_AND_PERCENT (
    AG_ID INTEGER,
    SD_ID INTEGER,
    RESET SMALLINT)
AS
declare variable SMD float;
declare variable PCD float;
declare variable SM float;
declare variable PC float;
declare variable SSP smallint;
BEGIN
  EXECUTE PROCEDURE COUNT_SUM_NEW(:AG_ID,:SD_ID)
  RETURNING_VALUES :SMD;
/*  EXECUTE PROCEDURE COUNT_PERCENT(:AG_ID,:SD_ID)
  RETURNING_VALUES :PCD;
*/
  PCD = 0;

  SELECT SD_SUM,SD_PERCENT
  FROM SDELKA
  WHERE AG_ID=:AG_ID AND
        SD_ID=:SD_ID
  INTO :SM,:PC;

  if (SM IS NULL or RESET = 1) then
    SM=SMD;
  if (PC IS NULL or RESET = 1) then
    PC=PCD;

  UPDATE SDELKA
  SET SD_SUM=:SM,
      SD_PERCENT=:PC,
      SD_SUM_DEFAULT=:SMD,
      SD_PERCENT_DEFAULT=:PCD
  WHERE AG_ID=:AG_ID AND
        SD_ID=:SD_ID;
  SUSPEND;
END^


ALTER PROCEDURE SET_SUM_AND_PERCENT (
    AG_ID INTEGER,
    SD_ID INTEGER)
AS
declare variable SMD float;
declare variable PCD float;
declare variable SM float;
declare variable PC float;
declare variable SSP smallint;
BEGIN
  EXECUTE PROCEDURE COUNT_SUM_NEW(:AG_ID,:SD_ID)
  RETURNING_VALUES :SMD;
/*  EXECUTE PROCEDURE COUNT_PERCENT(:AG_ID,:SD_ID)
  RETURNING_VALUES :PCD;*/
  PCD = 0;
  SELECT SD_SUM,SD_PERCENT,SD_SETTING_SUM_AND_PERCENT
  FROM SDELKA
  WHERE AG_ID=:AG_ID AND
        SD_ID=:SD_ID
  INTO :SM,:PC,:SSP;
  if (SSP=0) then
    SSP=1;
  ELSE
    SSP=0;
  if (SM IS NULL) then
    SM=SMD;
  if (PC IS NULL) then
    PC=PCD;
  UPDATE SDELKA
  SET SD_SUM=:SM,
      SD_PERCENT=:PC,
      SD_SUM_DEFAULT=:SMD,
      SD_PERCENT_DEFAULT=:PCD,
      SD_SETTING_SUM_AND_PERCENT=:SSP
  WHERE AG_ID=:AG_ID AND
        SD_ID=:SD_ID;
  SUSPEND;
END^


ALTER PROCEDURE SITE_OBJAV_COPY (
    SITE_OBJAV_ID INTEGER)
RETURNS (
    NEW_SITE_OBJAV_ID INTEGER)
AS
BEGIN
  NEW_SITE_OBJAV_ID = GEN_ID(G_SITE_OBJAV, 1);

  INSERT INTO SITE_OBJAV (
    SITE_OBJAV_ID
    , RS_ID
    , SITE_OBJAV_TEXT
  )
  SELECT
      :NEW_SITE_OBJAV_ID
    , SO.RS_ID
    , SO.SITE_OBJAV_TEXT
  FROM
    SITE_OBJAV SO
  WHERE
    SO.SITE_OBJAV_ID = :SITE_OBJAV_ID;

  SUSPEND;
END^


ALTER PROCEDURE TRANSFE_SDELKA (
    DATE_FROM TIMESTAMP,
    DATE_TO TIMESTAMP)
RETURNS (
    SD_FACT_NUM INTEGER,
    SD_FACT_DATE TIMESTAMP,
    SERV_ID SMALLINT,
    PODACHA_NUMS_INSIDE1 VARCHAR(255),
    SD_SUM FLOAT,
    SD_SUM_PAYED FLOAT,
    CU_OKPO CHAR(10),
    CU_NAME VARCHAR(128),
    COMPANY_OKPO VARCHAR(10),
    ISPAID SMALLINT,
    SD_ID INTEGER,
    AG_ID INTEGER)
AS
declare variable AGID integer;
declare variable SDID integer;
declare variable SD_TYPE integer;
declare variable GZID smallint;
declare variable AG_NAME varchar(128);
declare variable ALL_PAID integer;
declare variable RQ_ID integer;
begin
   /*
     select p.pm_app_instance_no
     from params p
     into :instanceid;
   */
    for
        select distinct
                 s.rq_id
                ,s.sd_id
                ,a.ag_id
                ,a.AG_NAME
                ,c.CU_NAME
                ,c.CU_OKPO
                ,s.SD_FACT_NUM
                ,s.SD_FACT_DATE
                ,g.gz_id
                ,s.sd_type
                ,s.SD_SUM
                ,s.SD_SUM_PAYED
                ,s.sd_all_payed
       from
                SDELKA s
                left join AGENT a on (a.AG_ID = s.AG_ID)
                left join CUST c on (c.AG_ID = s.AG_ID and c.CU_ID = s.CU_ID)
                left join GAZETA g on (g.GZ_ID = s.GZ_ID)
                left join PAY_TYPE pt on (pt.PT_ID = s.PT_ID)
       where
                -- didn't delete,
                s.SD_STATE <> 100
                --  old and closed
                and ((s.SD_STATE >= 4 and s.pt_id in (2,6) and s.AS_ID = 0) or (s.sd_all_payed = 1))
                and s.sd_fact_date between :DATE_FROM and :date_to
                and s.SD_IS_CHANGED_COPY_OF_SD_ID is null
              --  AND s.SD_NUM in ('54-701365', '54-701368')

       into
                 :rq_id
                ,:sdid
                ,:agid
                ,:AG_NAME
                ,:CU_NAME
                ,:CU_OKPO
                ,:SD_FACT_NUM
                ,:SD_FACT_DATE
                ,:GZID
                ,:SD_TYPE
                ,:SD_SUM
                ,:SD_SUM_PAYED
                ,:all_paid
    do
    begin
       sd_id = :sdid;
       ag_id = agid;
             --поумолчанию ТОВ "Робота Плюс"
      -- company_okpo = '33302178';
            --команда Коваленко ПП РА "Успіх Плюс"
      -- if (agid in (34,304,94,309,42,308,4,307,22,305) ) then
      --        company_okpo = '30634380';

                    -- ТОВ "Робота Плюс"
       if(rq_id = 1) then company_okpo = '33302178';
            --команда Коваленко ПП РА "Успіх Плюс"
       else if(rq_id = 2) then company_okpo = '30634380';
            --Компания Инвестиция
       else if(rq_id = 3) then company_okpo = '38449956';

       else company_okpo = '33302178';

      -- if (agid in (34,304,94,309,42,308,4,307,22,305)) then company_okpo = '30634380';

       if (AG_NAME is not null) then
       begin

         if (all_paid = 1) then
          ispaid = 1;
          else
           ispaid = 0;

         --SD_TYPE = 1
         if (SD_TYPE = 1) then
         begin
            -- Об'ява до газети "Пропоную роботу"
            if (GZID = 1) then
                SERV_ID = 1;

            -- Об'ява до газети "Пропоную оголошення"
            if (GZID = 2) then
                SERV_ID = 8;

            -- Об'ява до газети "Срочно требуются"
            if (GZID = 3) then
            begin
                -- "Срочно требуются"
              --  if (instanceid = 1) then
                    SERV_ID = 2;
             --   else
                -- "Пропоную оголошення"
             --       SERV_ID = 8;

            end

            -- Об'ява до газети "Робота для жiнок"
            if (GZID = 4) then
                SERV_ID = 4;

            -- Об'ява до газети "Работа в Киеве"
            if (GZID = 5) then
                SERV_ID = 15;    --08.06.2011

            select spd.PODACHA_NUMS
            from sdelka_podacha_nums_dates_1c(:AGID, :SDID, :DATE_FROM, :DATE_TO) spd
            into :PODACHA_NUMS_INSIDE1;

           -- if (SD_FACT_NUM = 122241 ) then podacha_nums_inside1 = '32 (2012-08-20), 33 (2012-09-20)';

         -- if (not (:podacha_nums_inside1 like '%0%(2000-01-01)%')) then
         suspend;
          end
--SD_TYPE = 1

        else if (SD_TYPE = 3) then
        begin
            -- Послуги кадрової агенцiї
            SERV_ID = 6;
            PODACHA_NUMS_INSIDE1 = LEFT('', 200);
            suspend;
        end
        else if (SD_TYPE in (4,6)) then
        begin
            -- Реклама у iнтернетi
            SERV_ID = 5;
            PODACHA_NUMS_INSIDE1 = LEFT('', 200);
            suspend;
        end
        else if (SD_TYPE = 5) then
        begin
            -- Об'ява до регiональної газети
            SERV_ID = 7;
            PODACHA_NUMS_INSIDE1 = LEFT('', 200);
            suspend;
        end

       end
      AG_NAME = null;
  end
end^


ALTER PROCEDURE TRANSPORT_DATA_1C (
    DATE_FROM TIMESTAMP,
    DATE_TO TIMESTAMP,
    ONLY_NOT_PAYED INTEGER)
RETURNS (
    FAC_NUM INTEGER,
    FAC_DATE TIMESTAMP,
    SERV_ID INTEGER,
    DESCRIPT VARCHAR(200),
    COST FLOAT,
    PAYED FLOAT,
    CUS_OKPO CHAR(10),
    CUS_NAME CHAR(128),
    PODACHA_NUMS_INSIDE VARCHAR(255))
AS
declare variable AGID integer;
declare variable SDID integer;
declare variable SD_TYPE integer;
declare variable PODACHA_NUMS varchar(128);
declare variable ONEISNAME varchar(10);
declare variable PDCOUNT integer;
declare variable SRAMOUNT integer;
declare variable SERVTYPE integer;
declare variable GZID integer;
declare variable SKIP_SERV smallint;
declare variable SRDESC varchar(1024);
declare variable SDCOUNT integer;
declare variable INSTANCEID integer;
declare variable CNT_TOTAL integer;
declare variable CNT_INSIDE integer;
declare variable AG_NAME varchar(128);
begin

    select p.pm_app_instance_no
    from params p
    into :instanceid;

     for
        select
            pd.AG_ID, pd.SD_ID, count(*)
        from
            ISSUE iss
            inner join PODACHA pd on (pd.IS_ID = iss.IS_ID)
        where
            iss.IS_DATE >= :DATE_FROM
            and iss.IS_DATE <= :DATE_TO

            --команда Коваленко ТОВ "Успіх Плюс"
            --and (pd.ag_id not in (34,304,94,309,42,308,4,307,22,305))
        group by
            pd.AG_ID, pd.SD_ID
        order by
            pd.AG_ID, pd.SD_ID
        into
            :AGID, :SDID, :CNT_INSIDE
    do
     begin

        select
            count(*)
        from
            PODACHA p
            inner join ISSUE i on (i.IS_ID = p.IS_ID)
        where
            p.AG_ID = :AGID
            and p.SD_ID = :SDID
        into
            :CNT_TOTAL;

       if (CNT_TOTAL >= CNT_INSIDE) then
        begin

        select
             a.ag_name                -- name of agent
            ,s.SD_FACT_NUM            /* номер счета-фактуры   */
            ,s.SD_FACT_DATE           /* дата счета-фактуры    */
            ,s.SD_SUM                 /* стоимость объявления  */
            ,s.SD_SUM_PAYED           /* оплачено              */
            ,c.CU_OKPO                /* ОКПО клиента          */
            ,c.CU_NAME                /* название клиента      */

            ,s.SD_TYPE
            ,s.GZ_ID
        from
                SDELKA s
                inner join AGENT a on (a.AG_ID = s.AG_ID)
                inner join CUST c on (c.AG_ID = s.AG_ID and c.CU_ID = s.CU_ID)
                inner join GAZETA g on (g.GZ_ID = s.GZ_ID)
                inner join PAY_TYPE pt on (pt.PT_ID = s.PT_ID)
        where
              (s.sd_fact_num is not null)
              and (s.ag_id = :agid)
              and (s.sd_id = :sdid)

              -- not payed:
              and (s.SD_STATE <> 100 )
              and (s.SD_STATE > 4 )
              and (S.AS_ID <> 2 )
              --без оплаты по кредиту
              --and pt.pt_id <> 3
              and (s.pt_id in (2,6)) --оплата по безналу + касса
              and (s.sd_all_payed = 0 or s.sd_all_payed is null)
        into
             :AG_NAME
            ,:FAC_NUM
            ,:FAC_DATE
            ,:COST
            ,:PAYED
            ,:CUS_OKPO
            ,:CUS_NAME
            ,:SD_TYPE
            ,:GZID;

    if (AG_NAME is not null) then
     begin

  --  </sdelka>
  --  <main>
        if (SD_TYPE = 1) then
        begin
            -- Об'ява до газети "Пропоную роботу"
            if (GZID = 1) then
                SERV_ID = 1;

            -- Об'ява до газети "Пропоную оголошення"
            if (GZID = 2) then
                SERV_ID = 8;

            -- Об'ява до газети "Срочно требуются"
            if (GZID = 3) then
            begin
                -- "Срочно требуются"
                if (instanceid = 1) then
                    SERV_ID = 2;
                else
                -- "Пропоную оголошення"
                    SERV_ID = 8;
            end

            -- Об'ява до газети "Робота для жiнок"
            if (GZID = 4) then
                SERV_ID = 4;

            -- Об'ява до газети "Работа в Киеве"
            if (GZID = 5) then
                SERV_ID = 15;    --08.06.2011
            --   SERV_ID = 1;  -- was changed
-- Подачи
            PODACHA_NUMS = '';
            PDCOUNT = 0;

            descript = '';

            select spd.PODACHA_NUMS
            from sdelka_podacha_nums_dates_1c(:AGID, :SDID, :DATE_FROM, :DATE_TO) spd
            into :PODACHA_NUMS_INSIDE;
-- подачи
            suspend;
        end
 /*
        else if (SD_TYPE = 3) then
        begin
            -- Послуги кадрової агенцiї
            SERV_ID = 6;
            DESCRIPT = F_LEFT('', 200);
         --   COST = SDSUM;
            suspend;
        end

        else if (SD_TYPE = 4) then
        begin
            -- Реклама у iнтернетi
            SERV_ID = 5;
            DESCRIPT = F_LEFT('', 200);
        --  COST = SDSUM;
            suspend;
        end

        else if (SD_TYPE = 5) then
        begin
            -- Об'ява до регiональної газети
            SERV_ID = 7;
            DESCRIPT = F_LEFT('', 200);
        --  COST = SDSUM;
            suspend;
        end

        else if (SD_TYPE = 6) then
        begin
        --</begin 3>
            -- Iншi послуги
            for
                select
                     cast(sr.SR_AMOUNT as integer)
                 -- ,sr.SR_SUM
                    ,sr.SR_TYPE
                    ,sr.SR_DESCRIPTION
                from
                    SERVICE sr

                    left join SERVICE_TYPE se
                    on (se.SE_ID = sr.SR_TYPE)
                where
                        sr.AG_ID = :AGID
                    and sr.SD_ID = :SDID
                into
                     :SRAMOUNT
                 -- ,:COST
                    ,:SERVTYPE
                    ,:SRDESC
            do
            begin
                --<begin 4>
                SKIP_SERV = 0;

                -- Друк
                if (SERVTYPE = 1) then
                    SERV_ID = 11;
                -- Вкладка ПР
                else if (SERVTYPE = 2) then
                    SERV_ID = 12;
                -- Вкладка РЖ
                else if (SERVTYPE = 3) then
                    SERV_ID = 12;
                -- Кур'єр
                else if (SERVTYPE = 4) then
                    SERV_ID = 13;
                -- _нше
                else if (SERVTYPE = 5) then
                    SKIP_SERV = 1;

                if (SKIP_SERV = 0) then
                begin

                --<begin 5>
                    if (SRAMOUNT > 0) then
                        DESCRIPT = 'Кiльк.:' || SRAMOUNT;

                    if (F_STRINGLENGTH(SRDESC) > 0) then
                    begin
                        if (F_STRINGLENGTH(DESCRIPT) > 0) then
                            DESCRIPT = DESCRIPT || '. ';

                        DESCRIPT = DESCRIPT || F_LEFT(SRDESC, 85);
                    end

                    suspend;
                --</begin 5>

                end

            --</begin 4>
            end
  --      </begin 3>
        end
        */
    --</main>
     end

   end
 end

end^


ALTER PROCEDURE UPD_NEW_CUSTS
RETURNS (
    NUM VARCHAR(64))
AS
declare variable AG_ID integer;
declare variable SD_ID integer;
declare variable CU_ID integer;
declare variable GZ_ID integer;
declare variable SD_DATE timestamp;
declare variable RES integer;
declare variable CUST_VAL integer;
begin
  /* Procedure Text */
  FOR SELECT s.AG_ID, s.SD_ID, s.CU_ID, s.GZ_ID, s.SD_DATE, s.SD_NUM, s.SD_NEW_CUST
      FROM SDELKA_WORKING_LIST swl
      LEFT JOIN SDELKA s ON (s.AG_ID = swl.AG_ID AND s.SD_ID = swl.SD_ID)
      WHERE swl.SD_STATE >= 2
     -- AND s.SD_NEW_CUST = 0
    -- AND s.SD_NUM IN ('584-689361')
      INTO :AG_ID, :SD_ID, :CU_ID, :GZ_ID, :SD_DATE, :NUM, :CUST_VAL DO
  BEGIN
       SELECT nc.result FROM CHECK_FOR_NEW_CUSTOMER(:AG_ID, :CU_ID, :SD_DATE, :GZ_ID) nc INTO :res;

       IF (RES <> CUST_VAL) THEN
       BEGIN
            UPdATE sdelka s
            SET s.SD_NEW_CUST = :res
            WHERE s.AG_ID = :AG_ID AND s.SD_ID = :SD_ID;

            INSERT INTO NEW_CUST_LOG(AG_ID, SD_ID, NEW_CUST_VALUE, EDIT_TIME)
            VALUES(:AG_ID, :SD_ID, :RES, CURRENT_TIMESTAMP);

            SUSPEND;
       END
  END
end^


ALTER PROCEDURE USER_LOGGED_IN (
    US_ID INTEGER,
    AG_ID INTEGER,
    HOST VARCHAR(64))
AS
declare variable USTYPE integer;
BEGIN
    INSERT INTO USER_LOGIN_LOG(US_ID,AG_ID,ULL_HOST)
    VALUES (:US_ID,:AG_ID,:HOST);

    SELECT US_TYPE FROM USR
    WHERE US_ID=:US_ID
    INTO :USTYPE;

    if (US_ID=124 or (:USTYPE IN (1,2) AND US_ID<>58)) then
        POST_EVENT 'USER_LOGGED_IN';
END^


ALTER PROCEDURE UTIL_FORMAT_DATE (
    DT DATE)
RETURNS (
    RES CHAR(10))
AS
BEGIN
   -- RES=F_DAYOFMONTH(DT)||'.'||F_MONTH(DT)||'.'||F_YEAR(DT);
    RES= (SELECT EXTRACT(DAY FROM :DT) ||'.'||
                 EXTRACT(MONTH FROM :DT)||'.'||
                 EXTRACT(YEAR FROM :DT)
          FROM rdb$database);
    SUSPEND;
END^


ALTER PROCEDURE WRONG_GAZETA
RETURNS (
    AG_ID INTEGER,
    SD_ID INTEGER)
AS
BEGIN
    FOR
        SELECT
            SD.AG_ID,SD.SD_ID
        FROM
            PODACHA PD
            LEFT JOIN SDELKA SD
            ON (PD.AG_ID=SD.AG_ID AND PD.SD_ID=SD.SD_ID)
            LEFT JOIN ISSUE ISS
            ON (PD.IS_ID=ISS.IS_ID)
        WHERE
            PD.GZ_ID<>SD.GZ_ID
        INTO
            :AG_ID,:SD_ID
    DO
        SUSPEND;
END^


ALTER PROCEDURE Z_DELETE_OLD_SDELKA (
    DATE_FROM DATE)
AS
declare variable PDCNT integer;
declare variable AGID integer;
declare variable SDID integer;
begin
/*
    Удалим все сделки, в которых нету объявлений, выходящих после
    указанной даты (для сделок в газеты), и сделки не в газеты,
    зарегистрированные после указанной даты
*/

/*
    Удаляем сделки не в газеты
*/

    delete from SDELKA
    where
        SD_TYPE in (3, 4, 5, 6)
        and SD_DATE < :DATE_FROM;

/*
    Перебираем все сделки, зарег-ные раньше указанной даты
*/
    for
        select
            sd.AG_ID, sd.SD_ID
        from
            SDELKA sd
        where
            sd.SD_TYPE = 1
            and sd.SD_DATE < :DATE_FROM
        into
            :agid, :sdid
    do
    begin
        /*
            Проверяем у сделки наличие подач после указанной даты
        */
        select count(*)
        from
            PODACHA pd left join ISSUE i on (i.IS_ID = pd.IS_ID)
        where
            pd.AG_ID = :agid
            and pd.SD_ID = :sdid
            and (
                i.IS_DATE > :DATE_FROM
                or i.IS_NAME = '0'
            )

        into
            :pdcnt;
        /*
            Удаляем сделку, если подач нету
        */
        if (pdcnt = 0) then
        begin
            delete from SDELKA sd
            where
                sd.AG_ID = :agid
                and sd.SD_ID = :sdid;
        end
    end

/*
    Теперь удалим контенты объявлений, на которые больше
    нет ссылок
*/
    delete from OBJAV_CONTENT_SITE_OBJAV so
    where not exists (
        select *
        from OBJAVLENIE ob
        where ob.CONTENT_ID = so.CONTENT_ID
    );

    delete from SITE_OBJAV so
    where not exists (
        select *
        from OBJAV_CONTENT_SITE_OBJAV ob
        where ob.SITE_OBJAV_ID = so.SITE_OBJAV_ID
    );

    delete from OBJAV_CONTENT oc
    where not exists (
        select *
        from OBJAVLENIE ob
        where ob.CONTENT_ID = oc.CONTENT_ID AND ob.OB_STATE <> 1
    );

end^



SET TERM ; ^


/******************************************************************************/
/***                              Descriptions                              ***/
/******************************************************************************/

DESCRIBE TABLE ADMIN_TOOLS
'Метаописание утилиты для администратора';

DESCRIBE TABLE AGENT
'Агент';

DESCRIBE TABLE CHANGE_AGENT_TASK
'Задача изменения агента у сделки';

DESCRIBE TABLE CUST
'Клиент';

DESCRIBE TABLE CUST_PHONE
'Телефоны клиентов';

DESCRIBE TABLE CUST_UNIQUE
'Юр. информация о клиентах';

DESCRIBE TABLE DISTRICT
'Район';

DESCRIBE TABLE FORMAT
'Формат объявления';

DESCRIBE TABLE FORMAT_COST
'Стоимость объявления формата в газете';

DESCRIBE TABLE GAZETA
'Газета';

DESCRIBE TABLE ISSUE
'Выход газеты';

DESCRIBE TABLE OBJAV
'Текстовое объявление';

DESCRIBE TABLE OBJAVLENIE
'Выход модульного объявления';

DESCRIBE TABLE OBJAVLENIE_DUPL
'Ссылки между объявлениями, означающие, что одно объявление является автоматической копией другого';

DESCRIBE TABLE OBJAVLENIE_LOG
'Записывает изменения состояний (OB_STATE или OB_STATE_TXT) у модульных объявлений
Внимание !!! OB_ID может быть как  same_code';

DESCRIBE TABLE OBJAV_CONTENT_LOAD_LOG
'Лог загрузки модулей дизайнерами';

DESCRIBE TABLE OBJAV_CONTENT_SITE_OBJAV
'Связь между модульным объявлением и набором объявлений на сайт';

DESCRIBE TABLE OBJAV_DUPL
'Ссылки между текстовыми объявлениями, означающие, что одно объявление является автоматической копией другого';

DESCRIBE TABLE REQUISITE
'Реквизиты фирм, от лица которых заключаются сделки';

DESCRIBE TABLE RESERVE_RECORD
'First 10 records are STATIC See Delphi Code For Static Cells';

DESCRIBE TABLE SDELKA_CHANGE_LOG
'Журнал изменения состояния сделки';

DESCRIBE TABLE SDELKA_DUPL
'Ссылки между сделками, означающие, что одна сделка является автоматической копией другой';

DESCRIBE TABLE SDELKA_DUPLICATE_SUM
'Соответствие стоимости сделки в одну газету и её дубля в другую';

DESCRIBE TABLE SDELKA_DUPLICATING
'Сделки, находящиеся в процессе дублирования';

DESCRIBE TABLE SERVICE
'Экземпляр услуги';

DESCRIBE TABLE SERVICE_TYPE
'Тип услуги';

DESCRIBE TABLE SITE_OBJAV
'Объявление на сайт';



/******************************************************************************/
/***                              Descriptions                              ***/
/******************************************************************************/

DESCRIBE PROCEDURE CLEAR_DOUBLES
'Удаляет дубли контрагентов см Программу синхронизации 1С и Принфо';

DESCRIBE PROCEDURE COPY_OBJAVLENIE
'NEW_CONTENT - Если повтор из другой газеты то нужно создавать новый контент иначе при изменении модуля 
в одной газете он будет менятся и в другой';

DESCRIBE PROCEDURE COPY_SITE_OBJAV
'Используеться для копирования объявлений для сайта см TfrmLoadPicture';

DESCRIBE PROCEDURE COPY_SITE_OBJAV_ID
'Используеться для копирования объявлений наборщицей см TframeContent';

DESCRIBE PROCEDURE IS_RIGHT_NAME_GAZETA
'сравниваем номер газеты, если он открыт "result=1"';

DESCRIBE PROCEDURE IS_RIGHT_NAME_GZ
'сравниваем номер газеты, если он открыт "result=1"';

DESCRIBE PROCEDURE MODULI_V_NOMER_2
'Можно использовать для выгрузки вышедших номеров';

DESCRIBE PROCEDURE OBJAV_LIST_V_INTERNET
'Выгрузка объявлений на сайт';

DESCRIBE PROCEDURE OBJAV_LIST_V_NOMER
'Текстовые объявления в номер';

DESCRIBE PROCEDURE REP_SDELKA_CROSSING_MONTH
'Длинные сделки в месяце (для актов)';

DESCRIBE PROCEDURE TRANSFE_SDELKA
'Длинные сделки в месяце (для актов)';



/******************************************************************************/
/***                          Fields descriptions                           ***/
/******************************************************************************/

DESCRIBE FIELD AT_PROC TABLE ADMIN_TOOLS
'Хранимая процедура утилиты';

DESCRIBE FIELD AT_PROC_PARAMS TABLE ADMIN_TOOLS
'Описание параметров процедуры';

DESCRIBE FIELD AT_RESULT_NAME TABLE ADMIN_TOOLS
'Заголовок для результата выполнения процедуры';

DESCRIBE FIELD AG_IS_REMOTE TABLE AGENT
'Работает в удаленном офисе?';

DESCRIBE FIELD AG_MAX_FACT_NUM TABLE AGENT
'Последний номер счета-фактуры';

DESCRIBE FIELD AG_FACTURA_PHONES TABLE AGENT
'Номера телефонов для вывода на счете-фактуре';

DESCRIBE FIELD AG_FACTURA_NAME TABLE AGENT
'Имя для печати на счете-фактуре';

DESCRIBE FIELD AG_LOCK_RUBRIKAS TABLE AGENT
'Блокировать этому агенту регистрацию в указанные менеджером рубрики?';

DESCRIBE FIELD CAN_USE_NEW_REQUISITES TABLE AGENT
'Может использовать новые реквизиты фирмы?';

DESCRIBE FIELD CU_BONUS_ENABLED TABLE CUST
'Подсчитывать бонусы для этого клиента?';

DESCRIBE FIELD FM_SPACE TABLE FORMAT
'Площадь';

DESCRIBE FIELD FM_ALWAYS_ADD_SUM TABLE FORMAT
'Всегда учитывать при рассчета стоимости сделки, даже если есть более дорогие объявления или дубли (например - сетка КА)';

DESCRIBE FIELD FM_HAS_PICTURE TABLE FORMAT
'Модульное объявление?';

DESCRIBE FIELD FM_PICTURE_SIZES TABLE FORMAT
'Возможные размеры модуля, в пикселях';

DESCRIBE FIELD OB_STATE TABLE OBJAV
'Состояние';

DESCRIBE FIELD OB_IS_ACTIVE TABLE OBJAV
'Публиковать?';

DESCRIBE FIELD OB_PARENT TABLE OBJAV
'Объявление, для которого данное является дублем';

DESCRIBE FIELD OB_ORDER TABLE OBJAV
'Порядок сортировки';

DESCRIBE FIELD OB_FOR_INTERNET TABLE OBJAV
'Публиковать в интернете?';

DESCRIBE FIELD OB_CHANGED TABLE OBJAV
'Было изменено после корректуры?';

DESCRIBE FIELD OB_VAC_COUNT TABLE OBJAV
'Количество вакансий в объявлении';

DESCRIBE FIELD OB_HAS_ATTENTION TABLE OBJAV
'Обратить внимание Выпускающему отделу';

DESCRIBE FIELD OB_IS_OPTIONAL TABLE OBJAV
'Не обязательное для публикации';

DESCRIBE FIELD OF_IS_REMOTE TABLE OFFICE
'Офис является удаленным (Пункт приема объявлений)';

DESCRIBE FIELD SD_ID TABLE PAID_SERVICES
'1- Prinfo2';

DESCRIBE FIELD PM_CURRENT_ISSUE_PR TABLE PARAMS
'Пропоную Роботу';

DESCRIBE FIELD PM_CURRENT_ISSUE_NS TABLE PARAMS
'Пропоную оголошення';

DESCRIBE FIELD PM_CURRENT_ISSUE_SR TABLE PARAMS
'Срочно требуются';

DESCRIBE FIELD PM_CURRENT_ISSUE_RZ TABLE PARAMS
'Работа для женщин';

DESCRIBE FIELD PM_CURRENT_ISSUE_RK TABLE PARAMS
'Робота в Києві';

DESCRIBE FIELD RQ_ID TABLE REQUISITE
'ID';

DESCRIBE FIELD RQ_NAME TABLE REQUISITE
'Название';

DESCRIBE FIELD RQ_FULL_NAME TABLE REQUISITE
'Название юр. лица';

DESCRIBE FIELD RQ_ACCOUNT TABLE REQUISITE
'Рассчетный счет';

DESCRIBE FIELD RQ_ADDRESS TABLE REQUISITE
'Юр. адрес';

DESCRIBE FIELD RQ_PHONES TABLE REQUISITE
'Телефоны';

DESCRIBE FIELD REGISTERED_BY_ID TABLE SDELKA
'ID пользователя, который зарегистрировал';

DESCRIBE FIELD SD_NUM TABLE SDELKA_DELETED
'Delete table later';

DESCRIBE FIELD REGISTERED_BY_ID TABLE SDELKA_WAS_DELETED
'ID пользователя, который зарегистрировал';

DESCRIBE FIELD SR_ID TABLE SERVICE
'ID';

DESCRIBE FIELD SR_AMOUNT TABLE SERVICE
'Тираж (количество)';

DESCRIBE FIELD SR_SUM TABLE SERVICE
'Стоимость';

DESCRIBE FIELD SR_TYPE TABLE SERVICE
'Тип';

DESCRIBE FIELD SR_DESCRIPTION TABLE SERVICE
'Описание';

DESCRIBE FIELD SE_ID TABLE SERVICE_TYPE
'ID';

DESCRIBE FIELD SE_NAME TABLE SERVICE_TYPE
'Название';

DESCRIBE FIELD US_OFFICE_NAME TABLE USR
'Название офиса (устарело, есть OF_ID)';

DESCRIBE FIELD US_IS_REMOTE TABLE USR
'Пользователь в удаленном офисе (устарело, есть OF_ID)';

DESCRIBE FIELD OF_ID TABLE USR
'ID офиса';



/******************************************************************************/
/***                        Parameters descriptions                         ***/
/******************************************************************************/

DESCRIBE PARAMETER OUT_NAME PROCEDURE REPORT_RESUME_WEEK_BY_CLIENT
'Агент';

